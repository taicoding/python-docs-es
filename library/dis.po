# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-21 16:38-0300\n"
"PO-Revision-Date: 2021-11-05 23:34+0800\n"
"Last-Translator: Rodrigo Tobar <rtobarc@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../Doc/library/dis.rst:2
#, fuzzy
msgid ":mod:`!dis` --- Disassembler for Python bytecode"
msgstr ":mod:`dis` --- Desensamblador para bytecode de Python"

#: ../Doc/library/dis.rst:7
msgid "**Source code:** :source:`Lib/dis.py`"
msgstr "**Código fuente:** :source:`Lib/dis.py`"

#: ../Doc/library/dis.rst:17
msgid ""
"The :mod:`dis` module supports the analysis of CPython :term:`bytecode` by "
"disassembling it. The CPython bytecode which this module takes as an input "
"is defined in the file :file:`Include/opcode.h` and used by the compiler and "
"the interpreter."
msgstr ""
"El módulo :mod:`dis` admite el análisis de CPython :term:`bytecode` al "
"desarmarlo. El bytecode de CPython que este módulo toma como entrada se "
"define en el archivo :file:`Include/opcode.h` y lo utilizan el compilador y "
"el intérprete."

#: ../Doc/library/dis.rst:24
msgid ""
"Bytecode is an implementation detail of the CPython interpreter.  No "
"guarantees are made that bytecode will not be added, removed, or changed "
"between versions of Python.  Use of this module should not be considered to "
"work across Python VMs or Python releases."
msgstr ""
"Bytecode es un detalle de implementación del intérprete CPython. No se "
"garantiza que el bytecode no se agregará, eliminará ni cambiará entre las "
"versiones de Python. El uso de este módulo no debe considerarse para "
"trabajar en diferentes máquinas virtuales Python o versiones de Python."

#: ../Doc/library/dis.rst:29
msgid ""
"Use 2 bytes for each instruction. Previously the number of bytes varied by "
"instruction."
msgstr ""
"Use 2 bytes para cada instrucción. Anteriormente, el número de bytes variaba "
"según la instrucción."

#: ../Doc/library/dis.rst:33
msgid ""
"The argument of jump, exception handling and loop instructions is now the "
"instruction offset rather than the byte offset."
msgstr ""
"El argumento de las instrucciones de salto, manejo de excepciones y bucle "
"ahora es el desplazamiento de instrucción en lugar del desplazamiento de "
"byte."

#: ../Doc/library/dis.rst:37
#, fuzzy
msgid ""
"Some instructions are accompanied by one or more inline cache entries, which "
"take the form of :opcode:`CACHE` instructions. These instructions are hidden "
"by default, but can be shown by passing ``show_caches=True`` to "
"any :mod:`dis` utility. Furthermore, the interpreter now adapts the bytecode "
"to specialize it for different runtime conditions. The adaptive bytecode can "
"be shown by passing ``adaptive=True``."
msgstr ""
"Algunas instrucciones van acompañadas de una o más entradas de caché en "
"línea, que adoptan la forma de instrucciones :opcode:`CACHE`. Estas "
"instrucciones están ocultas de forma predeterminada, pero se pueden mostrar "
"pasando ``show_caches=True`` a cualquier utilidad :mod:`dis`."

#: ../Doc/library/dis.rst:45
msgid ""
"The argument of a jump is the offset of the target instruction relative to "
"the instruction that appears immediately after the jump "
"instruction's :opcode:`CACHE` entries."
msgstr ""

#: ../Doc/library/dis.rst:50
msgid ""
"As a consequence, the presence of the :opcode:`CACHE` instructions is "
"transparent for forward jumps but needs to be taken into account when "
"reasoning about backward jumps."
msgstr ""

#: ../Doc/library/dis.rst:54
msgid ""
"The output shows logical labels rather than instruction offsets for jump "
"targets and exception handlers. The ``-O`` command line option and the "
"``show_offsets`` argument were added."
msgstr ""

#: ../Doc/library/dis.rst:59
#, fuzzy
msgid "Example: Given the function :func:`!myfunc`::"
msgstr "Ejemplo: dada la función :func:`myfunc`::"

#: ../Doc/library/dis.rst:61
msgid ""
"def myfunc(alist):\n"
"    return len(alist)"
msgstr ""

#: ../Doc/library/dis.rst:64
#, fuzzy
msgid ""
"the following command can be used to display the disassembly of :func:`!"
"myfunc`:"
msgstr ""
"el siguiente comando se puede utilizar para mostrar el desmontaje "
"de :func:`myfunc`:"

#: ../Doc/library/dis.rst:67
msgid ""
">>> dis.dis(myfunc)\n"
"  2           RESUME                   0\n"
"\n"
"  3           LOAD_GLOBAL              1 (len + NULL)\n"
"              LOAD_FAST                0 (alist)\n"
"              CALL                     1\n"
"              RETURN_VALUE"
msgstr ""

#: ../Doc/library/dis.rst:77
msgid "(The \"2\" is a line number)."
msgstr "(El \"2\" es un número de línea)."

#: ../Doc/library/dis.rst:82
msgid "Command-line interface"
msgstr ""

#: ../Doc/library/dis.rst:84
msgid "The :mod:`dis` module can be invoked as a script from the command line:"
msgstr ""

#: ../Doc/library/dis.rst:86
msgid "python -m dis [-h] [-C] [-O] [infile]"
msgstr ""

#: ../Doc/library/dis.rst:90
msgid "The following options are accepted:"
msgstr ""

#: ../Doc/library/dis.rst:96
msgid "Display usage and exit."
msgstr ""

#: ../Doc/library/dis.rst:100
msgid "Show inline caches."
msgstr ""

#: ../Doc/library/dis.rst:104
#, fuzzy
msgid "Show offsets of instructions."
msgstr "Instrucciones bytecode de Python"

#: ../Doc/library/dis.rst:106
msgid ""
"If :file:`infile` is specified, its disassembled code will be written to "
"stdout. Otherwise, disassembly is performed on compiled source code received "
"from stdin."
msgstr ""

#: ../Doc/library/dis.rst:110
msgid "Bytecode analysis"
msgstr "Análisis de bytecode"

#: ../Doc/library/dis.rst:114
msgid ""
"The bytecode analysis API allows pieces of Python code to be wrapped in "
"a :class:`Bytecode` object that provides easy access to details of the "
"compiled code."
msgstr ""
"La API de análisis de bytecode permite que partes del código Python se "
"envuelvan en un objeto :class:`Bytecode` que proporciona un fácil acceso a "
"los detalles del código compilado."

#: ../Doc/library/dis.rst:121
msgid ""
"Analyse the bytecode corresponding to a function, generator, asynchronous "
"generator, coroutine, method, string of source code, or a code object (as "
"returned by :func:`compile`)."
msgstr ""
"Analiza el bytecode correspondiente a una función, generador, generador "
"asíncrono, corutina, método, cadena de código fuente o un objeto de código "
"(como lo retorna :func:`compile`)."

#: ../Doc/library/dis.rst:125
msgid ""
"This is a convenience wrapper around many of the functions listed below, "
"most notably :func:`get_instructions`, as iterating over a :class:`Bytecode` "
"instance yields the bytecode operations as :class:`Instruction` instances."
msgstr ""
"Este es un contenedor conveniente para muchas de las funciones enumeradas a "
"continuación, en particular :func:`get_instructions`, ya que iterar sobre "
"una instancia de :class:`Bytecode` produce las operaciones de bytecode como "
"instancias de :class:`Instruction`."

#: ../Doc/library/dis.rst:129 ../Doc/library/dis.rst:326
msgid ""
"If *first_line* is not ``None``, it indicates the line number that should be "
"reported for the first source line in the disassembled code.  Otherwise, the "
"source line information (if any) is taken directly from the disassembled "
"code object."
msgstr ""
"Si *first_line* no es ``None``, indica el número de línea que se debe "
"informar para la primera línea de origen en el código desmontado. De lo "
"contrario, la información de la línea de origen (si la hay) se toma "
"directamente del objeto de código desmontado."

#: ../Doc/library/dis.rst:134
msgid ""
"If *current_offset* is not ``None``, it refers to an instruction offset in "
"the disassembled code. Setting this means :meth:`.dis` will display a "
"\"current instruction\" marker against the specified opcode."
msgstr ""
"Si *current_offset* no es ``None``, se refiere a un desplazamiento de "
"instrucción en el código desmontado. Establecer esto significa :meth:`.dis` "
"mostrará un marcador de \"instrucción actual\" contra el código de operación "
"especificado."

#: ../Doc/library/dis.rst:138
msgid ""
"If *show_caches* is ``True``, :meth:`.dis` will display inline cache entries "
"used by the interpreter to specialize the bytecode."
msgstr ""

#: ../Doc/library/dis.rst:141
msgid ""
"If *adaptive* is ``True``, :meth:`.dis` will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""

#: ../Doc/library/dis.rst:144
msgid ""
"If *show_offsets* is ``True``, :meth:`.dis` will include instruction offsets "
"in the output."
msgstr ""

#: ../Doc/library/dis.rst:149
msgid ""
"Construct a :class:`Bytecode` instance from the given traceback, setting "
"*current_offset* to the instruction responsible for the exception."
msgstr ""
"Construye una instancia de :class:`Bytecode` a partir del *traceback* dado, "
"estableciendo *current_offset* en la instrucción responsable de la excepción."

#: ../Doc/library/dis.rst:154
msgid "The compiled code object."
msgstr "El objeto de código compilado."

#: ../Doc/library/dis.rst:158
msgid "The first source line of the code object (if available)"
msgstr "La primera línea de origen del objeto de código (si está disponible)"

#: ../Doc/library/dis.rst:162
msgid ""
"Return a formatted view of the bytecode operations (the same as printed "
"by :func:`dis.dis`, but returned as a multi-line string)."
msgstr ""
"Retorna una vista formateada de las operaciones de bytecode (lo mismo que "
"impreso por :func:`dis.dis`, pero retornado como una cadena de caracteres "
"multilínea)."

#: ../Doc/library/dis.rst:167
msgid ""
"Return a formatted multi-line string with detailed information about the "
"code object, like :func:`code_info`."
msgstr ""
"Retorna una cadena de caracteres multilínea formateada con información "
"detallada sobre el objeto de código, como :func:`code_info`."

#: ../Doc/library/dis.rst:170 ../Doc/library/dis.rst:210
#: ../Doc/library/dis.rst:262
msgid "This can now handle coroutine and asynchronous generator objects."
msgstr ""
"Esto ahora puede manejar objetos generadores asíncronos y de corutinas."

#: ../Doc/library/dis.rst:173 ../Doc/library/dis.rst:265
#: ../Doc/library/dis.rst:282 ../Doc/library/dis.rst:312
#: ../Doc/library/dis.rst:335
#, fuzzy
msgid "Added the *show_caches* and *adaptive* parameters."
msgstr "Se agregó el parámetro ``show_caches``."

#: ../Doc/library/dis.rst:176
msgid "Example:"
msgstr "Ejemplo:"

#: ../Doc/library/dis.rst:178
msgid ""
">>> bytecode = dis.Bytecode(myfunc)\n"
">>> for instr in bytecode:\n"
"...     print(instr.opname)\n"
"...\n"
"RESUME\n"
"LOAD_GLOBAL\n"
"LOAD_FAST\n"
"CALL\n"
"RETURN_VALUE"
msgstr ""

#: ../Doc/library/dis.rst:192
msgid "Analysis functions"
msgstr "Funciones de análisis"

#: ../Doc/library/dis.rst:194
msgid ""
"The :mod:`dis` module also defines the following analysis functions that "
"convert the input directly to the desired output. They can be useful if only "
"a single operation is being performed, so the intermediate analysis object "
"isn't useful:"
msgstr ""
"El módulo :mod:`dis` también define las siguientes funciones de análisis que "
"convierten la entrada directamente en la salida deseada. Pueden ser útiles "
"si solo se realiza una sola operación, por lo que el objeto de análisis "
"intermedio no es útil:"

#: ../Doc/library/dis.rst:200
msgid ""
"Return a formatted multi-line string with detailed code object information "
"for the supplied function, generator, asynchronous generator, coroutine, "
"method, source code string or code object."
msgstr ""
"Retorna una cadena de caracteres multilínea formateada con información "
"detallada del objeto de código para la función, generador, generador "
"asíncrono, corutina, método, cadena de código fuente u objeto de código "
"suministrados."

#: ../Doc/library/dis.rst:204
msgid ""
"Note that the exact contents of code info strings are highly implementation "
"dependent and they may change arbitrarily across Python VMs or Python "
"releases."
msgstr ""
"Tenga en cuenta que el contenido exacto de las cadenas de información de "
"código depende en gran medida de la implementación y puede cambiar "
"arbitrariamente en las diferentes máquinas virtuales Python o las versiones "
"de Python."

#: ../Doc/library/dis.rst:216
msgid ""
"Print detailed code object information for the supplied function, method, "
"source code string or code object to *file* (or ``sys.stdout`` if *file* is "
"not specified)."
msgstr ""
"Imprime información detallada del objeto de código para la función, método, "
"cadena de código fuente u objeto de código suministrado en *file* (o "
"``sys.stdout`` si *file* no está especificado)."

#: ../Doc/library/dis.rst:220
msgid ""
"This is a convenient shorthand for ``print(code_info(x), file=file)``, "
"intended for interactive exploration at the interpreter prompt."
msgstr ""
"Esta es una abreviatura conveniente para ``print(code_info(x), file=file)``, "
"destinado a la exploración interactiva en el indicador del intérprete "
"(*prompt*)."

#: ../Doc/library/dis.rst:225 ../Doc/library/dis.rst:256
#: ../Doc/library/dis.rst:279 ../Doc/library/dis.rst:309
msgid "Added *file* parameter."
msgstr "Agrega un parámetro *file*."

#: ../Doc/library/dis.rst:231
#, fuzzy
msgid ""
"Disassemble the *x* object.  *x* can denote either a module, a class, a "
"method, a function, a generator, an asynchronous generator, a coroutine, a "
"code object, a string of source code or a byte sequence of raw bytecode. For "
"a module, it disassembles all functions. For a class, it disassembles all "
"methods (including class and static methods). For a code object or sequence "
"of raw bytecode, it prints one line per bytecode instruction. It also "
"recursively disassembles nested code objects. These can include generator "
"expressions, nested functions, the bodies of nested classes, and the code "
"objects used for :ref:`annotation scopes <annotation-scopes>`. Strings are "
"first compiled to code objects with the :func:`compile` built-in function "
"before being disassembled.  If no object is provided, this function "
"disassembles the last traceback."
msgstr ""
"Desmontar el objeto *x*. *x* puede denotar un módulo, una clase, un método, "
"una función, un generador, un generador asíncrono, una corutina, un objeto "
"de código, una cadena de código fuente o una secuencia de bytes de código de "
"bytes sin procesar. Para un módulo, desmonta todas las funciones. Para una "
"clase, desmonta todos los métodos (incluidos los métodos de clase y "
"estáticos). Para un objeto de código o secuencia de bytecode sin procesar, "
"imprime una línea por instrucción de bytecode. También desmonta "
"recursivamente objetos de código anidados (el código de comprensiones, "
"expresiones generadoras y funciones anidadas, y el código utilizado para "
"construir clases anidadas). Las cadenas de caracteres se compilan primero en "
"objetos de código con la función incorporada :func:`compile` antes de "
"desmontarse. Si no se proporciona ningún objeto, esta función desmonta el "
"último rastreo."

#: ../Doc/library/dis.rst:244 ../Doc/library/dis.rst:276
#: ../Doc/library/dis.rst:306
msgid ""
"The disassembly is written as text to the supplied *file* argument if "
"provided and to ``sys.stdout`` otherwise."
msgstr ""
"El desensamblaje se escribe como texto en el argumento *file* proporcionado "
"si se proporciona y, de lo contrario, ``sys.stdout``."

#: ../Doc/library/dis.rst:247
msgid ""
"The maximal depth of recursion is limited by *depth* unless it is ``None``. "
"``depth=0`` means no recursion."
msgstr ""
"La profundidad máxima de recursión está limitada por *depth* a menos que sea "
"``None``. ``depth=0`` significa que no hay recursión."

#: ../Doc/library/dis.rst:250
msgid ""
"If *show_caches* is ``True``, this function will display inline cache "
"entries used by the interpreter to specialize the bytecode."
msgstr ""

#: ../Doc/library/dis.rst:253
msgid ""
"If *adaptive* is ``True``, this function will display specialized bytecode "
"that may be different from the original bytecode."
msgstr ""

#: ../Doc/library/dis.rst:259
msgid "Implemented recursive disassembling and added *depth* parameter."
msgstr "Desensamblaje recursivo implementado y parámetro agregado *depth*."

#: ../Doc/library/dis.rst:272
msgid ""
"Disassemble the top-of-stack function of a traceback, using the last "
"traceback if none was passed.  The instruction causing the exception is "
"indicated."
msgstr ""
"Desmonta la función de inicio de pila de un rastreo, utilizando el último "
"rastreo si no se pasó ninguno. Se indica la instrucción que causa la "
"excepción."

#: ../Doc/library/dis.rst:285 ../Doc/library/dis.rst:315
#, fuzzy
msgid "Added the *show_offsets* parameter."
msgstr "Agrega un parámetro *file*."

#: ../Doc/library/dis.rst:292
msgid ""
"Disassemble a code object, indicating the last instruction if *lasti* was "
"provided.  The output is divided in the following columns:"
msgstr ""
"Desmonta un objeto de código, que indica la última instrucción si se "
"proporcionó *lasti*. La salida se divide en las siguientes columnas:"

#: ../Doc/library/dis.rst:295
msgid "the line number, for the first instruction of each line"
msgstr "el número de línea, para la primera instrucción de cada línea"

#: ../Doc/library/dis.rst:296
msgid "the current instruction, indicated as ``-->``,"
msgstr "la instrucción actual, indicada como ``-->``,"

#: ../Doc/library/dis.rst:297
msgid "a labelled instruction, indicated with ``>>``,"
msgstr "una instrucción etiquetada, indicada con ``>>``,"

#: ../Doc/library/dis.rst:298
msgid "the address of the instruction,"
msgstr "la dirección de la instrucción,"

#: ../Doc/library/dis.rst:299
msgid "the operation code name,"
msgstr "el nombre del código de operación,"

#: ../Doc/library/dis.rst:300
msgid "operation parameters, and"
msgstr "parámetros de operación, y"

#: ../Doc/library/dis.rst:301
msgid "interpretation of the parameters in parentheses."
msgstr "interpretación de los parámetros entre paréntesis."

#: ../Doc/library/dis.rst:303
msgid ""
"The parameter interpretation recognizes local and global variable names, "
"constant values, branch targets, and compare operators."
msgstr ""
"La interpretación de parámetros reconoce nombres de variables locales y "
"globales, valores constantes, objetivos de ramificación y operadores de "
"comparación."

#: ../Doc/library/dis.rst:320
msgid ""
"Return an iterator over the instructions in the supplied function, method, "
"source code string or code object."
msgstr ""
"Retorna un iterador sobre las instrucciones en la función, método, cadena de "
"código fuente u objeto de código suministrado."

#: ../Doc/library/dis.rst:323
msgid ""
"The iterator generates a series of :class:`Instruction` named tuples giving "
"the details of each operation in the supplied code."
msgstr ""
"El iterador genera una serie de tuplas con nombre :class:`Instruction` que "
"dan los detalles de cada operación en el código suministrado."

#: ../Doc/library/dis.rst:331
msgid "The *adaptive* parameter works as it does in :func:`dis`."
msgstr ""

#: ../Doc/library/dis.rst:338
msgid ""
"The *show_caches* parameter is deprecated and has no effect. The iterator "
"generates the :class:`Instruction` instances with the *cache_info* field "
"populated (regardless of the value of *show_caches*) and it no longer "
"generates separate items for the cache entries."
msgstr ""

#: ../Doc/library/dis.rst:346
#, fuzzy
msgid ""
"This generator function uses the :meth:`~codeobject.co_lines` method of "
"the :ref:`code object <code-objects>` *code* to find the offsets which are "
"starts of lines in the source code.  They are generated as ``(offset, "
"lineno)`` pairs."
msgstr ""
"Esta función generadora utiliza el método ``co_lines`` del objeto de código "
"*code* para encontrar las compensaciones que son los comienzos de las líneas "
"en el código fuente. Se generan como pares ``(offset, lineno)``."

#: ../Doc/library/dis.rst:351
msgid "Line numbers can be decreasing. Before, they were always increasing."
msgstr ""
"Los números de línea pueden estar disminuyendo. Antes, siempre estaban "
"aumentando."

#: ../Doc/library/dis.rst:354
#, fuzzy
msgid ""
"The :pep:`626` :meth:`~codeobject.co_lines` method is used instead of "
"the :attr:`~codeobject.co_firstlineno` and :attr:`~codeobject.co_lnotab` "
"attributes of the :ref:`code object <code-objects>`."
msgstr ""
"Se utiliza el método :pep:`626` ``co_lines`` en lugar de los atributos "
"``co_firstlineno`` y ``co_lnotab`` del objeto de código."

#: ../Doc/library/dis.rst:359
msgid ""
"Line numbers can be ``None`` for bytecode that does not map to source lines."
msgstr ""

#: ../Doc/library/dis.rst:365
msgid ""
"Detect all offsets in the raw compiled bytecode string *code* which are jump "
"targets, and return a list of these offsets."
msgstr ""
"Detecta todos los desplazamientos en la cadena de caracteres de código de "
"byte compilada *code* que son objetivos de salto y retorna una lista de "
"estos desplazamientos."

#: ../Doc/library/dis.rst:371
msgid "Compute the stack effect of *opcode* with argument *oparg*."
msgstr "Calcula el efecto de pila de *opcode* con el argumento *oparg*."

#: ../Doc/library/dis.rst:373
msgid ""
"If the code has a jump target and *jump* is ``True``, :func:`~stack_effect` "
"will return the stack effect of jumping.  If *jump* is ``False``, it will "
"return the stack effect of not jumping. And if *jump* is ``None`` (default), "
"it will return the maximal stack effect of both cases."
msgstr ""
"Si el código tiene un objetivo de salto y *jump* es "
"``True``, :func:`~stack_effect` retornará el efecto de pila del salto. Si "
"*jump* es ``False``, retornará el efecto de acumulación de no saltar. Y si "
"*jump* es ``None`` (predeterminado), retornará el efecto de acumulación "
"máxima de ambos casos."

#: ../Doc/library/dis.rst:380
msgid "Added *jump* parameter."
msgstr "Agrega un parámetro *jump*."

#: ../Doc/library/dis.rst:383
msgid ""
"If ``oparg`` is omitted (or ``None``), the stack effect is now returned for "
"``oparg=0``. Previously this was an error for opcodes that use their arg. It "
"is also no longer an error to pass an integer ``oparg`` when the ``opcode`` "
"does not use it; the ``oparg`` in this case is ignored."
msgstr ""

#: ../Doc/library/dis.rst:393
msgid "Python Bytecode Instructions"
msgstr "Instrucciones bytecode de Python"

#: ../Doc/library/dis.rst:395
msgid ""
"The :func:`get_instructions` function and :class:`Bytecode` class provide "
"details of bytecode instructions as :class:`Instruction` instances:"
msgstr ""
"La función :func:`get_instructions` y clase :class:`Bytecode` proporcionan "
"detalles de las instrucciones bytecode como instancias :class:`Instruction`:"

#: ../Doc/library/dis.rst:400
msgid "Details for a bytecode operation"
msgstr "Detalles para una operación de bytecode"

#: ../Doc/library/dis.rst:404
msgid ""
"numeric code for operation, corresponding to the opcode values listed below "
"and the bytecode values in the :ref:`opcode_collections`."
msgstr ""
"código numérico para la operación, correspondiente a los valores del opcode "
"listados a continuación y los valores de bytecode "
"en :ref:`opcode_collections`."

#: ../Doc/library/dis.rst:410
msgid "human readable name for operation"
msgstr "nombre legible por humanos para la operación"

#: ../Doc/library/dis.rst:415
msgid ""
"numeric code for the base operation if operation is specialized; otherwise "
"equal to :data:`opcode`"
msgstr ""

#: ../Doc/library/dis.rst:421
msgid ""
"human readable name for the base operation if operation is specialized; "
"otherwise equal to :data:`opname`"
msgstr ""

#: ../Doc/library/dis.rst:427
msgid "numeric argument to operation (if any), otherwise ``None``"
msgstr ""
"argumento numérico para la operación (si existe), de lo contrario ``None``"

#: ../Doc/library/dis.rst:431
msgid "alias for :data:`arg`"
msgstr ""

#: ../Doc/library/dis.rst:435
msgid "resolved arg value (if any), otherwise ``None``"
msgstr "valor de argumento resuelto (si lo hay); de lo contrario, ``None``"

#: ../Doc/library/dis.rst:440
msgid ""
"human readable description of operation argument (if any), otherwise an "
"empty string."
msgstr ""
"descripción legible por humanos del argumento de la operación (si lo hay); "
"de lo contrario, una cadena vacía."

#: ../Doc/library/dis.rst:446
msgid "start index of operation within bytecode sequence"
msgstr "índice de inicio de operación dentro de la secuencia de bytecode"

#: ../Doc/library/dis.rst:451
msgid ""
"start index of operation within bytecode sequence, including prefixed "
"``EXTENDED_ARG`` operations if present; otherwise equal to :data:`offset`"
msgstr ""

#: ../Doc/library/dis.rst:457
msgid "start index of the cache entries following the operation"
msgstr ""

#: ../Doc/library/dis.rst:462
msgid "end index of the cache entries following the operation"
msgstr ""

#: ../Doc/library/dis.rst:467
#, fuzzy
msgid "``True`` if this opcode starts a source line, otherwise ``False``"
msgstr "``True`` si otro código salta aquí, de lo contrario, ``False``"

#: ../Doc/library/dis.rst:472
#, fuzzy
msgid ""
"source line number associated with this opcode (if any), otherwise ``None``"
msgstr ""
"línea iniciada por este código de operación (si existe), de lo contrario "
"``None``"

#: ../Doc/library/dis.rst:477
msgid "``True`` if other code jumps to here, otherwise ``False``"
msgstr "``True`` si otro código salta aquí, de lo contrario, ``False``"

#: ../Doc/library/dis.rst:482
msgid ""
"bytecode index of the jump target if this is a jump operation, otherwise "
"``None``"
msgstr ""

#: ../Doc/library/dis.rst:488
msgid ""
":class:`dis.Positions` object holding the start and end locations that are "
"covered by this instruction."
msgstr ""
"Objeto :class:`dis.Positions` que contiene las ubicaciones de inicio y "
"finalización cubiertas por esta instrucción."

#: ../Doc/library/dis.rst:503
msgid "Field ``positions`` is added."
msgstr "Se agrega el campo ``positions``."

#: ../Doc/library/dis.rst:507
msgid "Changed field ``starts_line``."
msgstr ""

#: ../Doc/library/dis.rst:509
msgid ""
"Added fields ``start_offset``, ``cache_offset``, ``end_offset``, "
"``baseopname``, ``baseopcode``, ``jump_target``, ``oparg``, ``line_number`` "
"and ``cache_info``."
msgstr ""

#: ../Doc/library/dis.rst:516
msgid ""
"In case the information is not available, some fields might be ``None``."
msgstr ""
"En caso de que la información no esté disponible, algunos campos pueden ser "
"``None``."

#: ../Doc/library/dis.rst:526
msgid ""
"The Python compiler currently generates the following bytecode instructions."
msgstr ""
"El compilador de Python actualmente genera las siguientes instrucciones de "
"bytecode."

#: ../Doc/library/dis.rst:529
msgid "**General instructions**"
msgstr "**Instrucciones generales**"

#: ../Doc/library/dis.rst:531
msgid ""
"In the following, We will refer to the interpreter stack as ``STACK`` and "
"describe operations on it as if it was a Python list. The top of the stack "
"corresponds to ``STACK[-1]`` in this language."
msgstr ""

#: ../Doc/library/dis.rst:537
msgid ""
"Do nothing code.  Used as a placeholder by the bytecode optimizer, and to "
"generate line tracing events."
msgstr ""
"Código que no hace nada. Utilizado como marcador de posición por el "
"optimizador de bytecode y para generar eventos de seguimiento de línea."

#: ../Doc/library/dis.rst:543
#, fuzzy
msgid "Removes the top-of-stack item::"
msgstr "Elimina el elemento de la parte superior de la pila (TOS)."

#: ../Doc/library/dis.rst:545
msgid "STACK.pop()"
msgstr ""

#: ../Doc/library/dis.rst:550
msgid ""
"Removes the top-of-stack item. Equivalent to ``POP_TOP``. Used to clean up "
"at the end of loops, hence the name."
msgstr ""

#: ../Doc/library/dis.rst:559
msgid "Implements ``del STACK[-2]``. Used to clean up when a generator exits."
msgstr ""

#: ../Doc/library/dis.rst:567
#, fuzzy
msgid ""
"Push the i-th item to the top of the stack without removing it from its "
"original location::"
msgstr ""
"Empuje el elemento *i*-th a la parte superior de la pila. El elemento no se "
"elimina de su ubicación original."

#: ../Doc/library/dis.rst:570
msgid ""
"assert i > 0\n"
"STACK.append(STACK[-i])"
msgstr ""

#: ../Doc/library/dis.rst:578
msgid "Swap the top of the stack with the i-th element::"
msgstr ""

#: ../Doc/library/dis.rst:580
msgid "STACK[-i], STACK[-1] = STACK[-1], STACK[-i]"
msgstr ""

#: ../Doc/library/dis.rst:587
msgid ""
"Rather than being an actual instruction, this opcode is used to mark extra "
"space for the interpreter to cache useful data directly in the bytecode "
"itself. It is automatically hidden by all ``dis`` utilities, but can be "
"viewed with ``show_caches=True``."
msgstr ""
"En lugar de ser una instrucción real, este código de operación se usa para "
"marcar espacio adicional para que el intérprete almacene en caché datos "
"útiles directamente en el bytecode. Todas las utilidades ``dis`` lo ocultan "
"automáticamente, pero se puede ver con ``show_caches=True``."

#: ../Doc/library/dis.rst:592
msgid ""
"Logically, this space is part of the preceding instruction. Many opcodes "
"expect to be followed by an exact number of caches, and will instruct the "
"interpreter to skip over them at runtime."
msgstr ""
"Lógicamente, este espacio forma parte de la instrucción anterior. Muchos "
"códigos de operación esperan ser seguidos por un número exacto de cachés y "
"le indicarán al intérprete que los omita en tiempo de ejecución."

#: ../Doc/library/dis.rst:596
msgid ""
"Populated caches can look like arbitrary instructions, so great care should "
"be taken when reading or modifying raw, adaptive bytecode containing "
"quickened data."
msgstr ""
"Los cachés poblados pueden parecer instrucciones arbitrarias, por lo que se "
"debe tener mucho cuidado al leer o modificar el bytecode adaptativo sin "
"procesar que contiene datos acelerados."

#: ../Doc/library/dis.rst:603
msgid "**Unary operations**"
msgstr "**Operaciones unarias**"

#: ../Doc/library/dis.rst:605
msgid ""
"Unary operations take the top of the stack, apply the operation, and push "
"the result back on the stack."
msgstr ""
"Las operaciones unarias toman la parte superior de la pila, aplican la "
"operación y retornan el resultado a la pila."

#: ../Doc/library/dis.rst:611
#, fuzzy
msgid "Implements ``STACK[-1] = -STACK[-1]``."
msgstr "Implementa ``TOS = -TOS``."

#: ../Doc/library/dis.rst:616
#, fuzzy
msgid "Implements ``STACK[-1] = not STACK[-1]``."
msgstr "Implementa ``TOS = not TOS``."

#: ../Doc/library/dis.rst:618 ../Doc/library/dis.rst:1313
#: ../Doc/library/dis.rst:1329
msgid "This instruction now requires an exact :class:`bool` operand."
msgstr ""

#: ../Doc/library/dis.rst:624
#, fuzzy
msgid "Implements ``STACK[-1] = ~STACK[-1]``."
msgstr "Implementa ``TOS = ~TOS``."

#: ../Doc/library/dis.rst:629
#, fuzzy
msgid "Implements ``STACK[-1] = iter(STACK[-1])``."
msgstr "Implementa ``TOS = iter(TOS)``."

#: ../Doc/library/dis.rst:634
#, fuzzy
msgid ""
"If ``STACK[-1]`` is a :term:`generator iterator` or :term:`coroutine` object "
"it is left as is.  Otherwise, implements ``STACK[-1] = iter(STACK[-1])``."
msgstr ""
"Si ``TOS`` es un :term:`iterador generador <generator iterator>` o un "
"objeto :term:`corutina <coroutine>` se deja como está. De lo contrario, "
"implementa ``TOS = iter(TOS)``."

#: ../Doc/library/dis.rst:642
#, fuzzy
msgid "Implements ``STACK[-1] = bool(STACK[-1])``."
msgstr "Implementa ``TOS = ~TOS``."

#: ../Doc/library/dis.rst:647
msgid "**Binary and in-place operations**"
msgstr "**Operaciones binarias e in situ**"

#: ../Doc/library/dis.rst:649
#, fuzzy
msgid ""
"Binary operations remove the top two items from the stack (``STACK[-1]`` and "
"``STACK[-2]``). They perform the operation, then put the result back on the "
"stack."
msgstr ""
"Las operaciones binarias eliminan el elemento superior de la pila (TOS) y el "
"segundo elemento de la pila superior (TOS1) de la pila. Realizan la "
"operación y retornan el resultado a la pila."

#: ../Doc/library/dis.rst:652
#, fuzzy
msgid ""
"In-place operations are like binary operations, but the operation is done in-"
"place when ``STACK[-2]`` supports it, and the resulting ``STACK[-1]`` may be "
"(but does not have to be) the original ``STACK[-2]``."
msgstr ""
"Las operaciones en el lugar son como operaciones binarias, ya que eliminan "
"TOS y TOS1, y retornan el resultado a la pila, pero la operación se realiza "
"en el lugar cuando TOS1 lo admite, y el TOS resultante puede ser (pero no "
"tiene ser) el TOS1 original."

#: ../Doc/library/dis.rst:659
#, fuzzy
msgid ""
"Implements the binary and in-place operators (depending on the value of "
"*op*)::"
msgstr "Implementa los operadores binarios e in situ (según el valor de *op*)."

#: ../Doc/library/dis.rst:662
msgid ""
"rhs = STACK.pop()\n"
"lhs = STACK.pop()\n"
"STACK.append(lhs op rhs)"
msgstr ""

#: ../Doc/library/dis.rst:671 ../Doc/library/dis.rst:680
#: ../Doc/library/dis.rst:690 ../Doc/library/dis.rst:698
#: ../Doc/library/dis.rst:710 ../Doc/library/dis.rst:798
#: ../Doc/library/dis.rst:808 ../Doc/library/dis.rst:818
#: ../Doc/library/dis.rst:1041 ../Doc/library/dis.rst:1052
#: ../Doc/library/dis.rst:1156 ../Doc/library/dis.rst:1168
#: ../Doc/library/dis.rst:1180
msgid "Implements::"
msgstr ""

#: ../Doc/library/dis.rst:673
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[key])"
msgstr ""

#: ../Doc/library/dis.rst:682
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"value = STACK.pop()\n"
"container[key] = value"
msgstr ""

#: ../Doc/library/dis.rst:692
msgid ""
"key = STACK.pop()\n"
"container = STACK.pop()\n"
"del container[key]"
msgstr ""

#: ../Doc/library/dis.rst:700
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"STACK.append(container[start:end])"
msgstr ""

#: ../Doc/library/dis.rst:712
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"container = STACK.pop()\n"
"values = STACK.pop()\n"
"container[start:end] = value"
msgstr ""

#: ../Doc/library/dis.rst:721
msgid "**Coroutine opcodes**"
msgstr "**Opcodes de corutinas**"

#: ../Doc/library/dis.rst:725
#, fuzzy
msgid ""
"Implements ``STACK[-1] = get_awaitable(STACK[-1])``, where "
"``get_awaitable(o)`` returns ``o`` if ``o`` is a coroutine object or a "
"generator object with the :data:`~inspect.CO_ITERABLE_COROUTINE` flag, or "
"resolves ``o.__await__``."
msgstr ""
"Implementa ``TOS = get_awaitable(TOS)``, donde ``get_awaitable(o)`` retorna "
"``o`` si ``o`` es un objeto de corutina o un objeto generador con el "
"indicador CO_ITERABLE_COROUTINE, o resuelve ``o.__await__``."

#: ../Doc/library/dis.rst:730
msgid ""
"If the ``where`` operand is nonzero, it indicates where the instruction "
"occurs:"
msgstr ""
"Si el operando ``where`` es distinto de cero, indica dónde ocurre la "
"instrucción:"

#: ../Doc/library/dis.rst:733
#, fuzzy
msgid "``1``: After a call to ``__aenter__``"
msgstr "``1`` Después de una llamada a ``__aenter__``"

#: ../Doc/library/dis.rst:734
#, fuzzy
msgid "``2``: After a call to ``__aexit__``"
msgstr "``2`` Después de una llamada a ``__aexit__``"

#: ../Doc/library/dis.rst:738
msgid "Previously, this instruction did not have an oparg."
msgstr "Anteriormente, esta instrucción no tenía un oparg."

#: ../Doc/library/dis.rst:744
#, fuzzy
msgid "Implements ``STACK[-1] = STACK[-1].__aiter__()``."
msgstr "Implementa ``TOS = TOS.__aiter__()``."

#: ../Doc/library/dis.rst:747
msgid "Returning awaitable objects from ``__aiter__`` is no longer supported."
msgstr "Ya no se admite el retorno de objetos *awaitable* de ``__aiter__``."

#: ../Doc/library/dis.rst:754
#, fuzzy
msgid ""
"Implement ``STACK.append(get_awaitable(STACK[-1].__anext__()))`` to the "
"stack. See ``GET_AWAITABLE`` for details about ``get_awaitable``."
msgstr ""
"Agrega ``get_awaitable(TOS.__anext__())`` a la pila. Consulte "
"``GET_AWAITABLE`` para obtener detalles sobre ``get_awaitable``."

#: ../Doc/library/dis.rst:762
msgid ""
"Terminates an :keyword:`async for` loop.  Handles an exception raised when "
"awaiting a next item. The stack contains the async iterable in ``STACK[-2]`` "
"and the raised exception in ``STACK[-1]``. Both are popped. If the exception "
"is not :exc:`StopAsyncIteration`, it is re-raised."
msgstr ""

#: ../Doc/library/dis.rst:769 ../Doc/library/dis.rst:877
#: ../Doc/library/dis.rst:888
msgid ""
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"La representación de excepciones en la pila ahora consta de uno, no de tres "
"elementos."

#: ../Doc/library/dis.rst:775
msgid ""
"Handles an exception raised during a :meth:`~generator.throw` "
"or :meth:`~generator.close` call through the current frame.  If "
"``STACK[-1]`` is an instance of :exc:`StopIteration`, pop three values from "
"the stack and push its ``value`` member.  Otherwise, re-raise ``STACK[-1]``."
msgstr ""

#: ../Doc/library/dis.rst:785
#, fuzzy
msgid ""
"Resolves ``__aenter__`` and ``__aexit__`` from ``STACK[-1]``. Pushes "
"``__aexit__`` and result of ``__aenter__()`` to the stack::"
msgstr ""
"Resuelve ``__aenter__`` y ``__aexit__`` del objeto en la parte superior de "
"la pila. Apila ``__aexit__`` y el resultado de ``__aenter__()`` a la pila."

#: ../Doc/library/dis.rst:788
msgid "STACK.extend((__aexit__, __aenter__())"
msgstr ""

#: ../Doc/library/dis.rst:794
msgid "**Miscellaneous opcodes**"
msgstr "**Opcodes misceláneos**"

#: ../Doc/library/dis.rst:800
msgid ""
"item = STACK.pop()\n"
"set.add(STACK[-i], item)"
msgstr ""

#: ../Doc/library/dis.rst:803
#, fuzzy
msgid "Used to implement set comprehensions."
msgstr ""
"Llama a ``set.add(TOS1[-i], TOS)``. Se utiliza para implementar "
"comprensiones de conjuntos."

#: ../Doc/library/dis.rst:810
msgid ""
"item = STACK.pop()\n"
"list.append(STACK[-i], item)"
msgstr ""

#: ../Doc/library/dis.rst:813
#, fuzzy
msgid "Used to implement list comprehensions."
msgstr ""
"Llama a ``list.append(TOS1[-i], TOS)``. Se utiliza para implementar listas "
"por comprensión."

#: ../Doc/library/dis.rst:820
msgid ""
"value = STACK.pop()\n"
"key = STACK.pop()\n"
"dict.__setitem__(STACK[-i], key, value)"
msgstr ""

#: ../Doc/library/dis.rst:824
#, fuzzy
msgid "Used to implement dict comprehensions."
msgstr ""
"Llama a ``set.add(TOS1[-i], TOS)``. Se utiliza para implementar "
"comprensiones de conjuntos."

#: ../Doc/library/dis.rst:827
#, fuzzy
msgid ""
"Map value is ``STACK[-1]`` and map key is ``STACK[-2]``. Before, those were "
"reversed."
msgstr ""
"El valor del mapa es TOS y la clave del mapa es TOS1. Antes, esos fueron "
"revertidos."

#: ../Doc/library/dis.rst:831
msgid ""
"For all of the :opcode:`SET_ADD`, :opcode:`LIST_APPEND` "
"and :opcode:`MAP_ADD` instructions, while the added value or key/value pair "
"is popped off, the container object remains on the stack so that it is "
"available for further iterations of the loop."
msgstr ""
"Para todas las instrucciones :opcode:`SET_ADD`, :opcode:`LIST_APPEND` "
"y :opcode:`MAP_ADD`, mientras el valor agregado o el par clave/valor "
"aparece, el objeto contenedor permanece en la pila para que quede disponible "
"para futuras iteraciones del bucle."

#: ../Doc/library/dis.rst:839
#, fuzzy
msgid "Returns with ``STACK[-1]`` to the caller of the function."
msgstr "Retorna con TOS a quien llama la función."

#: ../Doc/library/dis.rst:844
#, fuzzy
msgid "Returns with ``co_consts[consti]`` to the caller of the function."
msgstr "Retorna con TOS a quien llama la función."

#: ../Doc/library/dis.rst:851
#, fuzzy
msgid "Yields ``STACK.pop()`` from a :term:`generator`."
msgstr "Desapila TOS y lo genera (*yield*) de un :term:`generator`."

#: ../Doc/library/dis.rst:853
msgid "oparg set to be the stack depth."
msgstr ""

#: ../Doc/library/dis.rst:856
msgid ""
"oparg set to be the exception block depth, for efficient closing of "
"generators."
msgstr ""

#: ../Doc/library/dis.rst:859
msgid ""
"oparg is ``1`` if this instruction is part of a yield-from or await, and "
"``0`` otherwise."
msgstr ""

#: ../Doc/library/dis.rst:865
msgid ""
"Checks whether ``__annotations__`` is defined in ``locals()``, if not it is "
"set up to an empty ``dict``. This opcode is only emitted if a class or "
"module body contains :term:`variable annotations <variable annotation>` "
"statically."
msgstr ""
"Comprueba si ``__anotaciones__`` está definido en ``locals()``, si no está "
"configurado como un ``dict`` vacío. Este código de operación solo se emite "
"si el cuerpo de una clase o módulo contiene :term:`anotaciones de variables "
"<variable annotation>` estáticamente."

#: ../Doc/library/dis.rst:875
msgid ""
"Pops a value from the stack, which is used to restore the exception state."
msgstr ""
"Extrae un valor de la pila, que se utiliza para restaurar el estado de "
"excepción."

#: ../Doc/library/dis.rst:882
#, fuzzy
msgid ""
"Re-raises the exception currently on top of the stack. If oparg is non-zero, "
"pops an additional value from the stack which is used to "
"set :attr:`~frame.f_lasti` of the current frame."
msgstr ""
"Vuelve a generar la excepción que se encuentra actualmente en la parte "
"superior de la pila. Si oparg no es cero, extrae un valor adicional de la "
"pila que se usa para establecer ``f_lasti`` del marco actual."

#: ../Doc/library/dis.rst:893
msgid ""
"Pops a value from the stack. Pushes the current exception to the top of the "
"stack. Pushes the value originally popped back to the stack. Used in "
"exception handlers."
msgstr ""
"Extrae un valor de la pila. Agrega la excepción actual a la parte superior "
"de la pila. Agrega el valor que apareció originalmente de vuelta a la pila. "
"Se utiliza en los controladores de excepciones."

#: ../Doc/library/dis.rst:901
#, fuzzy
msgid ""
"Performs exception matching for ``except``. Tests whether the ``STACK[-2]`` "
"is an exception matching ``STACK[-1]``. Pops ``STACK[-1]`` and pushes the "
"boolean result of the test."
msgstr ""
"Realiza coincidencias de excepciones para ``except``. Comprueba si TOS1 es "
"una excepción que coincide con TOS. Aparece TOS y agrega el resultado "
"booleano de la prueba."

#: ../Doc/library/dis.rst:909
#, fuzzy
msgid ""
"Performs exception matching for ``except*``. Applies ``split(STACK[-1])`` on "
"the exception group representing ``STACK[-2]``."
msgstr ""
"Realiza coincidencias de excepciones para ``except*``. Aplica ``split(TOS)`` "
"en el grupo de excepción que representa TOS1."

#: ../Doc/library/dis.rst:912
msgid ""
"In case of a match, pops two items from the stack and pushes the non-"
"matching subgroup (``None`` in case of full match) followed by the matching "
"subgroup. When there is no match, pops one item (the match type) and pushes "
"``None``."
msgstr ""
"En caso de coincidencia, extrae dos elementos de la pila y agrega el "
"subgrupo que no coincide (``None`` en caso de coincidencia total) seguido "
"del subgrupo coincidente. Cuando no hay ninguna coincidencia, muestra un "
"elemento (el tipo de coincidencia) y presiona ``None``."

#: ../Doc/library/dis.rst:921
msgid ""
"Calls the function in position 4 on the stack with arguments (type, val, tb) "
"representing the exception at the top of the stack. Used to implement the "
"call ``context_manager.__exit__(*exc_info())`` when an exception has "
"occurred in a :keyword:`with` statement."
msgstr ""
"Llama a la función en la posición 4 de la pila con argumentos (tipo, val, "
"tb) que representan la excepción en la parte superior de la pila. Se utiliza "
"para implementar la llamada ``context_manager.__exit__(*exc_info())`` cuando "
"se ha producido una excepción en una sentencia :keyword:`with`."

#: ../Doc/library/dis.rst:928
msgid ""
"The ``__exit__`` function is in position 4 of the stack rather than 7. "
"Exception representation on the stack now consist of one, not three, items."
msgstr ""
"La función ``__exit__`` está en la posición 4 de la pila en lugar de la 7. "
"La representación de excepciones en la pila ahora consta de uno, no de tres, "
"elementos."

#: ../Doc/library/dis.rst:935
msgid ""
"Pushes :exc:`AssertionError` onto the stack.  Used by the :keyword:`assert` "
"statement."
msgstr ""
"Inserta :exc:`AssertionError` en la pila. Utilizado por la "
"declaración :keyword:`assert`."

#: ../Doc/library/dis.rst:943
#, fuzzy
msgid ""
"Pushes :func:`!builtins.__build_class__` onto the stack.  It is later called "
"to construct a class."
msgstr ""
"Agrega :func:`builtins.__build_class__` a la pila. Más tarde se llama para "
"construir una clase."

#: ../Doc/library/dis.rst:949
msgid ""
"This opcode performs several operations before a with block starts.  First, "
"it loads :meth:`~object.__exit__` from the context manager and pushes it "
"onto the stack for later use by :opcode:`WITH_EXCEPT_START`.  "
"Then, :meth:`~object.__enter__` is called. Finally, the result of calling "
"the ``__enter__()`` method is pushed onto the stack."
msgstr ""
"Este código de operación realiza varias operaciones antes de que comience un "
"bloque with. Primero, carga :meth:`~object.__exit__` desde el administrador "
"de contexto y lo agrega a la pila para que :opcode:`WITH_EXCEPT_START` lo "
"use más tarde. Entonces, se llama :meth:`~object.__enter__`. Finalmente, el "
"resultado de llamar al método ``__enter__()`` se agrega en la pila."

#: ../Doc/library/dis.rst:960
msgid "Perform ``STACK.append(len(STACK[-1]))``."
msgstr ""

#: ../Doc/library/dis.rst:967
#, fuzzy
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Mapping` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Si TOS es una instancia de :class:`collections.abc.Mapping` (o, más "
"técnicamente, si tiene el indicador :const:`Py_TPFLAGS_MAPPING`  establecido "
"en su :c:member:`~PyTypeObject.tp_flags`), apila ``True`` en la pila. De lo "
"contrario apila ``False``."

#: ../Doc/library/dis.rst:977
#, fuzzy
msgid ""
"If ``STACK[-1]`` is an instance of :class:`collections.abc.Sequence` and is "
"*not* an instance of :class:`str`/:class:`bytes`/:class:`bytearray` (or, "
"more technically: if it has the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in "
"its :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  "
"Otherwise, push ``False``."
msgstr ""
"Si TOS es una instancia de :class:`collections.abc.Sequence` y *no* es una "
"instancia de :class:`str`/:class:`bytes`/:class:`bytearray` (o, más "
"técnicamente, si tiene el indicador :const:`Py_TPFLAGS_SEQUENCE`  "
"establecido en su :c:member:`~PyTypeObject.tp_flags`), apila ``True`` en la "
"pila. De lo contrario apila ``False``."

#: ../Doc/library/dis.rst:987
#, fuzzy
msgid ""
"``STACK[-1]`` is a tuple of mapping keys, and ``STACK[-2]`` is the match "
"subject. If ``STACK[-2]`` contains all of the keys in ``STACK[-1]``, push "
"a :class:`tuple` containing the corresponding values. Otherwise, push "
"``None``."
msgstr ""
"TOS es una tupla de claves de mapeo y TOS1 es el sujeto de coincidencia. Si "
"TOS1 contiene todas las claves en TOS, agrega un :class:`tuple` que contenga "
"los valores correspondientes. De lo contrario, agrega ``None``."

#: ../Doc/library/dis.rst:993 ../Doc/library/dis.rst:1664
msgid ""
"Previously, this instruction also pushed a boolean value indicating success "
"(``True``) or failure (``False``)."
msgstr ""
"Anteriormente, esta instrucción también generaba un valor booleano que "
"indicaba éxito (``True``) o falla (``False``)."

#: ../Doc/library/dis.rst:1000
#, fuzzy
msgid ""
"Implements ``name = STACK.pop()``. *namei* is the index of *name* in the "
"attribute :attr:`~codeobject.co_names` of the :ref:`code object <code-"
"objects>`. The compiler tries to use :opcode:`STORE_FAST` "
"or :opcode:`STORE_GLOBAL` if possible."
msgstr ""
"Implementa ``name = TOS``. *namei* es el índice de *name* en el "
"atributo :attr:`co_names` del objeto de código. El compilador intenta "
"usar :opcode:`STORE_FAST` o :opcode:`STORE_GLOBAL` si es posible."

#: ../Doc/library/dis.rst:1007
#, fuzzy
msgid ""
"Implements ``del name``, where *namei* is the index "
"into :attr:`~codeobject.co_names` attribute of the :ref:`code object <code-"
"objects>`."
msgstr ""
"Implementa ``del name``, donde *namei* es el índice en "
"atributo :attr:`co_names` del objeto de código."

#: ../Doc/library/dis.rst:1013
#, fuzzy
msgid ""
"Unpacks ``STACK[-1]`` into *count* individual values, which are put onto the "
"stack right-to-left. Require there to be exactly *count* values.::"
msgstr ""
"Descomprime TOS en *count* valores individuales, que se colocan en la pila "
"de derecha a izquierda."

#: ../Doc/library/dis.rst:1016
msgid ""
"assert(len(STACK[-1]) == count)\n"
"STACK.extend(STACK.pop()[:-count-1:-1])"
msgstr ""

#: ../Doc/library/dis.rst:1022
#, fuzzy
msgid ""
"Implements assignment with a starred target: Unpacks an iterable in "
"``STACK[-1]`` into individual values, where the total number of values can "
"be smaller than the number of items in the iterable: one of the new values "
"will be a list of all leftover items."
msgstr ""
"Implementa la asignación con un objetivo destacado: desempaqueta un iterable "
"en TOS en valores individuales, donde el número total de valores puede ser "
"menor que el número de elementos en el iterable: uno de los nuevos valores "
"será una lista de todos los elementos sobrantes."

#: ../Doc/library/dis.rst:1027
msgid "The number of values before and after the list value is limited to 255."
msgstr ""

#: ../Doc/library/dis.rst:1029
msgid ""
"The number of values before the list value is encoded in the argument of the "
"opcode. The number of values after the list if any is encoded using an "
"``EXTENDED_ARG``. As a consequence, the argument can be seen as a two bytes "
"values where the low byte of *counts* is the number of values before the "
"list value, the high byte of *counts* the number of values after it."
msgstr ""

#: ../Doc/library/dis.rst:1035
msgid ""
"The extracted values are put onto the stack right-to-left, i.e. ``a, *b, c = "
"d`` will be stored after execution as ``STACK.extend((a, b, c))``."
msgstr ""

#: ../Doc/library/dis.rst:1043
msgid ""
"obj = STACK.pop()\n"
"value = STACK.pop()\n"
"obj.name = value"
msgstr ""

#: ../Doc/library/dis.rst:1047
#, fuzzy
msgid ""
"where *namei* is the index of name in :attr:`~codeobject.co_names` of "
"the :ref:`code object <code-objects>`."
msgstr ""
"Implementa ``del name``, donde *namei* es el índice en "
"atributo :attr:`co_names` del objeto de código."

#: ../Doc/library/dis.rst:1054
msgid ""
"obj = STACK.pop()\n"
"del obj.name"
msgstr ""

#: ../Doc/library/dis.rst:1057
#, fuzzy
msgid ""
"where *namei* is the index of name into :attr:`~codeobject.co_names` of "
"the :ref:`code object <code-objects>`."
msgstr ""
"Implementa ``del name``, donde *namei* es el índice en "
"atributo :attr:`co_names` del objeto de código."

#: ../Doc/library/dis.rst:1063
msgid "Works as :opcode:`STORE_NAME`, but stores the name as a global."
msgstr ""
"Funciona como :opcode:`STORE_NAME`, pero almacena el nombre como global."

#: ../Doc/library/dis.rst:1068
msgid "Works as :opcode:`DELETE_NAME`, but deletes a global name."
msgstr "Funciona como :opcode:`DELETE_NAME`, pero elimina un nombre global."

#: ../Doc/library/dis.rst:1073
msgid "Pushes ``co_consts[consti]`` onto the stack."
msgstr "Apila ``co_consts[consti]`` en la pila."

#: ../Doc/library/dis.rst:1078
#, fuzzy
msgid ""
"Pushes the value associated with ``co_names[namei]`` onto the stack. The "
"name is looked up within the locals, then the globals, then the builtins."
msgstr "Apila el valor asociado con ``co_names [namei]`` en la pila."

#: ../Doc/library/dis.rst:1084
msgid ""
"Pushes a reference to the locals dictionary onto the stack.  This is used to "
"prepare namespace dictionaries for :opcode:`LOAD_FROM_DICT_OR_DEREF` "
"and :opcode:`LOAD_FROM_DICT_OR_GLOBALS`."
msgstr ""

#: ../Doc/library/dis.rst:1093
msgid ""
"Pops a mapping off the stack and looks up the value for ``co_names[namei]``. "
"If the name is not found there, looks it up in the globals and then the "
"builtins, similar to :opcode:`LOAD_GLOBAL`. This is used for loading global "
"variables in :ref:`annotation scopes <annotation-scopes>` within class "
"bodies."
msgstr ""

#: ../Doc/library/dis.rst:1104
#, fuzzy
msgid ""
"Creates a tuple consuming *count* items from the stack, and pushes the "
"resulting tuple onto the stack::"
msgstr ""
"Crea una tupla que consume elementos *count* de la pila, y apila la tupla "
"resultante a la pila."

#: ../Doc/library/dis.rst:1107
msgid ""
"if count == 0:\n"
"    value = ()\n"
"else:\n"
"    value = tuple(STACK[-count:])\n"
"    STACK = STACK[:-count]\n"
"\n"
"STACK.append(value)"
msgstr ""

#: ../Doc/library/dis.rst:1118
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a list."
msgstr "Funciona como :opcode:`BUILD_TUPLE`, pero crea una lista."

#: ../Doc/library/dis.rst:1123
msgid "Works as :opcode:`BUILD_TUPLE`, but creates a set."
msgstr "Funciona como :opcode:`BUILD_TUPLE`, pero crea un conjunto."

#: ../Doc/library/dis.rst:1128
#, fuzzy
msgid ""
"Pushes a new dictionary object onto the stack.  Pops ``2 * count`` items so "
"that the dictionary holds *count* entries: ``{..., STACK[-4]: STACK[-3], "
"STACK[-2]: STACK[-1]}``."
msgstr ""
"Apila un nuevo objeto de diccionario en la pila. Desapila ``2 * count`` "
"elementos para que el diccionario contenga *count* entradas: ``{..., TOS3: "
"TOS2, TOS1: TOS}``."

#: ../Doc/library/dis.rst:1132
msgid ""
"The dictionary is created from stack items instead of creating an empty "
"dictionary pre-sized to hold *count* items."
msgstr ""
"El diccionario se crea a partir de elementos de la pila en lugar de crear un "
"diccionario vacío dimensionado previamente para contener *count* elementos."

#: ../Doc/library/dis.rst:1139
#, fuzzy
msgid ""
"The version of :opcode:`BUILD_MAP` specialized for constant keys. Pops the "
"top element on the stack which contains a tuple of keys, then starting from "
"``STACK[-2]``, pops *count* values to form values in the built dictionary."
msgstr ""
"La versión de :opcode:`BUILD_MAP` especializada para claves constantes. "
"Desapila el elemento superior en la pila que contiene una tupla de claves, "
"luego, a partir de ``TOS1``, muestra los valores *count* para formar valores "
"en el diccionario incorporado."

#: ../Doc/library/dis.rst:1148
msgid ""
"Concatenates *count* strings from the stack and pushes the resulting string "
"onto the stack."
msgstr ""
"Concatena *count* cadenas de caracteres de la pila y empuja la cadena de "
"caracteres resultante en la pila."

#: ../Doc/library/dis.rst:1158
msgid ""
"seq = STACK.pop()\n"
"list.extend(STACK[-i], seq)"
msgstr ""

#: ../Doc/library/dis.rst:1161
msgid "Used to build lists."
msgstr ""

#: ../Doc/library/dis.rst:1170
msgid ""
"seq = STACK.pop()\n"
"set.update(STACK[-i], seq)"
msgstr ""

#: ../Doc/library/dis.rst:1173
msgid "Used to build sets."
msgstr ""

#: ../Doc/library/dis.rst:1182
msgid ""
"map = STACK.pop()\n"
"dict.update(STACK[-i], map)"
msgstr ""

#: ../Doc/library/dis.rst:1185
msgid "Used to build dicts."
msgstr ""

#: ../Doc/library/dis.rst:1192
msgid "Like :opcode:`DICT_UPDATE` but raises an exception for duplicate keys."
msgstr ""
"Como :opcode:`DICT_UPDATE` pero lanza una excepción para claves duplicadas."

#: ../Doc/library/dis.rst:1199
msgid ""
"If the low bit of ``namei`` is not set, this replaces ``STACK[-1]`` with "
"``getattr(STACK[-1], co_names[namei>>1])``."
msgstr ""

#: ../Doc/library/dis.rst:1202
#, fuzzy
msgid ""
"If the low bit of ``namei`` is set, this will attempt to load a method named "
"``co_names[namei>>1]`` from the ``STACK[-1]`` object. ``STACK[-1]`` is "
"popped. This bytecode distinguishes two cases: if ``STACK[-1]`` has a method "
"with the correct name, the bytecode pushes the unbound method and "
"``STACK[-1]``. ``STACK[-1]`` will be used as the first argument (``self``) "
"by :opcode:`CALL` or :opcode:`CALL_KW` when calling the unbound method. "
"Otherwise, ``NULL`` and the object returned by the attribute lookup are "
"pushed."
msgstr ""
"Carga un método denominado ``co_names[namei]`` desde el objeto TOS. TOS es "
"retirado. Este código de bytes distingue dos casos: si TOS tiene un método "
"con el nombre correcto, el código de bytes agrega el método independiente y "
"TOS. :opcode:`CALL` utilizará TOS como primer argumento (``self``) al llamar "
"al método independiente. De lo contrario, se agregan ``NULL`` y el objeto "
"devuelto por la búsqueda de atributos."

#: ../Doc/library/dis.rst:1211
#, fuzzy
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` or ``self`` is pushed to "
"the stack before the attribute or unbound method respectively."
msgstr ""
"Si se establece el bit bajo de ``namei``, se agrega un ``NULL`` a la pila "
"antes de la variable global."

#: ../Doc/library/dis.rst:1218
msgid ""
"This opcode implements :func:`super`, both in its zero-argument and two-"
"argument forms (e.g. ``super().method()``, ``super().attr`` and ``super(cls, "
"self).method()``, ``super(cls, self).attr``)."
msgstr ""

#: ../Doc/library/dis.rst:1222
msgid "It pops three values from the stack (from top of stack down):"
msgstr ""

#: ../Doc/library/dis.rst:1224
msgid "``self``: the first argument to the current method"
msgstr ""

#: ../Doc/library/dis.rst:1225
msgid "``cls``: the class within which the current method was defined"
msgstr ""

#: ../Doc/library/dis.rst:1226
msgid "the global ``super``"
msgstr ""

#: ../Doc/library/dis.rst:1228
msgid ""
"With respect to its argument, it works similarly to :opcode:`LOAD_ATTR`, "
"except that ``namei`` is shifted left by 2 bits instead of 1."
msgstr ""

#: ../Doc/library/dis.rst:1231
msgid ""
"The low bit of ``namei`` signals to attempt a method load, as "
"with :opcode:`LOAD_ATTR`, which results in pushing ``NULL`` and the loaded "
"method. When it is unset a single value is pushed to the stack."
msgstr ""

#: ../Doc/library/dis.rst:1235
msgid ""
"The second-low bit of ``namei``, if set, means that this was a two-argument "
"call to :func:`super` (unset means zero-argument)."
msgstr ""

#: ../Doc/library/dis.rst:1243
#, fuzzy
msgid ""
"Performs a Boolean operation.  The operation name can be found in "
"``cmp_op[opname >> 5]``. If the fifth-lowest bit of ``opname`` is set "
"(``opname & 16``), the result should be coerced to ``bool``."
msgstr ""
"Realiza una operación booleana. El nombre de la operación se puede encontrar "
"en ``cmp_op[opname]``."

#: ../Doc/library/dis.rst:1247
msgid ""
"The fifth-lowest bit of the oparg now indicates a forced conversion "
"to :class:`bool`."
msgstr ""

#: ../Doc/library/dis.rst:1254
msgid "Performs ``is`` comparison, or ``is not`` if ``invert`` is 1."
msgstr "Realiza una comparación ``is`` o ``is not`` si ``invert`` es 1."

#: ../Doc/library/dis.rst:1261
msgid "Performs ``in`` comparison, or ``not in`` if ``invert`` is 1."
msgstr "Realiza una comparación ``in`` o ``not in`` si ``invert`` es 1."

#: ../Doc/library/dis.rst:1268
#, fuzzy
msgid ""
"Imports the module ``co_names[namei]``.  ``STACK[-1]`` and ``STACK[-2]`` are "
"popped and provide the *fromlist* and *level* arguments "
"of :func:`__import__`. The module object is pushed onto the stack.  The "
"current namespace is not affected: for a proper import statement, a "
"subsequent :opcode:`STORE_FAST` instruction modifies the namespace."
msgstr ""
"Importa el módulo ``co_names[namei]``. TOS y TOS1 aparecen y proporcionan "
"los argumentos *fromlist* y *level* de :func:`__import__`. El objeto del "
"módulo se empuja a la pila. El espacio de nombres actual no se ve afectado: "
"para una instrucción de importación adecuada, una instrucción "
"posterior :opcode:`STORE_FAST` modifica el espacio de nombres."

#: ../Doc/library/dis.rst:1276
#, fuzzy
msgid ""
"Loads the attribute ``co_names[namei]`` from the module found in "
"``STACK[-1]``. The resulting object is pushed onto the stack, to be "
"subsequently stored by a :opcode:`STORE_FAST` instruction."
msgstr ""
"Carga el atributo ``co_names[namei]`` del módulo que se encuentra en TOS. El "
"objeto resultante se apila en la pila, para luego ser almacenado por la "
"instrucción :opcode:`STORE_FAST`."

#: ../Doc/library/dis.rst:1283
msgid "Increments bytecode counter by *delta*."
msgstr "Incrementa el contador de bytecode en *delta*."

#: ../Doc/library/dis.rst:1288
msgid "Decrements bytecode counter by *delta*. Checks for interrupts."
msgstr ""
"Decrementa el contador de bytecode en *delta*. Comprueba si hay "
"interrupciones."

#: ../Doc/library/dis.rst:1295
msgid "Decrements bytecode counter by *delta*. Does not check for interrupts."
msgstr ""
"Decrementa el contador de bytecode en *delta*. No busca interrupciones."

#: ../Doc/library/dis.rst:1302
#, fuzzy
msgid ""
"If ``STACK[-1]`` is true, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Si TOS es verdadero, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1305 ../Doc/library/dis.rst:1321
msgid ""
"The oparg is now a relative delta rather than an absolute target. This "
"opcode is a pseudo-instruction, replaced in final bytecode by the directed "
"versions (forward/backward)."
msgstr ""

#: ../Doc/library/dis.rst:1310 ../Doc/library/dis.rst:1326
#: ../Doc/library/dis.rst:1342 ../Doc/library/dis.rst:1356
msgid "This is no longer a pseudo-instruction."
msgstr ""

#: ../Doc/library/dis.rst:1318
#, fuzzy
msgid ""
"If ``STACK[-1]`` is false, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Si TOS es falso, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1334
#, fuzzy
msgid ""
"If ``STACK[-1]`` is not ``None``, increments the bytecode counter by "
"*delta*. ``STACK[-1]`` is popped."
msgstr ""
"Si TOS no es ``None``, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1337 ../Doc/library/dis.rst:1351
msgid ""
"This opcode is a pseudo-instruction, replaced in final bytecode by the "
"directed versions (forward/backward)."
msgstr ""

#: ../Doc/library/dis.rst:1348
#, fuzzy
msgid ""
"If ``STACK[-1]`` is ``None``, increments the bytecode counter by *delta*. "
"``STACK[-1]`` is popped."
msgstr ""
"Si TOS es ``None``, incrementa el contador de bytecode en *delta*. TOS es "
"retirado."

#: ../Doc/library/dis.rst:1361
#, fuzzy
msgid ""
"``STACK[-1]`` is an :term:`iterator`.  Call its :meth:`~iterator.__next__` "
"method. If this yields a new value, push it on the stack (leaving the "
"iterator below it).  If the iterator indicates it is exhausted then the byte "
"code counter is incremented by *delta*."
msgstr ""
"TOS es un :term:`iterador`. Llama a su método :meth:`~iterator.__next__`. Si "
"esto produce un nuevo valor, lo apila en la pila (dejando el iterador debajo "
"de él). Si el iterador indica que está agotado, se abre TOS y el contador de "
"código de bytes se incrementa en *delta*."

#: ../Doc/library/dis.rst:1366
msgid "Up until 3.11 the iterator was popped when it was exhausted."
msgstr ""

#: ../Doc/library/dis.rst:1371
msgid "Loads the global named ``co_names[namei>>1]`` onto the stack."
msgstr "Carga el ``co_names[namei>>1]`` global llamado en la pila."

#: ../Doc/library/dis.rst:1373
msgid ""
"If the low bit of ``namei`` is set, then a ``NULL`` is pushed to the stack "
"before the global variable."
msgstr ""
"Si se establece el bit bajo de ``namei``, se agrega un ``NULL`` a la pila "
"antes de la variable global."

#: ../Doc/library/dis.rst:1379
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack."
msgstr "Apila una referencia al local ``co_varnames[var_num]`` sobre la pila."

#: ../Doc/library/dis.rst:1381
msgid ""
"This opcode is now only used in situations where the local variable is "
"guaranteed to be initialized. It cannot raise :exc:`UnboundLocalError`."
msgstr ""

#: ../Doc/library/dis.rst:1387
#, fuzzy
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack, "
"raising an :exc:`UnboundLocalError` if the local variable has not been "
"initialized."
msgstr "Apila una referencia al local ``co_varnames[var_num]`` sobre la pila."

#: ../Doc/library/dis.rst:1395
msgid ""
"Pushes a reference to the local ``co_varnames[var_num]`` onto the stack (or "
"pushes ``NULL`` onto the stack if the local variable has not been "
"initialized) and sets ``co_varnames[var_num]`` to ``NULL``."
msgstr ""

#: ../Doc/library/dis.rst:1403
#, fuzzy
msgid "Stores ``STACK.pop()`` into the local ``co_varnames[var_num]``."
msgstr "Almacena TOS en el local ``co_varnames[var_num]``."

#: ../Doc/library/dis.rst:1408
msgid "Deletes local ``co_varnames[var_num]``."
msgstr "Elimina la ``co_varnames[var_num]`` local."

#: ../Doc/library/dis.rst:1413
#, fuzzy
msgid ""
"Creates a new cell in slot ``i``.  If that slot is nonempty then that value "
"is stored into the new cell."
msgstr ""
"Crea una nueva celda en la ranura ``i``. Si esa ranura está vacía, ese valor "
"se almacena en la nueva celda."

#: ../Doc/library/dis.rst:1421
msgid ""
"Loads the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Pushes a reference to the object the cell contains on the stack."
msgstr ""
"Carga la celda contenida en el slot ``i`` del almacenamiento \"fast "
"locals\". Agrega una referencia al objeto que contiene la celda en la pila."

#: ../Doc/library/dis.rst:1424 ../Doc/library/dis.rst:1446
#: ../Doc/library/dis.rst:1457
#, fuzzy
msgid ""
"``i`` is no longer offset by the length of :attr:`~codeobject.co_varnames`."
msgstr "``i`` ya no se compensa con la longitud de ``co_varnames``."

#: ../Doc/library/dis.rst:1430
msgid ""
"Pops a mapping off the stack and looks up the name associated with slot "
"``i`` of the \"fast locals\" storage in this mapping. If the name is not "
"found there, loads it from the cell contained in slot ``i``, similar "
"to :opcode:`LOAD_DEREF`. This is used for loading free variables in class "
"bodies (which previously used :opcode:`!LOAD_CLASSDEREF`) and "
"in :ref:`annotation scopes <annotation-scopes>` within class bodies."
msgstr ""

#: ../Doc/library/dis.rst:1443
#, fuzzy
msgid ""
"Stores ``STACK.pop()`` into the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Almacena TOS en la celda contenida en la ranura ``i`` del almacenamiento "
"\"locales rápidos\"."

#: ../Doc/library/dis.rst:1452
msgid ""
"Empties the cell contained in slot ``i`` of the \"fast locals\" storage. "
"Used by the :keyword:`del` statement."
msgstr ""
"Vacía la celda contenida en la ranura ``i`` del almacenamiento de \"locales "
"rápidos\". Utilizado por la instrucción :keyword:`del`."

#: ../Doc/library/dis.rst:1463
msgid ""
"Copies the ``n`` free variables from the closure into the frame. Removes the "
"need for special code on the caller's side when calling closures."
msgstr ""
"Copia las variables libres ``n`` del cierre al marco. Elimina la necesidad "
"de un código especial en el lado del que llama al llamar clausuras."

#: ../Doc/library/dis.rst:1472
msgid ""
"Raises an exception using one of the 3 forms of the ``raise`` statement, "
"depending on the value of *argc*:"
msgstr ""
"Provoca una excepción utilizando una de las 3 formas de la declaración "
"``raise``, dependiendo del valor de *argc*:"

#: ../Doc/library/dis.rst:1475
msgid "0: ``raise`` (re-raise previous exception)"
msgstr "0: ``raise`` (vuelve a lanzar la excepción anterior)"

#: ../Doc/library/dis.rst:1476
#, fuzzy
msgid ""
"1: ``raise STACK[-1]`` (raise exception instance or type at ``STACK[-1]``)"
msgstr "1: ``raise TOS`` (lanza instancia de excepción o un tipo en ``TOS``)"

#: ../Doc/library/dis.rst:1477
#, fuzzy
msgid ""
"2: ``raise STACK[-2] from STACK[-1]`` (raise exception instance or type at "
"``STACK[-2]`` with ``__cause__`` set to ``STACK[-1]``)"
msgstr ""
"2: ``raise TOS1 desde TOS`` (lanza una instancia de excepción o tipo en "
"``TOS1`` con ``__cause__`` establecida en ``TOS``)"

#: ../Doc/library/dis.rst:1483
#, fuzzy
msgid ""
"Calls a callable object with the number of arguments specified by ``argc``. "
"On the stack are (in ascending order):"
msgstr ""
"Llama a un objeto invocable con la cantidad de argumentos especificados por "
"``argc``, incluidos los argumentos con nombre especificados por "
"el :opcode:`KW_NAMES` anterior, si los hay. En la pila están (en orden "
"ascendente), ya sea:"

#: ../Doc/library/dis.rst:1486 ../Doc/library/dis.rst:1510
msgid "The callable"
msgstr "El llamable"

#: ../Doc/library/dis.rst:1487 ../Doc/library/dis.rst:1511
msgid "``self`` or ``NULL``"
msgstr ""

#: ../Doc/library/dis.rst:1488 ../Doc/library/dis.rst:1512
msgid "The remaining positional arguments"
msgstr "Los argumentos posicionales restantes"

#: ../Doc/library/dis.rst:1490
#, fuzzy
msgid "``argc`` is the total of the positional arguments, excluding ``self``."
msgstr ""
"``argc`` es el total de los argumentos posicionales y con nombre, excluyendo "
"``self`` cuando ``NULL`` no está presente."

#: ../Doc/library/dis.rst:1492
msgid ""
"``CALL`` pops all arguments and the callable object off the stack, calls the "
"callable object with those arguments, and pushes the return value returned "
"by the callable object."
msgstr ""
"``CALL`` extrae todos los argumentos y el objeto invocable de la pila, llama "
"al objeto invocable con esos argumentos y agrega el valor retornado por el "
"objeto invocable."

#: ../Doc/library/dis.rst:1498
msgid "The callable now always appears at the same position on the stack."
msgstr ""

#: ../Doc/library/dis.rst:1501
msgid "Calls with keyword arguments are now handled by :opcode:`CALL_KW`."
msgstr ""

#: ../Doc/library/dis.rst:1507
#, fuzzy
msgid ""
"Calls a callable object with the number of arguments specified by ``argc``, "
"including one or more named arguments. On the stack are (in ascending order):"
msgstr ""
"Llama a un objeto invocable con la cantidad de argumentos especificados por "
"``argc``, incluidos los argumentos con nombre especificados por "
"el :opcode:`KW_NAMES` anterior, si los hay. En la pila están (en orden "
"ascendente), ya sea:"

#: ../Doc/library/dis.rst:1513
msgid "The named arguments"
msgstr "Los argumentos nombrados"

#: ../Doc/library/dis.rst:1514
msgid "A :class:`tuple` of keyword argument names"
msgstr ""

#: ../Doc/library/dis.rst:1516
#, fuzzy
msgid ""
"``argc`` is the total of the positional and named arguments, excluding "
"``self``. The length of the tuple of keyword argument names is the number of "
"named arguments."
msgstr ""
"``argc`` es el total de los argumentos posicionales y con nombre, excluyendo "
"``self`` cuando ``NULL`` no está presente."

#: ../Doc/library/dis.rst:1519
#, fuzzy
msgid ""
"``CALL_KW`` pops all arguments, the keyword names, and the callable object "
"off the stack, calls the callable object with those arguments, and pushes "
"the return value returned by the callable object."
msgstr ""
"``CALL`` extrae todos los argumentos y el objeto invocable de la pila, llama "
"al objeto invocable con esos argumentos y agrega el valor retornado por el "
"objeto invocable."

#: ../Doc/library/dis.rst:1528
msgid ""
"Calls a callable object with variable set of positional and keyword "
"arguments.  If the lowest bit of *flags* is set, the top of the stack "
"contains a mapping object containing additional keyword arguments. Before "
"the callable is called, the mapping object and iterable object are each "
"\"unpacked\" and their contents passed in as keyword and positional "
"arguments respectively. ``CALL_FUNCTION_EX`` pops all arguments and the "
"callable object off the stack, calls the callable object with those "
"arguments, and pushes the return value returned by the callable object."
msgstr ""
"Llama a un objeto invocable con un conjunto variable de argumentos "
"posicionales y de palabras clave. Si se establece el bit más bajo de "
"*flags*, la parte superior de la pila contiene un objeto de mapeo que "
"contiene argumentos de palabras clave adicionales. Antes de que se llame al "
"invocable, el objeto de mapeo y el objeto iterable se \"desempaquetan\" y su "
"contenido se pasa como palabra clave y argumentos posicionales, "
"respectivamente. ``CALL_FUNCTION_EX`` saca todos los argumentos y el objeto "
"invocable de la pila, llama al objeto invocable con esos argumentos y empuja "
"el valor de retorno retornado por el objeto invocable."

#: ../Doc/library/dis.rst:1543
msgid ""
"Pushes a ``NULL`` to the stack. Used in the call sequence to match the "
"``NULL`` pushed by :opcode:`LOAD_METHOD` for non-method calls."
msgstr ""
"Agrega un ``NULL`` a la pila. Se usa en la secuencia de llamadas para hacer "
"coincidir el ``NULL`` enviado por :opcode:`LOAD_METHOD` para llamadas que no "
"son de método."

#: ../Doc/library/dis.rst:1552
msgid ""
"Pushes a new function object on the stack built from the code object at "
"``STACK[1]``."
msgstr ""

#: ../Doc/library/dis.rst:1554
msgid "Flag value ``0x04`` is a tuple of strings instead of dictionary"
msgstr ""
"El valor indicador ``0x04`` es una tupla de cadena de caracteres en vez de "
"un diccionario"

#: ../Doc/library/dis.rst:1557
msgid "Qualified name at ``STACK[-1]`` was removed."
msgstr ""

#: ../Doc/library/dis.rst:1560
msgid ""
"Extra function attributes on the stack, signaled by oparg flags, were "
"removed. They now use :opcode:`SET_FUNCTION_ATTRIBUTE`."
msgstr ""

#: ../Doc/library/dis.rst:1567
msgid ""
"Sets an attribute on a function object. Expects the function at "
"``STACK[-1]`` and the attribute value to set at ``STACK[-2]``; consumes both "
"and leaves the function at ``STACK[-1]``. The flag determines which "
"attribute to set:"
msgstr ""

#: ../Doc/library/dis.rst:1571
msgid ""
"``0x01`` a tuple of default values for positional-only and positional-or-"
"keyword parameters in positional order"
msgstr ""
"``0x01``, una tupla de valores predeterminados para solo parámetros "
"posicionales y posicionales o de palabras clave en orden posicional"

#: ../Doc/library/dis.rst:1573
msgid "``0x02`` a dictionary of keyword-only parameters' default values"
msgstr ""
"``0x02`` un diccionario de valores predeterminados de solo palabras clave"

#: ../Doc/library/dis.rst:1574
msgid "``0x04`` a tuple of strings containing parameters' annotations"
msgstr ""
"``0x04`` una tupla de cadenas de caracteres que contiene anotaciones de "
"parámetros"

#: ../Doc/library/dis.rst:1575
msgid "``0x08`` a tuple containing cells for free variables, making a closure"
msgstr ""
"``0x08`` una tupla que contiene celdas para variables libres, haciendo un "
"cierre (*closure*)"

#: ../Doc/library/dis.rst:1584
msgid ""
"Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it is 2, "
"implements::"
msgstr ""

#: ../Doc/library/dis.rst:1586
msgid ""
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end))"
msgstr ""

#: ../Doc/library/dis.rst:1590
msgid "if it is 3, implements::"
msgstr ""

#: ../Doc/library/dis.rst:1592
msgid ""
"step = STACK.pop()\n"
"end = STACK.pop()\n"
"start = STACK.pop()\n"
"STACK.append(slice(start, end, step))"
msgstr ""

#: ../Doc/library/dis.rst:1597
msgid "See the :func:`slice` built-in function for more information."
msgstr ""

#: ../Doc/library/dis.rst:1602
msgid ""
"Prefixes any opcode which has an argument too big to fit into the default "
"one byte. *ext* holds an additional byte which act as higher bits in the "
"argument. For each opcode, at most three prefixal ``EXTENDED_ARG`` are "
"allowed, forming an argument from two-byte to four-byte."
msgstr ""
"Prefija cualquier código de operación que tenga un argumento demasiado "
"grande para caber en el byte predeterminado. *ext* contiene un byte "
"adicional que actúa como bits más altos en el argumento. Para cada opcode, "
"como máximo se permiten tres prefijos ``EXTENDED_ARG``, formando un "
"argumento de dos bytes a cuatro bytes."

#: ../Doc/library/dis.rst:1610
msgid "Convert value to a string, depending on ``oparg``::"
msgstr ""

#: ../Doc/library/dis.rst:1612
msgid ""
"value = STACK.pop()\n"
"result = func(value)\n"
"STACK.append(result)"
msgstr ""

#: ../Doc/library/dis.rst:1616
#, fuzzy
msgid "``oparg == 1``: call :func:`str` on *value*"
msgstr ""
"``(flags & 0x03) == 0x01``: llama :func:`str` sobre *value* antes de "
"formatearlo."

#: ../Doc/library/dis.rst:1617
#, fuzzy
msgid "``oparg == 2``: call :func:`repr` on *value*"
msgstr ""
"``(flags & 0x03) == 0x02``: llama :func:`repr` sobre *value* antes de "
"formatearlo."

#: ../Doc/library/dis.rst:1618
#, fuzzy
msgid "``oparg == 3``: call :func:`ascii` on *value*"
msgstr ""
"``(flags & 0x03) == 0x03``: llama :func:`ascii` sobre *value* antes de "
"formatearlo."

#: ../Doc/library/dis.rst:1620 ../Doc/library/dis.rst:1633
#: ../Doc/library/dis.rst:1646
msgid "Used for implementing formatted literal strings (f-strings)."
msgstr ""

#: ../Doc/library/dis.rst:1627
#, fuzzy
msgid "Formats the value on top of stack::"
msgstr "Elimina el elemento de la parte superior de la pila (TOS)."

#: ../Doc/library/dis.rst:1629
msgid ""
"value = STACK.pop()\n"
"result = value.__format__(\"\")\n"
"STACK.append(result)"
msgstr ""

#: ../Doc/library/dis.rst:1639
msgid "Formats the given value with the given format spec::"
msgstr ""

#: ../Doc/library/dis.rst:1641
msgid ""
"spec = STACK.pop()\n"
"value = STACK.pop()\n"
"result = value.__format__(spec)\n"
"STACK.append(result)"
msgstr ""

#: ../Doc/library/dis.rst:1653
#, fuzzy
msgid ""
"``STACK[-1]`` is a tuple of keyword attribute names, ``STACK[-2]`` is the "
"class being matched against, and ``STACK[-3]`` is the match subject.  "
"*count* is the number of positional sub-patterns."
msgstr ""
"TOS es una tupla de nombres de atributos clave, TOS1 es la clase contra la "
"cual se hace la coincidencia, y TOS2 es el sujeto de la coincidencia. "
"*count* es el número de sub-patrones posicionales."

#: ../Doc/library/dis.rst:1657
#, fuzzy
msgid ""
"Pop ``STACK[-1]``, ``STACK[-2]``, and ``STACK[-3]``. If ``STACK[-3]`` is an "
"instance of ``STACK[-2]`` and has the positional and keyword attributes "
"required by *count* and ``STACK[-1]``, push a tuple of extracted attributes. "
"Otherwise, push ``None``."
msgstr ""
"Retira TOS, TOS1 y TOS2. Si TOS2 es una instancia de TOS1 y tiene los "
"atributos posicionales y de palabra clave requeridos por *count* y TOS, "
"agrega una tupla de atributos extraídos. De lo contrario, agrega ``None``."

#: ../Doc/library/dis.rst:1671
msgid "A no-op. Performs internal tracing, debugging and optimization checks."
msgstr ""
"Un no-op. Realiza comprobaciones internas de seguimiento, depuración y "
"optimización."

#: ../Doc/library/dis.rst:1673
#, fuzzy
msgid ""
"The ``context`` oparand consists of two parts. The lowest two bits indicate "
"where the ``RESUME`` occurs:"
msgstr "El operando ``where`` marca dónde ocurre el ``RESUME``:"

#: ../Doc/library/dis.rst:1676
msgid ""
"``0`` The start of a function, which is neither a generator, coroutine nor "
"an async generator"
msgstr ""

#: ../Doc/library/dis.rst:1678
msgid "``1`` After a ``yield`` expression"
msgstr "``1`` Después de una expresión ``yield``"

#: ../Doc/library/dis.rst:1679
msgid "``2`` After a ``yield from`` expression"
msgstr "``2`` Después de una expresión ``yield from``"

#: ../Doc/library/dis.rst:1680
msgid "``3`` After an ``await`` expression"
msgstr "``3`` Después de una expresión ``await``"

#: ../Doc/library/dis.rst:1682
msgid ""
"The next bit is ``1`` if the RESUME is at except-depth ``1``, and ``0`` "
"otherwise."
msgstr ""

#: ../Doc/library/dis.rst:1687
msgid "The oparg value changed to include information about except-depth"
msgstr ""

#: ../Doc/library/dis.rst:1693
#, fuzzy
msgid ""
"Create a generator, coroutine, or async generator from the current frame. "
"Used as first opcode of in code object for the above mentioned callables. "
"Clear the current frame and return the newly created generator."
msgstr ""
"Crea un generador, corrutina o generador asíncrono a partir del marco "
"actual. Borra el marco actual y retorna el generador recién creado."

#: ../Doc/library/dis.rst:1702
msgid ""
"Equivalent to ``STACK[-1] = STACK[-2].send(STACK[-1])``. Used in ``yield "
"from`` and ``await`` statements."
msgstr ""

#: ../Doc/library/dis.rst:1705
msgid ""
"If the call raises :exc:`StopIteration`, pop the top value from the stack, "
"push the exception's ``value`` attribute, and increment the bytecode counter "
"by *delta*."
msgstr ""

#: ../Doc/library/dis.rst:1714
#, fuzzy
msgid ""
"This is not really an opcode.  It identifies the dividing line between "
"opcodes in the range [0,255] which don't use their argument and those that "
"do (``< HAVE_ARGUMENT`` and ``>= HAVE_ARGUMENT``, respectively)."
msgstr ""
"Esto no es realmente un opcode. Identifica la línea divisoria entre los "
"opcode que no usan su argumento y los que lo hacen (``< HAVE_ARGUMENT`` y "
"``>= HAVE_ARGUMENT``, respectivamente)."

#: ../Doc/library/dis.rst:1718
msgid ""
"If your application uses pseudo instructions or specialized instructions, "
"use the :data:`hasarg` collection instead."
msgstr ""

#: ../Doc/library/dis.rst:1721
msgid ""
"Now every instruction has an argument, but opcodes ``< HAVE_ARGUMENT`` "
"ignore it. Before, only opcodes ``>= HAVE_ARGUMENT`` had an argument."
msgstr ""
"Ahora cada instrucción tiene un argumento, pero los códigos de operación "
"``<HAVE_ARGUMENT`` la ignoran. Antes, solo los códigos de operación ``> = "
"HAVE_ARGUMENT`` tenían un argumento."

#: ../Doc/library/dis.rst:1725
msgid ""
"Pseudo instructions were added to the :mod:`dis` module, and for them it is "
"not true that comparison with ``HAVE_ARGUMENT`` indicates whether they use "
"their arg."
msgstr ""

#: ../Doc/library/dis.rst:1730
msgid "Use :data:`hasarg` instead."
msgstr ""

#: ../Doc/library/dis.rst:1735
msgid ""
"Calls an intrinsic function with one argument. Passes ``STACK[-1]`` as the "
"argument and sets ``STACK[-1]`` to the result. Used to implement "
"functionality that is not performance critical."
msgstr ""

#: ../Doc/library/dis.rst:1739 ../Doc/library/dis.rst:1793
msgid "The operand determines which intrinsic function is called:"
msgstr ""

#: ../Doc/library/dis.rst:1742 ../Doc/library/dis.rst:1796
msgid "Operand"
msgstr ""

#: ../Doc/library/dis.rst:1742 ../Doc/library/dis.rst:1796
msgid "Description"
msgstr ""

#: ../Doc/library/dis.rst:1744
msgid "``INTRINSIC_1_INVALID``"
msgstr ""

#: ../Doc/library/dis.rst:1744 ../Doc/library/dis.rst:1798
msgid "Not valid"
msgstr ""

#: ../Doc/library/dis.rst:1746
msgid "``INTRINSIC_PRINT``"
msgstr ""

#: ../Doc/library/dis.rst:1746
msgid "Prints the argument to standard out. Used in the REPL."
msgstr ""

#: ../Doc/library/dis.rst:1749
msgid "``INTRINSIC_IMPORT_STAR``"
msgstr ""

#: ../Doc/library/dis.rst:1749
msgid "Performs ``import *`` for the named module."
msgstr ""

#: ../Doc/library/dis.rst:1752
msgid "``INTRINSIC_STOPITERATION_ERROR``"
msgstr ""

#: ../Doc/library/dis.rst:1752
msgid "Extracts the return value from a ``StopIteration`` exception."
msgstr ""

#: ../Doc/library/dis.rst:1755
msgid "``INTRINSIC_ASYNC_GEN_WRAP``"
msgstr ""

#: ../Doc/library/dis.rst:1755
msgid "Wraps an async generator value"
msgstr ""

#: ../Doc/library/dis.rst:1757
msgid "``INTRINSIC_UNARY_POSITIVE``"
msgstr ""

#: ../Doc/library/dis.rst:1757
msgid "Performs the unary ``+`` operation"
msgstr ""

#: ../Doc/library/dis.rst:1760
msgid "``INTRINSIC_LIST_TO_TUPLE``"
msgstr ""

#: ../Doc/library/dis.rst:1760
msgid "Converts a list to a tuple"
msgstr ""

#: ../Doc/library/dis.rst:1762
msgid "``INTRINSIC_TYPEVAR``"
msgstr ""

#: ../Doc/library/dis.rst:1762
msgid "Creates a :class:`typing.TypeVar`"
msgstr ""

#: ../Doc/library/dis.rst:1764
msgid "``INTRINSIC_PARAMSPEC``"
msgstr ""

#: ../Doc/library/dis.rst:1764
msgid "Creates a :class:`typing.ParamSpec`"
msgstr ""

#: ../Doc/library/dis.rst:1767
msgid "``INTRINSIC_TYPEVARTUPLE``"
msgstr ""

#: ../Doc/library/dis.rst:1767
msgid "Creates a :class:`typing.TypeVarTuple`"
msgstr ""

#: ../Doc/library/dis.rst:1770
msgid "``INTRINSIC_SUBSCRIPT_GENERIC``"
msgstr ""

#: ../Doc/library/dis.rst:1770
msgid "Returns :class:`typing.Generic` subscripted with the argument"
msgstr ""

#: ../Doc/library/dis.rst:1773
msgid "``INTRINSIC_TYPEALIAS``"
msgstr ""

#: ../Doc/library/dis.rst:1773
msgid ""
"Creates a :class:`typing.TypeAliasType`; used in the :keyword:`type` "
"statement. The argument is a tuple of the type alias's name, type "
"parameters, and value."
msgstr ""

#: ../Doc/library/dis.rst:1785
msgid ""
"Calls an intrinsic function with two arguments. Used to implement "
"functionality that is not performance critical::"
msgstr ""

#: ../Doc/library/dis.rst:1788
msgid ""
"arg2 = STACK.pop()\n"
"arg1 = STACK.pop()\n"
"result = intrinsic2(arg1, arg2)\n"
"STACK.append(result)"
msgstr ""

#: ../Doc/library/dis.rst:1798
msgid "``INTRINSIC_2_INVALID``"
msgstr ""

#: ../Doc/library/dis.rst:1800
msgid "``INTRINSIC_PREP_RERAISE_STAR``"
msgstr ""

#: ../Doc/library/dis.rst:1800
msgid "Calculates the :exc:`ExceptionGroup` to raise from a ``try-except*``."
msgstr ""

#: ../Doc/library/dis.rst:1804
msgid "``INTRINSIC_TYPEVAR_WITH_BOUND``"
msgstr ""

#: ../Doc/library/dis.rst:1804
msgid "Creates a :class:`typing.TypeVar` with a bound."
msgstr ""

#: ../Doc/library/dis.rst:1807
msgid "``INTRINSIC_TYPEVAR_WITH_CONSTRAINTS``"
msgstr ""

#: ../Doc/library/dis.rst:1807
msgid "Creates a :class:`typing.TypeVar` with constraints."
msgstr ""

#: ../Doc/library/dis.rst:1811
msgid "``INTRINSIC_SET_FUNCTION_TYPE_PARAMS``"
msgstr ""

#: ../Doc/library/dis.rst:1811
msgid "Sets the ``__type_params__`` attribute of a function."
msgstr ""

#: ../Doc/library/dis.rst:1818
#, fuzzy
msgid "**Pseudo-instructions**"
msgstr "**Instrucciones generales**"

#: ../Doc/library/dis.rst:1820
msgid ""
"These opcodes do not appear in Python bytecode. They are used by the "
"compiler but are replaced by real opcodes or removed before bytecode is "
"generated."
msgstr ""

#: ../Doc/library/dis.rst:1825
msgid ""
"Set up an exception handler for the following code block. If an exception "
"occurs, the value stack level is restored to its current state and control "
"is transferred to the exception handler at ``target``."
msgstr ""

#: ../Doc/library/dis.rst:1832
msgid ""
"Like ``SETUP_FINALLY``, but in case of an exception also pushes the last "
"instruction (``lasti``) to the stack so that ``RERAISE`` can restore it. If "
"an exception occurs, the value stack level and the last instruction on the "
"frame are restored to their current state, and control is transferred to the "
"exception handler at ``target``."
msgstr ""

#: ../Doc/library/dis.rst:1841
msgid ""
"Like ``SETUP_CLEANUP``, but in case of an exception one more item is popped "
"from the stack before control is transferred to the exception handler at "
"``target``."
msgstr ""

#: ../Doc/library/dis.rst:1845
msgid ""
"This variant is used in :keyword:`with` and :keyword:`async with` "
"constructs, which push the return value of the context "
"manager's :meth:`~object.__enter__` or :meth:`~object.__aenter__` to the "
"stack."
msgstr ""

#: ../Doc/library/dis.rst:1852
msgid ""
"Marks the end of the code block associated with the last ``SETUP_FINALLY``, "
"``SETUP_CLEANUP`` or ``SETUP_WITH``."
msgstr ""

#: ../Doc/library/dis.rst:1858
msgid ""
"Undirected relative jump instructions which are replaced by their directed "
"(forward/backward) counterparts by the assembler."
msgstr ""

#: ../Doc/library/dis.rst:1863
#, fuzzy
msgid ""
"Pushes a reference to the cell contained in slot ``i`` of the \"fast "
"locals\" storage."
msgstr ""
"Almacena TOS en la celda contenida en la ranura ``i`` del almacenamiento "
"\"locales rápidos\"."

#: ../Doc/library/dis.rst:1866
#, fuzzy
msgid ""
"Note that ``LOAD_CLOSURE`` is replaced with ``LOAD_FAST`` in the assembler."
msgstr ""
"Tenga en cuenta que ``LOAD_CLOSURE`` es efectivamente un alias para "
"``LOAD_FAST``. Existe para mantener el bytecode un poco más legible."

#: ../Doc/library/dis.rst:1868
msgid "This opcode is now a pseudo-instruction."
msgstr ""

#: ../Doc/library/dis.rst:1874
msgid ""
"Optimized unbound method lookup. Emitted as a ``LOAD_ATTR`` opcode with a "
"flag set in the arg."
msgstr ""

#: ../Doc/library/dis.rst:1881
msgid "Opcode collections"
msgstr "Colecciones opcode"

#: ../Doc/library/dis.rst:1883
msgid ""
"These collections are provided for automatic introspection of bytecode "
"instructions:"
msgstr ""
"Estas colecciones se proporcionan para la introspección automática de "
"instrucciones de bytecode:"

#: ../Doc/library/dis.rst:1886
msgid ""
"The collections now contain pseudo instructions and instrumented "
"instructions as well. These are opcodes with values ``>= MIN_PSEUDO_OPCODE`` "
"and ``>= MIN_INSTRUMENTED_OPCODE``."
msgstr ""

#: ../Doc/library/dis.rst:1893
msgid "Sequence of operation names, indexable using the bytecode."
msgstr "Secuencia de nombres de operaciones, indexable utilizando el bytecode."

#: ../Doc/library/dis.rst:1898
msgid "Dictionary mapping operation names to bytecodes."
msgstr "Nombres de operaciones de mapeo de diccionario a bytecodes."

#: ../Doc/library/dis.rst:1903
msgid "Sequence of all compare operation names."
msgstr "Secuencia de todos los nombres de operaciones de comparación."

#: ../Doc/library/dis.rst:1908
#, fuzzy
msgid "Sequence of bytecodes that use their argument."
msgstr "Secuencia de bytecodes que acceden a una constante."

#: ../Doc/library/dis.rst:1915
msgid "Sequence of bytecodes that access a constant."
msgstr "Secuencia de bytecodes que acceden a una constante."

#: ../Doc/library/dis.rst:1920
#, fuzzy
msgid ""
"Sequence of bytecodes that access a free variable. 'free' in this context "
"refers to names in the current scope that are referenced by inner scopes or "
"names in outer scopes that are referenced from this scope.  It does *not* "
"include references to global or builtin scopes."
msgstr ""
"Secuencia de bytecodes que acceden a una variable libre (tenga en cuenta que "
"'libre' en este contexto se refiere a nombres en el alcance actual a los que "
"hacen referencia los ámbitos internos o los nombres en los ámbitos externos "
"a los que se hace referencia desde este ámbito. **No** incluye referencias a "
"ámbitos globales o integrados)."

#: ../Doc/library/dis.rst:1928
msgid "Sequence of bytecodes that access an attribute by name."
msgstr "Secuencia de bytecodes que acceden a un atributo por nombre."

#: ../Doc/library/dis.rst:1933
#, fuzzy
msgid "Sequence of bytecodes that have a jump target. All jumps are relative."
msgstr "Secuencia de bytecodes que tienen un objetivo de salto relativo."

#: ../Doc/library/dis.rst:1940
msgid "Sequence of bytecodes that access a local variable."
msgstr "Secuencia de códigos de bytes que acceden a una variable local."

#: ../Doc/library/dis.rst:1945
msgid "Sequence of bytecodes of Boolean operations."
msgstr "Secuencia de bytecodes de operaciones booleanas."

#: ../Doc/library/dis.rst:1949
#, fuzzy
msgid "Sequence of bytecodes that set an exception handler."
msgstr "Secuencia de bytecodes que acceden a una constante."

#: ../Doc/library/dis.rst:1956
msgid "Sequence of bytecodes that have a relative jump target."
msgstr "Secuencia de bytecodes que tienen un objetivo de salto relativo."

#: ../Doc/library/dis.rst:1958
msgid "All jumps are now relative. Use :data:`hasjump`."
msgstr ""

#: ../Doc/library/dis.rst:1964
msgid "Sequence of bytecodes that have an absolute jump target."
msgstr "Secuencia de bytecodes que tienen un objetivo de salto absoluto."

#: ../Doc/library/dis.rst:1966
msgid "All jumps are now relative. This list is empty."
msgstr ""

#: ../Doc/library/dis.rst:1582
msgid "built-in function"
msgstr ""

#: ../Doc/library/dis.rst:1582
msgid "slice"
msgstr ""
