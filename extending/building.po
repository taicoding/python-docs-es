# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-21 16:38-0300\n"
"PO-Revision-Date: 2020-06-24 22:47+0200\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../Doc/extending/building.rst:7
msgid "Building C and C++ Extensions"
msgstr "Construyendo extensiones C y C++"

#: ../Doc/extending/building.rst:9
msgid ""
"A C extension for CPython is a shared library (e.g. a ``.so`` file on Linux, "
"``.pyd`` on Windows), which exports an *initialization function*."
msgstr ""
"Una extensión C para CPython es una biblioteca compartida (por ejemplo, un "
"archivo ``.so`` en Linux, ``.pyd`` en Windows), que exporta una *función de "
"inicialización*."

#: ../Doc/extending/building.rst:12
#, fuzzy
msgid ""
"To be importable, the shared library must be available "
"on :envvar:`PYTHONPATH`, and must be named after the module name, with an "
"appropriate extension. When using setuptools, the correct filename is "
"generated automatically."
msgstr ""
"Para que sea importable, la biblioteca compartida debe estar disponible "
"en :envvar:`PYTHONPATH`, y debe tener el nombre del módulo, con una "
"extensión adecuada. Cuando se usan distutils, el nombre de archivo correcto "
"se genera automáticamente."

#: ../Doc/extending/building.rst:16
msgid "The initialization function has the signature:"
msgstr "La función de inicialización tiene la firma:"

#: ../Doc/extending/building.rst:20
#, fuzzy
msgid ""
"It returns either a fully initialized module, or a :c:type:`PyModuleDef` "
"instance. See :ref:`initializing-modules` for details."
msgstr ""
"Retorna un módulo completamente inicializado o una "
"instancia :c:type:`PyModuleDef`. Ver :ref:`initializing-modules` para más "
"detalles."

#: ../Doc/extending/building.rst:25
msgid ""
"For modules with ASCII-only names, the function must be named "
"``PyInit_<modulename>``, with ``<modulename>`` replaced by the name of the "
"module. When using :ref:`multi-phase-initialization`, non-ASCII module names "
"are allowed. In this case, the initialization function name is "
"``PyInitU_<modulename>``, with ``<modulename>`` encoded using Python's "
"*punycode* encoding with hyphens replaced by underscores. In Python::"
msgstr ""
"Para los módulos con nombres solo ASCII, la función debe llamarse "
"``PyInit_<modulename>``, con ``<modulename>`` reemplazado por el nombre del "
"módulo. Cuando se usa :ref:`multi-phase-initialization`, se permiten nombres "
"de módulos que no sean ASCII. En este caso, el nombre de la función de "
"inicialización es ``PyInitU_<modulename>``, con ``<modulename>`` codificado "
"usando la codificación *punycode* de Python con guiones reemplazados por "
"guiones bajos. En Python::"

#: ../Doc/extending/building.rst:32
msgid ""
"def initfunc_name(name):\n"
"    try:\n"
"        suffix = b'_' + name.encode('ascii')\n"
"    except UnicodeEncodeError:\n"
"        suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')\n"
"    return b'PyInit' + suffix"
msgstr ""

#: ../Doc/extending/building.rst:39
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires "
"using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the *\"Multiple modules "
"in one library\"* section in :pep:`489` for details."
msgstr ""
"Es posible exportar múltiples módulos desde una única biblioteca compartida "
"definiendo múltiples funciones de inicialización. Sin embargo, importarlos "
"requiere el uso de enlaces simbólicos o un importador personalizado, porque "
"de forma predeterminada solo se encuentra la función correspondiente al "
"nombre del archivo. Consulte la sección *\"Múltiples módulos en una "
"biblioteca\"* en :pep:`489` para más detalles."

#: ../Doc/extending/building.rst:52
#, fuzzy
msgid "Building C and C++ Extensions with setuptools"
msgstr "Construyendo extensiones C y C++ con distutils"

#: ../Doc/extending/building.rst:54
msgid ""
"Python 3.12 and newer no longer come with distutils. Please refer to the "
"``setuptools`` documentation at https://setuptools.readthedocs.io/en/latest/"
"setuptools.html to learn more about how build and distribute C/C++ "
"extensions with setuptools."
msgstr ""
