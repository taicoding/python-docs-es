# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python en Español
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: Python en Español 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-21 16:38-0300\n"
"PO-Revision-Date: 2024-11-28 14:40-0600\n"
"Last-Translator: \n"
"Language-Team: python-doc-es\n"
"Language: es_US\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Generated-By: Babel 2.16.0\n"
"X-Generator: Poedit 3.4.2\n"

#: ../Doc/howto/enum.rst:5
msgid "Enum HOWTO"
msgstr "HOWTO - Enum"

#: ../Doc/howto/enum.rst:11
msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:`repr`, "
"grouping, type-safety, and a few other features."
msgstr ""
"Un :class:`Enum` es un conjunto de nombres simbólicos vinculados a valores "
"únicos. Son similares a las variables globales, pero ofrecen un :func:"
"`repr()` más útil, agrupación, seguridad de tipos y algunas otras "
"características."

#: ../Doc/howto/enum.rst:15
msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"Son más útiles cuando tiene una variable que puede tomar uno de una "
"selección limitada de valores. Por ejemplo, los días de la semana:"

#: ../Doc/howto/enum.rst:18
msgid ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"
msgstr ""
">>> from enum import Enum\n"
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7"

#: ../Doc/howto/enum.rst:28
msgid "Or perhaps the RGB primary colors::"
msgstr "O quizás los colores primarios RGB::"

#: ../Doc/howto/enum.rst:30
msgid ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"
msgstr ""
">>> from enum import Enum\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3"

#: ../Doc/howto/enum.rst:36
msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Como puede ver, crear un :class:`Enum` es tan simple como escribir una clase "
"que herede del propio :class:`Enum`."

#: ../Doc/howto/enum.rst:39
msgid "Case of Enum Members"
msgstr "Caso de miembros de Enum"

#: ../Doc/howto/enum.rst:41
msgid ""
"Because Enums are used to represent constants, and to help avoid issues with "
"name clashes between mixin-class methods/attributes and enum names, we "
"strongly recommend using UPPER_CASE names for members, and will be using "
"that style in our examples."
msgstr ""
"Dado que las enumeraciones se utilizan para representar constantes y para "
"evitar problemas con conflictos de nombres entre los métodos/atributos de "
"las clases mixin y los nombres de las enumeraciones, recomendamos "
"encarecidamente utilizar nombres en MAYÚSCULAS para los miembros, y "
"utilizaremos ese estilo en nuestros ejemplos."

#: ../Doc/howto/enum.rst:46
msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"Dependiendo de la naturaleza de la enumeración, el valor de un miembro puede "
"o no ser importante, pero de cualquier manera ese valor puede usarse para "
"obtener el miembro correspondiente:"

#: ../Doc/howto/enum.rst:50
msgid ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"
msgstr ""
">>> Weekday(3)\n"
"<Weekday.WEDNESDAY: 3>"

#: ../Doc/howto/enum.rst:53
msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""
"Como puede ver, el ``repr()`` de un miembro muestra el nombre de "
"enumeración, el nombre del miembro y el valor. El ``str()`` de un miembro "
"muestra solo el nombre de enumeración y el nombre del miembro:"

#: ../Doc/howto/enum.rst:57
msgid ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"
msgstr ""
">>> print(Weekday.THURSDAY)\n"
"Weekday.THURSDAY"

#: ../Doc/howto/enum.rst:60
msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr ""
"El *type* de un miembro de la enumeración es la enumeración a la que "
"pertenece:"

#: ../Doc/howto/enum.rst:62
msgid ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"
msgstr ""
">>> type(Weekday.MONDAY)\n"
"<enum 'Weekday'>\n"
">>> isinstance(Weekday.FRIDAY, Weekday)\n"
"True"

#: ../Doc/howto/enum.rst:67
msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr ""
"Los miembros de enumeración tienen un atributo que contiene solo su :attr:"
"`name`::"

#: ../Doc/howto/enum.rst:69
msgid ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"
msgstr ""
">>> print(Weekday.TUESDAY.name)\n"
"TUESDAY"

#: ../Doc/howto/enum.rst:72
msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "Asimismo, tienen un atributo para su :attr:`value`:"

#: ../Doc/howto/enum.rst:75
msgid ""
">>> Weekday.WEDNESDAY.value\n"
"3"
msgstr ""
">>> Weekday.WEDNESDAY.value\n"
"3"

#: ../Doc/howto/enum.rst:78
msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""
"A diferencia de muchos lenguajes que tratan las enumeraciones únicamente "
"como pares de nombre/valor, Python Enums puede tener un comportamiento "
"agregado. Por ejemplo, :class:`datetime.date` tiene dos métodos para "
"retornar el día de la semana: :meth:`weekday` y :meth:`isoweekday`. La "
"diferencia es que uno de ellos cuenta de 0 a 6 y el otro de 1 a 7. En lugar "
"de hacer un seguimiento de eso nosotros mismos, podemos agregar un método a "
"la enumeración :class:`Weekday` para extraer el día de la instancia :class:"
"`date` y retornar el miembro de enumeración coincidente:"

#: ../Doc/howto/enum.rst:86
msgid ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"
msgstr ""
"@classmethod\n"
"def from_date(cls, date):\n"
"    return cls(date.isoweekday())"

#: ../Doc/howto/enum.rst:90
msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr "La enumeración :class:`Weekday` completa ahora se ve así:"

#: ../Doc/howto/enum.rst:92
msgid ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"
msgstr ""
">>> class Weekday(Enum):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 3\n"
"...     THURSDAY = 4\n"
"...     FRIDAY = 5\n"
"...     SATURDAY = 6\n"
"...     SUNDAY = 7\n"
"...     #\n"
"...     @classmethod\n"
"...     def from_date(cls, date):\n"
"...         return cls(date.isoweekday())"

#: ../Doc/howto/enum.rst:105
msgid "Now we can find out what today is!  Observe::"
msgstr "¡Ahora podemos averiguar qué día de la semana es hoy! Observe::"

#: ../Doc/howto/enum.rst:107
msgid ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())     \n"
"<Weekday.TUESDAY: 2>"
msgstr ""
">>> from datetime import date\n"
">>> Weekday.from_date(date.today())\n"
"<Weekday.TUESDAY: 2>"

#: ../Doc/howto/enum.rst:111
msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr ""
"Por supuesto, si estás leyendo esto en otro día, verás ese día en su lugar."

#: ../Doc/howto/enum.rst:113
msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"Esta enumeración :class:`Weekday` es excelente si nuestra variable solo "
"necesita un día, pero ¿y si necesitamos varios? Tal vez estamos escribiendo "
"una función para trazar tareas durante una semana y no queremos usar un :"
"class:`list`; podríamos usar un tipo diferente de :class:`Enum`:"

#: ../Doc/howto/enum.rst:118
msgid ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"
msgstr ""
">>> from enum import Flag\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = 1\n"
"...     TUESDAY = 2\n"
"...     WEDNESDAY = 4\n"
"...     THURSDAY = 8\n"
"...     FRIDAY = 16\n"
"...     SATURDAY = 32\n"
"...     SUNDAY = 64"

#: ../Doc/howto/enum.rst:128
msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""
"Hemos cambiado dos cosas: somos heredados de :class:`Flag` y los valores son "
"todos potencia de 2."

#: ../Doc/howto/enum.rst:131
msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr ""
"Al igual que la enumeración :class:`Weekday` original anterior, podemos "
"tener una sola selección:"

#: ../Doc/howto/enum.rst:133
msgid ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"
msgstr ""
">>> first_week_day = Weekday.MONDAY\n"
">>> first_week_day\n"
"<Weekday.MONDAY: 1>"

#: ../Doc/howto/enum.rst:137
msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Pero :class:`Flag` también nos permite combinar varios miembros en una sola "
"variable:"

#: ../Doc/howto/enum.rst:140
msgid ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"
msgstr ""
">>> weekend = Weekday.SATURDAY | Weekday.SUNDAY\n"
">>> weekend\n"
"<Weekday.SATURDAY|SUNDAY: 96>"

#: ../Doc/howto/enum.rst:144
msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Incluso puede iterar sobre una variable :class:`Flag`:"

#: ../Doc/howto/enum.rst:146
msgid ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"
msgstr ""
">>> for day in weekend:\n"
"...     print(day)\n"
"Weekday.SATURDAY\n"
"Weekday.SUNDAY"

#: ../Doc/howto/enum.rst:151
msgid "Okay, let's get some chores set up::"
msgstr "Bien, preparemos algunas tareas::"

#: ../Doc/howto/enum.rst:153
msgid ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday."
"FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"
msgstr ""
">>> chores_for_ethan = {\n"
"...     'feed the cat': Weekday.MONDAY | Weekday.WEDNESDAY | Weekday."
"FRIDAY,\n"
"...     'do the dishes': Weekday.TUESDAY | Weekday.THURSDAY,\n"
"...     'answer SO questions': Weekday.SATURDAY,\n"
"...     }"

#: ../Doc/howto/enum.rst:159
msgid "And a function to display the chores for a given day::"
msgstr "Y una función para mostrar las tareas de un día determinado:"

#: ../Doc/howto/enum.rst:161
msgid ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"
msgstr ""
">>> def show_chores(chores, day):\n"
"...     for chore, days in chores.items():\n"
"...         if day in days:\n"
"...             print(chore)\n"
"...\n"
">>> show_chores(chores_for_ethan, Weekday.SATURDAY)\n"
"answer SO questions"

#: ../Doc/howto/enum.rst:169
msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto` for the values::"
msgstr ""
"En los casos en que los valores reales de los miembros no importen, puede "
"ahorrarse algo de trabajo y usar :func:`auto()` para los valores:"

#: ../Doc/howto/enum.rst:172
msgid ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"
msgstr ""
">>> from enum import auto\n"
">>> class Weekday(Flag):\n"
"...     MONDAY = auto()\n"
"...     TUESDAY = auto()\n"
"...     WEDNESDAY = auto()\n"
"...     THURSDAY = auto()\n"
"...     FRIDAY = auto()\n"
"...     SATURDAY = auto()\n"
"...     SUNDAY = auto()\n"
"...     WEEKEND = SATURDAY | SUNDAY"

#: ../Doc/howto/enum.rst:188
msgid "Programmatic access to enumeration members and their attributes"
msgstr "Acceso programático a los miembros de la enumeración y sus atributos"

#: ../Doc/howto/enum.rst:190
msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"A veces es útil acceder a los miembros en las enumeraciones "
"programáticamente (es decir, situaciones en las que ``Color.RED`` no "
"funcionará porque no se conoce el color exacto en el momento de escribir el "
"programa). ``Enum`` permite dicho acceso::"

#: ../Doc/howto/enum.rst:194
msgid ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"
msgstr ""
">>> Color(1)\n"
"<Color.RED: 1>\n"
">>> Color(3)\n"
"<Color.BLUE: 3>"

#: ../Doc/howto/enum.rst:199
msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Si desea acceder a los miembros de la enumeración por *name*, use el acceso "
"a elementos::"

#: ../Doc/howto/enum.rst:201
msgid ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"
msgstr ""
">>> Color['RED']\n"
"<Color.RED: 1>\n"
">>> Color['GREEN']\n"
"<Color.GREEN: 2>"

#: ../Doc/howto/enum.rst:206
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""
"Si tiene un miembro de enumeración y necesita su :attr:`name` o :attr:"
"`value`:"

#: ../Doc/howto/enum.rst:208
msgid ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"
msgstr ""
">>> member = Color.RED\n"
">>> member.name\n"
"'RED'\n"
">>> member.value\n"
"1"

#: ../Doc/howto/enum.rst:216
msgid "Duplicating enum members and values"
msgstr "Duplicar miembros y valores de enumeración"

#: ../Doc/howto/enum.rst:218
msgid "Having two enum members with the same name is invalid::"
msgstr "Tener dos miembros de enumeración con el mismo nombre no es válido::"

#: ../Doc/howto/enum.rst:220
msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     SQUARE = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: 'SQUARE' already defined as 2"

#: ../Doc/howto/enum.rst:228
msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"Sin embargo, un miembro de enumeración puede tener otros nombres asociados. "
"Dadas dos entradas ``A`` y ``B`` con el mismo valor (y ``A`` definido "
"primero), ``B`` es un alias para el miembro ``A``. La búsqueda por valor del "
"valor de ``A`` retornará el miembro ``A``. La búsqueda por nombre de ``A`` "
"retornará el miembro ``A``. La búsqueda por nombre de ``B`` también "
"retornará el miembro ``A``::"

#: ../Doc/howto/enum.rst:234
msgid ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"
msgstr ""
">>> class Shape(Enum):\n"
"...     SQUARE = 2\n"
"...     DIAMOND = 1\n"
"...     CIRCLE = 3\n"
"...     ALIAS_FOR_SQUARE = 2\n"
"...\n"
">>> Shape.SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape.ALIAS_FOR_SQUARE\n"
"<Shape.SQUARE: 2>\n"
">>> Shape(2)\n"
"<Shape.SQUARE: 2>"

#: ../Doc/howto/enum.rst:249
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"No está permitido intentar crear un miembro con el mismo nombre que un "
"atributo ya definido (otro miembro, un método, etc.) o intentar crear un "
"atributo con el mismo nombre que un miembro."

#: ../Doc/howto/enum.rst:255
msgid "Ensuring unique enumeration values"
msgstr "Garantizar valores de enumeración únicos"

#: ../Doc/howto/enum.rst:257
msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"De forma predeterminada, las enumeraciones permiten múltiples nombres como "
"alias para el mismo valor. Cuando no se desea este comportamiento, puede "
"usar el decorador :func:`unique`:"

#: ../Doc/howto/enum.rst:260
msgid ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"
msgstr ""
">>> from enum import Enum, unique\n"
">>> @unique\n"
"... class Mistake(Enum):\n"
"...     ONE = 1\n"
"...     TWO = 2\n"
"...     THREE = 3\n"
"...     FOUR = 3\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: duplicate values found in <enum 'Mistake'>: FOUR -> THREE"

#: ../Doc/howto/enum.rst:274
msgid "Using automatic values"
msgstr "Uso de valores automáticos"

#: ../Doc/howto/enum.rst:276
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "Si el valor exacto no es importante, puede usar :class:`auto`::"

#: ../Doc/howto/enum.rst:278
msgid ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"
msgstr ""
">>> from enum import Enum, auto\n"
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> [member.value for member in Color]\n"
"[1, 2, 3]"

#: ../Doc/howto/enum.rst:287
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Los valores son elegidos por :func:`_generate_next_value_`, que se pueden "
"anular:"

#: ../Doc/howto/enum.rst:290
msgid ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"
msgstr ""
">>> class AutoName(Enum):\n"
"...     @staticmethod\n"
"...     def _generate_next_value_(name, start, count, last_values):\n"
"...         return name\n"
"...\n"
">>> class Ordinal(AutoName):\n"
"...     NORTH = auto()\n"
"...     SOUTH = auto()\n"
"...     EAST = auto()\n"
"...     WEST = auto()\n"
"...\n"
">>> [member.value for member in Ordinal]\n"
"['NORTH', 'SOUTH', 'EAST', 'WEST']"

#: ../Doc/howto/enum.rst:306
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""
"El método :meth:`_generate_next_value_` debe definirse antes que cualquier "
"miembro."

#: ../Doc/howto/enum.rst:309
msgid "Iteration"
msgstr "Iteración"

#: ../Doc/howto/enum.rst:311
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Iterar sobre los miembros de una enumeración no proporciona los alias:"

#: ../Doc/howto/enum.rst:313
msgid ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday."
"THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: "
"64>]"
msgstr ""
">>> list(Shape)\n"
"[<Shape.SQUARE: 2>, <Shape.DIAMOND: 1>, <Shape.CIRCLE: 3>]\n"
">>> list(Weekday)\n"
"[<Weekday.MONDAY: 1>, <Weekday.TUESDAY: 2>, <Weekday.WEDNESDAY: 4>, <Weekday."
"THURSDAY: 8>, <Weekday.FRIDAY: 16>, <Weekday.SATURDAY: 32>, <Weekday.SUNDAY: "
"64>]"

#: ../Doc/howto/enum.rst:318
msgid ""
"Note that the aliases ``Shape.ALIAS_FOR_SQUARE`` and ``Weekday.WEEKEND`` "
"aren't shown."
msgstr ""
"Note que los alias ``Shape.ALIAS_FOR_SQUARE`` y ``Weekday.WEEKEND`` no se "
"muestran."

#: ../Doc/howto/enum.rst:320
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"El atributo especial ``__members__`` es una asignación ordenada de solo "
"lectura de nombres a miembros. Incluye todos los nombres definidos en la "
"enumeración, incluidos los alias::"

#: ../Doc/howto/enum.rst:324
msgid ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"
msgstr ""
">>> for name, member in Shape.__members__.items():\n"
"...     name, member\n"
"...\n"
"('SQUARE', <Shape.SQUARE: 2>)\n"
"('DIAMOND', <Shape.DIAMOND: 1>)\n"
"('CIRCLE', <Shape.CIRCLE: 3>)\n"
"('ALIAS_FOR_SQUARE', <Shape.SQUARE: 2>)"

#: ../Doc/howto/enum.rst:332
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"El atributo ``__members__`` se puede utilizar para el acceso programático "
"detallado a los miembros de la enumeración. Por ejemplo, encontrar todos los "
"alias::"

#: ../Doc/howto/enum.rst:335
msgid ""
">>> [name for name, member in Shape.__members__.items() if member.name != "
"name]\n"
"['ALIAS_FOR_SQUARE']"
msgstr ""
">>> [name for name, member in Shape.__members__.items() if member.name != "
"name]\n"
"['ALIAS_FOR_SQUARE']"

#: ../Doc/howto/enum.rst:340
msgid ""
"Aliases for flags include values with multiple flags set, such as ``3``, and "
"no flags set, i.e. ``0``."
msgstr ""
"Los alias para las banderas incluyen valores con múltiples banderas "
"establecidas, como ``3``, y ningún conjunto de banderas, es decir, ``0``."

#: ../Doc/howto/enum.rst:345
msgid "Comparisons"
msgstr "Comparaciones"

#: ../Doc/howto/enum.rst:347
msgid "Enumeration members are compared by identity::"
msgstr "Los miembros de la enumeración se comparan por identidad::"

#: ../Doc/howto/enum.rst:349
msgid ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"
msgstr ""
">>> Color.RED is Color.RED\n"
"True\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED is not Color.BLUE\n"
"True"

#: ../Doc/howto/enum.rst:356
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Las comparaciones ordenadas entre valores de enumeración son compatibles con "
"*not*. Los miembros de la enumeración no son números enteros (pero consulte "
"`IntEnum`_ a continuación):"

#: ../Doc/howto/enum.rst:359
msgid ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"
msgstr ""
">>> Color.RED < Color.BLUE\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: '<' not supported between instances of 'Color' and 'Color'"

#: ../Doc/howto/enum.rst:364
msgid "Equality comparisons are defined though::"
msgstr "Las comparaciones de igualdad se definen aunque:"

#: ../Doc/howto/enum.rst:366
msgid ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"
msgstr ""
">>> Color.BLUE == Color.RED\n"
"False\n"
">>> Color.BLUE != Color.RED\n"
"True\n"
">>> Color.BLUE == Color.BLUE\n"
"True"

#: ../Doc/howto/enum.rst:373
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Las comparaciones con valores que no son de enumeración siempre comparan no "
"iguales (nuevamente, :class:`IntEnum` se diseñó explícitamente para "
"comportarse de manera diferente, consulte a continuación):"

#: ../Doc/howto/enum.rst:377
msgid ""
">>> Color.BLUE == 2\n"
"False"
msgstr ""
">>> Color.BLUE == 2\n"
"False"

#: ../Doc/howto/enum.rst:382
msgid ""
"It is possible to reload modules -- if a reloaded module contains enums, "
"they will be recreated, and the new members may not compare identical/equal "
"to the original members."
msgstr ""
"Es posible recargar módulos; si un módulo recargado contiene enumeraciones, "
"estas se crearán de nuevo y los nuevos miembros pueden no compararse como "
"idénticos/iguales a los miembros originales."

#: ../Doc/howto/enum.rst:387
msgid "Allowed members and attributes of enumerations"
msgstr "Miembros permitidos y atributos de enumeraciones"

#: ../Doc/howto/enum.rst:389
msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"La mayoría de los ejemplos anteriores usan números enteros para los valores "
"de enumeración. El uso de números enteros es corto y práctico (y "
"proporcionado por defecto por el `Functional API`_), pero no se aplica "
"estrictamente. En la gran mayoría de los casos de uso, a uno no le importa "
"cuál es el valor real de una enumeración. Pero si el valor *is* es "
"importante, las enumeraciones pueden tener valores arbitrarios."

#: ../Doc/howto/enum.rst:395
msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Las enumeraciones son clases de Python y pueden tener métodos y métodos "
"especiales como de costumbre. Si tenemos esta enumeración:"

#: ../Doc/howto/enum.rst:398
msgid ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self is the member here\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls here is the enumeration\n"
"...         return cls.HAPPY\n"
"..."
msgstr ""
">>> class Mood(Enum):\n"
"...     FUNKY = 1\n"
"...     HAPPY = 3\n"
"...\n"
"...     def describe(self):\n"
"...         # self es el miembro aquí\n"
"...         return self.name, self.value\n"
"...\n"
"...     def __str__(self):\n"
"...         return 'my custom str! {0}'.format(self.value)\n"
"...\n"
"...     @classmethod\n"
"...     def favorite_mood(cls):\n"
"...         # cls es la enumeración aquí\n"
"...         return cls.HAPPY\n"
"..."

#: ../Doc/howto/enum.rst:415
msgid "Then::"
msgstr "Después::"

#: ../Doc/howto/enum.rst:417
msgid ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"
msgstr ""
">>> Mood.favorite_mood()\n"
"<Mood.HAPPY: 3>\n"
">>> Mood.HAPPY.describe()\n"
"('HAPPY', 3)\n"
">>> str(Mood.FUNKY)\n"
"'my custom str! 1'"

#: ../Doc/howto/enum.rst:424
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"Las reglas para lo que está permitido son las siguientes: los nombres que "
"comienzan y terminan con un solo guión bajo están reservados por enumeración "
"y no se pueden usar; todos los demás atributos definidos dentro de una "
"enumeración se convertirán en miembros de esta enumeración, con la excepción "
"de métodos especiales (:meth:`__str__`, :meth:`__add__`, etc.), descriptores "
"(los métodos también son descriptores) y nombres de variables enumerados en :"
"attr:`_ignore_`."

#: ../Doc/howto/enum.rst:431
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__`, "
"any value(s) given to the enum member will be passed into those methods. See "
"`Planet`_ for an example."
msgstr ""
"Nota:  si su enumeración define :meth:`__new__` y/o :meth:`__init__`, "
"cualquier valor(es) dado(s) al miembro de la enumeración se pasará a esos "
"métodos. Consulte `Planet`_ para ver un ejemplo."

#: ../Doc/howto/enum.rst:437
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members.  See :ref:`new-vs-init` for "
"more details."
msgstr ""
"El método :meth:`__new__`, si está definido, se usa durante la creación de "
"los miembros de Enum; luego se reemplaza por :meth:`__new__` de Enum, que se "
"usa después de la creación de clases para buscar miembros existentes.  "
"Consulte :ref:`new-vs-init` para obtener más detalles."

#: ../Doc/howto/enum.rst:444
msgid "Restricted Enum subclassing"
msgstr "Subclases de Enum restringidas"

#: ../Doc/howto/enum.rst:446
msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"Una nueva clase :class:`Enum` debe tener una clase de enumeración base, "
"hasta un tipo de datos concreto y tantas clases mixtas basadas en :class:"
"`object` como sea necesario.  El orden de estas clases base es:"

#: ../Doc/howto/enum.rst:450
msgid ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"
msgstr ""
"class EnumName([mix-in, ...,] [data-type,] base-enum):\n"
"    pass"

#: ../Doc/howto/enum.rst:453
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Además, la subclasificación de una enumeración solo se permite si la "
"enumeración no define ningún miembro. Así que esto está prohibido::"

#: ../Doc/howto/enum.rst:456
msgid ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"
msgstr ""
">>> class MoreColor(Color):\n"
"...     PINK = 17\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: <enum 'MoreColor'> cannot extend <enum 'Color'>"

#: ../Doc/howto/enum.rst:463
msgid "But this is allowed::"
msgstr "Pero esto está permitido:"

#: ../Doc/howto/enum.rst:465
msgid ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."
msgstr ""
">>> class Foo(Enum):\n"
"...     def some_behavior(self):\n"
"...         pass\n"
"...\n"
">>> class Bar(Foo):\n"
"...     HAPPY = 1\n"
"...     SAD = 2\n"
"..."

#: ../Doc/howto/enum.rst:474
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Permitir la subclasificación de enumeraciones que definen miembros "
"conduciría a una violación de algunas invariantes importantes de tipos e "
"instancias. Por otro lado, tiene sentido permitir compartir algún "
"comportamiento común entre un grupo de enumeraciones. (Consulte "
"`OrderedEnum`_ para ver un ejemplo)."

#: ../Doc/howto/enum.rst:483
msgid "Dataclass support"
msgstr "Soporte de Dataclass"

#: ../Doc/howto/enum.rst:485
msgid ""
"When inheriting from a :class:`~dataclasses.dataclass`, the :meth:`~Enum."
"__repr__` omits the inherited class' name.  For example::"
msgstr ""
"Cuando se hereda de una :class:`~dataclasses.dataclass`, el :meth:`~Enum."
"__repr__` omite el nombre de la clase heredada.  Por ejemplo::"

#: ../Doc/howto/enum.rst:488
msgid ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"
msgstr ""
">>> from dataclasses import dataclass, field\n"
">>> @dataclass\n"
"... class CreatureDataMixin:\n"
"...     size: str\n"
"...     legs: int\n"
"...     tail: bool = field(repr=False, default=True)\n"
"...\n"
">>> class Creature(CreatureDataMixin, Enum):\n"
"...     BEETLE = 'small', 6\n"
"...     DOG = 'medium', 4\n"
"...\n"
">>> Creature.DOG\n"
"<Creature.DOG: size='medium', legs=4>"

#: ../Doc/howto/enum.rst:502
msgid ""
"Use the :func:`~dataclasses.dataclass` argument ``repr=False`` to use the "
"standard :func:`repr`."
msgstr ""
"Utilice el argumento ``repr=False`` de :func:`~dataclasses.dataclass` para "
"utilizar el :func:`repr` estándar."

#: ../Doc/howto/enum.rst:505
msgid ""
"Only the dataclass fields are shown in the value area, not the dataclass' "
"name."
msgstr ""
"Solo se muestran los campos de la dataclass en el área de valores, no el "
"nombre de la dataclass."

#: ../Doc/howto/enum.rst:511
msgid ""
"Adding :func:`~dataclasses.dataclass` decorator to :class:`Enum` and its "
"subclasses is not supported. It will not raise any errors, but it will "
"produce very strange results at runtime, such as members being equal to each "
"other::"
msgstr ""
"Añadir el decorador :func:`~dataclasses.dataclass` a  :class:`Enum` y sus "
"subclases no está soportado.  No lanzará ningún error, pero producirá "
"resultados bastante extraños en tiempo de ejecución, como miembros siendo "
"iguales a otros:"

#: ../Doc/howto/enum.rst:516
msgid ""
">>> @dataclass               # don't do this: it does not make any sense\n"
"... class Color(Enum):\n"
"...    RED = 1\n"
"...    BLUE = 2\n"
"...\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED == Color.BLUE  # problem is here: they should not be equal\n"
"True"
msgstr ""
">>> @dataclass               # no haga esto: no tiene ningún sentido\n"
"... class Color(Enum):\n"
"...    RED = 1\n"
"...    BLUE = 2\n"
"...\n"
">>> Color.RED is Color.BLUE\n"
"False\n"
">>> Color.RED == Color.BLUE  # problema aquí:: no deberían ser iguales\n"
"True"

#: ../Doc/howto/enum.rst:528
msgid "Pickling"
msgstr "Serialización (Pickling)"

#: ../Doc/howto/enum.rst:530
msgid "Enumerations can be pickled and unpickled::"
msgstr "Las enumeraciones se pueden serializar y deserializar:"

#: ../Doc/howto/enum.rst:532
msgid ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"
msgstr ""
">>> from test.test_enum import Fruit\n"
">>> from pickle import dumps, loads\n"
">>> Fruit.TOMATO is loads(dumps(Fruit.TOMATO))\n"
"True"

#: ../Doc/howto/enum.rst:537
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Se aplican las restricciones habituales para el *pickling*: las "
"enumeraciones serializables deben definirse en el nivel superior de un "
"módulo, ya que el decapado requiere que se puedan importar desde ese módulo."

#: ../Doc/howto/enum.rst:543
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"Con la versión 4 del protocolo pickle es posible deserializar fácilmente "
"enumeraciones anidadas en otras clases."

#: ../Doc/howto/enum.rst:546
msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class.  The default method is by-"
"value, but enums with complicated values may want to use by-name::"
msgstr ""
"Es posible modificar la forma en que los miembros de la enumeración se "
"serialicen / deserialicen definiendo :meth:`__reduce_ex__` en la clase de "
"enumeración.  El método predeterminado es por valor, pero las enumeraciones "
"con valores complicados pueden querer utilizar por nombre::"

#: ../Doc/howto/enum.rst:550
msgid ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"
msgstr ""
">>> import enum\n"
">>> class MyEnum(enum.Enum):\n"
"...     __reduce_ex__ = enum.pickle_by_enum_name"

#: ../Doc/howto/enum.rst:556
msgid ""
"Using by-name for flags is not recommended, as unnamed aliases will not "
"unpickle."
msgstr ""
"No se recomienda usar banderas por nombre , ya que los alias sin nombre no "
"se desempaquetarán."

#: ../Doc/howto/enum.rst:561
msgid "Functional API"
msgstr "API funcional"

#: ../Doc/howto/enum.rst:563
msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"Se puede llamar a la clase :class:`Enum`, que proporciona la siguiente API "
"funcional:"

#: ../Doc/howto/enum.rst:565
msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG')\n"
">>> Animal\n"
"<enum 'Animal'>\n"
">>> Animal.ANT\n"
"<Animal.ANT: 1>\n"
">>> list(Animal)\n"
"[<Animal.ANT: 1>, <Animal.BEE: 2>, <Animal.CAT: 3>, <Animal.DOG: 4>]"

#: ../Doc/howto/enum.rst:573
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"La semántica de esta API se asemeja a :class:`~collections.namedtuple`. El "
"primer argumento de la llamada a :class:`Enum` es el nombre de la "
"enumeración."

#: ../Doc/howto/enum.rst:576
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"El segundo argumento es el *source* de nombres de miembros de enumeración. "
"Puede ser una cadena de nombres separados por espacios en blanco, una "
"secuencia de nombres, una secuencia de 2 tuplas con pares clave/valor o una "
"asignación (por ejemplo, un diccionario) de nombres a valores. Las dos "
"últimas opciones permiten asignar valores arbitrarios a las enumeraciones; "
"los otros asignan automáticamente números enteros crecientes que comienzan "
"con 1 (use el parámetro ``start`` para especificar un valor inicial "
"diferente). Se retorna una nueva clase derivada de :class:`Enum`. En otras "
"palabras, la asignación anterior a :class:`Animal` es equivalente a:"

#: ../Doc/howto/enum.rst:585
msgid ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."
msgstr ""
">>> class Animal(Enum):\n"
"...     ANT = 1\n"
"...     BEE = 2\n"
"...     CAT = 3\n"
"...     DOG = 4\n"
"..."

#: ../Doc/howto/enum.rst:592
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"La razón por la que se toma por defecto ``1`` como el número inicial y no "
"``0`` es que ``0`` es ``False`` en un sentido booleano, pero por defecto "
"todos los miembros de la enumeración se evalúan como ``True``."

#: ../Doc/howto/enum.rst:596
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""
"Deserializar las enumeraciones creadas con la API funcional puede ser "
"complicado, ya que los detalles de implementación de la pila de marcos se "
"usan para tratar de averiguar en qué módulo se está creando la enumeración "
"(por ejemplo, fallará si usa una función de utilidad en un módulo separado, "
"y también puede no trabajar en IronPython o Jython). La solución es "
"especificar el nombre del módulo explícitamente de la siguiente manera:"

#: ../Doc/howto/enum.rst:602
msgid ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"
msgstr ">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', module=__name__)"

#: ../Doc/howto/enum.rst:606
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Si no se proporciona ``module`` y Enum no puede determinar de qué se trata, "
"los nuevos miembros de Enum no serán seleccionables; para mantener los "
"errores más cerca de la fuente, se desactivará el decapado."

#: ../Doc/howto/enum.rst:610
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~type.__qualname__` being set to the location where pickle will be able to "
"find the class.  For example, if the class was made available in class "
"SomeData in the global scope::"
msgstr ""
"El nuevo protocolo pickle 4 también, en algunas circunstancias, depende de "
"que :attr:`~type.__qualname__` se establezca en la ubicación donde pickle "
"podrá encontrar la clase. Por ejemplo, si la clase estuvo disponible en la "
"clase SomeData en el ámbito global:"

#: ../Doc/howto/enum.rst:615
msgid ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"
msgstr ""
">>> Animal = Enum('Animal', 'ANT BEE CAT DOG', qualname='SomeData.Animal')"

#: ../Doc/howto/enum.rst:617
msgid "The complete signature is::"
msgstr "La firma completa es::"

#: ../Doc/howto/enum.rst:619
msgid ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"
msgstr ""
"Enum(\n"
"    value='NewEnumName',\n"
"    names=<...>,\n"
"    *,\n"
"    module='...',\n"
"    qualname='...',\n"
"    type=<mixed-in class>,\n"
"    start=1,\n"
"    )"

#: ../Doc/howto/enum.rst:629
msgid "*value*: What the new enum class will record as its name."
msgstr ""
"*value*: Lo que la nueva clase de enumeración registrará como su nombre."

#: ../Doc/howto/enum.rst:631
msgid ""
"*names*: The enum members.  This can be a whitespace- or comma-separated "
"string (values will start at 1 unless otherwise specified)::"
msgstr ""
"*names*: Los miembros de la enumeración. Puede ser una cadena separada por "
"comas o espacios en blanco (los valores comenzarán en 1 a menos que se "
"especifique lo contrario):"

#: ../Doc/howto/enum.rst:634
msgid "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"
msgstr "'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'"

#: ../Doc/howto/enum.rst:636
msgid "or an iterator of names::"
msgstr "o un iterador de nombres::"

#: ../Doc/howto/enum.rst:638
msgid "['RED', 'GREEN', 'BLUE']"
msgstr "['RED', 'GREEN', 'BLUE']"

#: ../Doc/howto/enum.rst:640
msgid "or an iterator of (name, value) pairs::"
msgstr "o un iterador de (nombre, valor) pares::"

#: ../Doc/howto/enum.rst:642
msgid "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"
msgstr "[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]"

#: ../Doc/howto/enum.rst:644
msgid "or a mapping::"
msgstr "o un mapeo::"

#: ../Doc/howto/enum.rst:646
msgid "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"
msgstr "{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}"

#: ../Doc/howto/enum.rst:648
msgid "*module*: name of module where new enum class can be found."
msgstr ""
"*module*: nombre del módulo donde se puede encontrar la nueva clase de "
"enumeración."

#: ../Doc/howto/enum.rst:650
msgid "*qualname*: where in module new enum class can be found."
msgstr ""
"*qualname*: donde en el módulo se puede encontrar la nueva clase de "
"enumeración."

#: ../Doc/howto/enum.rst:652
msgid "*type*: type to mix in to new enum class."
msgstr "*type*: tipo para mezclar en la nueva clase de enumeración."

#: ../Doc/howto/enum.rst:654
msgid "*start*: number to start counting at if only names are passed in."
msgstr "*start*: número para comenzar a contar si solo se pasan nombres."

#: ../Doc/howto/enum.rst:656
msgid "The *start* parameter was added."
msgstr "Se agregó el parámetro *start*."

#: ../Doc/howto/enum.rst:661
msgid "Derived Enumerations"
msgstr "Enumeraciones derivadas"

#: ../Doc/howto/enum.rst:664
msgid "IntEnum"
msgstr "IntEnum"

#: ../Doc/howto/enum.rst:666
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"La primera variación de :class:`Enum` que se proporciona también es una "
"subclase de :class:`int`. Los miembros de un :class:`IntEnum` se pueden "
"comparar con números enteros; por extensión, las enumeraciones enteras de "
"diferentes tipos también se pueden comparar entre sí:"

#: ../Doc/howto/enum.rst:671
msgid ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"
msgstr ""
">>> from enum import IntEnum\n"
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Request(IntEnum):\n"
"...     POST = 1\n"
"...     GET = 2\n"
"...\n"
">>> Shape == 1\n"
"False\n"
">>> Shape.CIRCLE == 1\n"
"True\n"
">>> Shape.CIRCLE == Request.POST\n"
"True"

#: ../Doc/howto/enum.rst:687
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Sin embargo, aún no se pueden comparar con las enumeraciones :class:`Enum` "
"estándar:"

#: ../Doc/howto/enum.rst:689
msgid ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"
msgstr ""
">>> class Shape(IntEnum):\n"
"...     CIRCLE = 1\n"
"...     SQUARE = 2\n"
"...\n"
">>> class Color(Enum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...\n"
">>> Shape.CIRCLE == Color.RED\n"
"False"

#: ../Doc/howto/enum.rst:700
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ""
"Los valores :class:`IntEnum` se comportan como números enteros en otras "
"formas que esperaría:"

#: ../Doc/howto/enum.rst:702
msgid ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"
msgstr ""
">>> int(Shape.CIRCLE)\n"
"1\n"
">>> ['a', 'b', 'c'][Shape.CIRCLE]\n"
"'b'\n"
">>> [i for i in range(Shape.SQUARE)]\n"
"[0, 1]"

#: ../Doc/howto/enum.rst:711
msgid "StrEnum"
msgstr "StrEnum"

#: ../Doc/howto/enum.rst:713
msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""
"La segunda variación de :class:`Enum` que se proporciona también es una "
"subclase de :class:`str`. Los miembros de un :class:`StrEnum` se pueden "
"comparar con cadenas; por extensión, las enumeraciones de cadenas de "
"diferentes tipos también se pueden comparar entre sí."

#: ../Doc/howto/enum.rst:722
msgid "IntFlag"
msgstr "IntFlag"

#: ../Doc/howto/enum.rst:724
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""
"La siguiente variación de :class:`Enum` proporcionada, :class:`IntFlag`, "
"también se basa en :class:`int`. La diferencia es que los miembros :class:"
"`IntFlag` se pueden combinar usando los operadores bit a bit (&, \\|, ^, ~) "
"y el resultado sigue siendo un miembro :class:`IntFlag`, si es posible. Al "
"igual que :class:`IntEnum`, los miembros :class:`IntFlag` también son "
"números enteros y se pueden utilizar siempre que se utilice un :class:`int`."

#: ../Doc/howto/enum.rst:732
msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"Cualquier operación en un miembro :class:`IntFlag` además de las operaciones "
"bit a bit perderá la pertenencia a :class:`IntFlag`."

#: ../Doc/howto/enum.rst:735
msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Las operaciones bit a bit que den como resultado valores :class:`IntFlag` no "
"válidos perderán la pertenencia a :class:`IntFlag`. Ver :class:"
"`FlagBoundary` para más detalles."

#: ../Doc/howto/enum.rst:742
msgid "Sample :class:`IntFlag` class::"
msgstr "Ejemplo de clase :class:`IntFlag`::"

#: ../Doc/howto/enum.rst:744
msgid ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"
msgstr ""
">>> from enum import IntFlag\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> Perm.R | Perm.W\n"
"<Perm.R|W: 6>\n"
">>> Perm.R + Perm.W\n"
"6\n"
">>> RW = Perm.R | Perm.W\n"
">>> Perm.R in RW\n"
"True"

#: ../Doc/howto/enum.rst:758
msgid "It is also possible to name the combinations::"
msgstr "También es posible nombrar las combinaciones:"

#: ../Doc/howto/enum.rst:760
msgid ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"
msgstr ""
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...     RWX = 7\n"
"...\n"
">>> Perm.RWX\n"
"<Perm.RWX: 7>\n"
">>> ~Perm.RWX\n"
"<Perm: 0>\n"
">>> Perm(7)\n"
"<Perm.RWX: 7>"

#: ../Doc/howto/enum.rst:775
msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"Las combinaciones con nombre se consideran alias. Los alias no aparecen "
"durante la iteración, pero se pueden devolver a partir de búsquedas por "
"valor."

#: ../Doc/howto/enum.rst:780
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Otra diferencia importante entre :class:`IntFlag` y :class:`Enum` es que si "
"no se establecen banderas (el valor es 0), su evaluación booleana es :data:"
"`False`::"

#: ../Doc/howto/enum.rst:783
msgid ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"
msgstr ""
">>> Perm.R & Perm.X\n"
"<Perm: 0>\n"
">>> bool(Perm.R & Perm.X)\n"
"False"

#: ../Doc/howto/enum.rst:788
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Debido a que los miembros :class:`IntFlag` también son subclases de :class:"
"`int`, se pueden combinar con ellos (pero pueden perder la membresía :class:"
"`IntFlag`::"

#: ../Doc/howto/enum.rst:791
msgid ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"
msgstr ""
">>> Perm.X | 4\n"
"<Perm.R|X: 5>\n"
"\n"
">>> Perm.X + 8\n"
"9"

#: ../Doc/howto/enum.rst:799
msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"El operador de negación, ``~``, siempre retorna un miembro :class:`IntFlag` "
"con un valor positivo:"

#: ../Doc/howto/enum.rst:802
msgid ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"
msgstr ""
">>> (~Perm.X).value == (Perm.R|Perm.W).value == 6\n"
"True"

#: ../Doc/howto/enum.rst:805
msgid ":class:`IntFlag` members can also be iterated over::"
msgstr "Los miembros :class:`IntFlag` también se pueden iterar sobre:"

#: ../Doc/howto/enum.rst:807
msgid ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"
msgstr ""
">>> list(RW)\n"
"[<Perm.R: 4>, <Perm.W: 2>]"

#: ../Doc/howto/enum.rst:814
msgid "Flag"
msgstr "Bandera"

#: ../Doc/howto/enum.rst:816
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"La última variación es :class:`Flag`. Al igual que :class:`IntFlag`, los "
"miembros de :class:`Flag` se pueden combinar mediante los operadores bit a "
"bit (&, \\|, ^, ~). A diferencia de :class:`IntFlag`, no se pueden combinar "
"ni comparar con ninguna otra enumeración :class:`Flag` ni con :class:`int`. "
"Si bien es posible especificar los valores directamente, se recomienda usar :"
"class:`auto` como valor y dejar que :class:`Flag` seleccione un valor "
"apropiado."

#: ../Doc/howto/enum.rst:825
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Al igual que :class:`IntFlag`, si una combinación de miembros :class:`Flag` "
"da como resultado que no se establezcan indicadores, la evaluación booleana "
"es :data:`False`::"

#: ../Doc/howto/enum.rst:828
msgid ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"
msgstr ""
">>> from enum import Flag, auto\n"
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.RED & Color.GREEN\n"
"<Color: 0>\n"
">>> bool(Color.RED & Color.GREEN)\n"
"False"

#: ../Doc/howto/enum.rst:839
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags will not::"
msgstr ""
"Las banderas individuales deben tener valores que sean potencias de dos (1, "
"2, 4, 8, ...), mientras que las combinaciones de banderas no::"

#: ../Doc/howto/enum.rst:842
msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...     WHITE = RED | BLUE | GREEN\n"
"...\n"
">>> Color.WHITE\n"
"<Color.WHITE: 7>"

#: ../Doc/howto/enum.rst:851
msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Dar un nombre a la condición \"sin banderas establecidas\" no cambia su "
"valor booleano:"

#: ../Doc/howto/enum.rst:854
msgid ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"
msgstr ""
">>> class Color(Flag):\n"
"...     BLACK = 0\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.BLACK\n"
"<Color.BLACK: 0>\n"
">>> bool(Color.BLACK)\n"
"False"

#: ../Doc/howto/enum.rst:865
msgid ":class:`Flag` members can also be iterated over::"
msgstr "Los miembros :class:`Flag` también se pueden iterar sobre:"

#: ../Doc/howto/enum.rst:867
msgid ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"
msgstr ""
">>> purple = Color.RED | Color.BLUE\n"
">>> list(purple)\n"
"[<Color.RED: 1>, <Color.BLUE: 2>]"

#: ../Doc/howto/enum.rst:875
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"Para la mayoría del código nuevo, se recomienda encarecidamente :class:"
"`Enum` y :class:`Flag`, ya que :class:`IntEnum` y :class:`IntFlag` rompen "
"algunas promesas semánticas de una enumeración (al ser comparables con los "
"números enteros y, por lo tanto, por la transitividad a otras enumeraciones "
"no relacionadas). :class:`IntEnum` y :class:`IntFlag` deben usarse solo en "
"los casos en que :class:`Enum` y :class:`Flag` no sirvan; por ejemplo, "
"cuando las constantes enteras se reemplazan con enumeraciones, o para la "
"interoperabilidad con otros sistemas."

#: ../Doc/howto/enum.rst:885
msgid "Others"
msgstr "Otros"

#: ../Doc/howto/enum.rst:887
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Si bien :class:`IntEnum` es parte del módulo :mod:`enum`, sería muy simple "
"de implementar de forma independiente:"

#: ../Doc/howto/enum.rst:890
msgid ""
"class IntEnum(int, ReprEnum):   # or Enum instead of ReprEnum\n"
"    pass"
msgstr ""
"class IntEnum(int, ReprEnum):   # o Enum en lugar de ReprEnum\n"
"    pass"

#: ../Doc/howto/enum.rst:893
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""
"Esto demuestra cómo se pueden definir enumeraciones derivadas similares; por "
"ejemplo, un :class:`FloatEnum` que se mezcla en :class:`float` en lugar de :"
"class:`int`."

#: ../Doc/howto/enum.rst:896
msgid "Some rules:"
msgstr "Algunas reglas:"

#: ../Doc/howto/enum.rst:898
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before the :class:"
"`Enum` class itself in the sequence of bases, as in the :class:`IntEnum` "
"example above."
msgstr ""
"Al subclasificar :class:`Enum`, los tipos de combinación deben aparecer "
"antes que :class:`Enum` en la secuencia de bases, como en el ejemplo "
"anterior de :class:`IntEnum`."

#: ../Doc/howto/enum.rst:901
msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""
"Los tipos mixtos deben ser subclasificables. Por ejemplo, :class:`bool` y :"
"class:`range` no son subclasificables y generarán un error durante la "
"creación de Enum si se usan como tipo de combinación."

#: ../Doc/howto/enum.rst:904
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Si bien :class:`Enum` puede tener miembros de cualquier tipo, una vez que "
"mezcle un tipo adicional, todos los miembros deben tener valores de ese "
"tipo, p. :class:`int` anterior. Esta restricción no se aplica a los "
"complementos que solo agregan métodos y no especifican otro tipo."

#: ../Doc/howto/enum.rst:908
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"Cuando se mezcla otro tipo de datos, el atributo :attr:`value` es *not the "
"same* como el propio miembro de la enumeración, aunque es equivalente y se "
"comparará igual."

#: ../Doc/howto/enum.rst:911
msgid ""
"A ``data type`` is a mixin that defines :meth:`__new__`, or a :class:"
"`~dataclasses.dataclass`"
msgstr ""
"Un ``data type`` es un mixin que define :meth:`__new__`, o una :class:"
"`~dataclasses.dataclass`"

#: ../Doc/howto/enum.rst:913
#, python-format
msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as ``%i`` or "
"``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"Formato de estilo %: ``%s`` y ``%r`` llaman a :meth:`__str__` y :meth:"
"`__repr__` de la clase :class:`Enum` respectivamente; otros códigos (como "
"``%i`` o ``%h`` para IntEnum) tratan el miembro de enumeración como su tipo "
"mixto."

#: ../Doc/howto/enum.rst:916
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`__str__` method."
msgstr ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format` y :func:"
"`format` usarán el método :meth:`__str__` de la enumeración."

#: ../Doc/howto/enum.rst:921
msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`__str__` method has been reset to their data types' :meth:`__str__` method."
msgstr ""
"Dado que :class:`IntEnum`, :class:`IntFlag` y :class:`StrEnum` están "
"diseñados para ser reemplazos directos de constantes existentes, su método :"
"meth:`__str__` se ha restablecido al método :meth:`__str__` de sus tipos de "
"datos."

#: ../Doc/howto/enum.rst:929
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "Cuándo usar :meth:`__new__` frente a :meth:`__init__`"

#: ../Doc/howto/enum.rst:931
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
":meth:`__new__` debe usarse siempre que desee personalizar el valor real del "
"miembro :class:`Enum`. Cualquier otra modificación puede ir en :meth:"
"`__new__` o :meth:`__init__`, siendo preferible :meth:`__init__`."

#: ../Doc/howto/enum.rst:935
msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Por ejemplo, si desea pasar varios elementos al constructor, pero solo desea "
"que uno de ellos sea el valor:"

#: ../Doc/howto/enum.rst:938
msgid ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordinate with binary codes that can be indexed by the int code.\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"
msgstr ""
">>> class Coordinate(bytes, Enum):\n"
"...     \"\"\"\n"
"...     Coordenada con códigos binarios que pueden ser indexada por el  "
"código entero\n"
"...     \"\"\"\n"
"...     def __new__(cls, value, label, unit):\n"
"...         obj = bytes.__new__(cls, [value])\n"
"...         obj._value_ = value\n"
"...         obj.label = label\n"
"...         obj.unit = unit\n"
"...         return obj\n"
"...     PX = (0, 'P.X', 'km')\n"
"...     PY = (1, 'P.Y', 'km')\n"
"...     VX = (2, 'V.X', 'km/s')\n"
"...     VY = (3, 'V.Y', 'km/s')\n"
"...\n"
"\n"
">>> print(Coordinate['PY'])\n"
"Coordinate.PY\n"
"\n"
">>> print(Coordinate(3))\n"
"Coordinate.VY"

#: ../Doc/howto/enum.rst:962
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly."
msgstr ""
"*No* llame a ``super().__new__()``, ya que encontrará el ``__new__`` de solo "
"búsqueda; en su lugar, utilice directamente el tipo de datos."

#: ../Doc/howto/enum.rst:967
msgid "Finer Points"
msgstr "Puntos más finos"

#: ../Doc/howto/enum.rst:970
msgid "Supported ``__dunder__`` names"
msgstr "Nombres ``__dunder__`` admitidos"

#: ../Doc/howto/enum.rst:972
msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` es una asignación ordenada de solo lectura de elementos "
"``member_name``:``member``. Solo está disponible en la clase."

#: ../Doc/howto/enum.rst:975
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
":meth:`__new__`, si se especifica, debe crear y devolver los miembros de "
"enumeración; también es una muy buena idea configurar correctamente el :attr:"
"`_value_` del miembro. Una vez que se crean todos los miembros, ya no se "
"utiliza."

#: ../Doc/howto/enum.rst:981
msgid "Supported ``_sunder_`` names"
msgstr "Nombres ``_sunder_`` admitidos"

#: ../Doc/howto/enum.rst:983
msgid ":attr:`~Enum._name_` -- name of the member"
msgstr ":attr:`~Enum._name_` -- nombre del miembro"

#: ../Doc/howto/enum.rst:984
msgid ":attr:`~Enum._value_` -- value of the member; can be set in ``__new__``"
msgstr ""
":attr:`~Enum._value_` -- valor del miembro; se puede configurar/modificar en "
"``__new__``"

#: ../Doc/howto/enum.rst:985
msgid ""
":meth:`~Enum._missing_` -- a lookup function used when a value is not found; "
"may be overridden"
msgstr ""
":meth:`~Enum._missing_` -- una función de búsqueda utilizada cuando no se "
"encuentra un valor; puede ser anulado"

#: ../Doc/howto/enum.rst:987
msgid ""
":attr:`~Enum._ignore_` -- a list of names, either as a :class:`list` or a :"
"class:`str`, that will not be transformed into members, and will be removed "
"from the final class"
msgstr ""
":attr:`~Enum._ignore_` -- una lista de nombres, ya sea como :class:`list` o :"
"class:`str`, que no se transformarán en miembros y se eliminarán de la clase "
"final"

#: ../Doc/howto/enum.rst:990
msgid ""
":meth:`~Enum._generate_next_value_` -- used to get an appropriate value for "
"an enum member; may be overridden"
msgstr ""
":meth:`~Enum._generate_next_value_` -- utilizado para obtener un valor "
"apropiado para un miembro de enumeración; puede ser sobrescrito"

#: ../Doc/howto/enum.rst:992
msgid ""
":meth:`~Enum._add_alias_` -- adds a new name as an alias to an existing "
"member."
msgstr ""
":meth:`~Enum._add_alias_` -- añade un nombre nuevo como alias a un miembro "
"existente."

#: ../Doc/howto/enum.rst:994
msgid ""
":meth:`~Enum._add_value_alias_` -- adds a new value as an alias to an "
"existing member.  See `MultiValueEnum`_ for an example."
msgstr ""
":meth:`~Enum._add_value_alias_` -- añade un valor nuevo como alias a un "
"miembro existente.  Vea `MultiValueEnum`_ para un ejemplo ."

#: ../Doc/howto/enum.rst:999
msgid ""
"For standard :class:`Enum` classes the next value chosen is the highest "
"value seen incremented by one."
msgstr ""
"Para las clases :class:`Enum` estándar, el siguiente valor elegido es el "
"valor más alto incrementado en uno."

#: ../Doc/howto/enum.rst:1002
msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two."
msgstr ""
"Para las clases :class:`Flag`, el siguiente valor elegido será la siguiente "
"potencia de dos más alta."

#: ../Doc/howto/enum.rst:1005
msgid ""
"Prior versions would use the last seen value instead of the highest value."
msgstr ""
"Versiones anteriores usarían el último valor visto en lugar del valor más "
"alto."

#: ../Doc/howto/enum.rst:1008
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../Doc/howto/enum.rst:1009
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../Doc/howto/enum.rst:1010
msgid "``_add_alias_``, ``_add_value_alias_``"
msgstr "``_add_alias_``, ``_add_value_alias_``"

#: ../Doc/howto/enum.rst:1012
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Para ayudar a mantener sincronizado el código de Python 2/Python 3, se puede "
"proporcionar un atributo :attr:`_order_`. Se comparará con el orden real de "
"la enumeración y lanzará un error si los dos no coinciden:"

#: ../Doc/howto/enum.rst:1016
msgid ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"
msgstr ""
">>> class Color(Enum):\n"
"...     _order_ = 'RED GREEN BLUE'\n"
"...     RED = 1\n"
"...     BLUE = 3\n"
"...     GREEN = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"...\n"
"TypeError: member order does not match _order_:\n"
"  ['RED', 'BLUE', 'GREEN']\n"
"  ['RED', 'GREEN', 'BLUE']"

#: ../Doc/howto/enum.rst:1030
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"En el código de Python 2, el atributo :attr:`_order_` es necesario ya que el "
"orden de definición se pierde antes de que se pueda registrar."

#: ../Doc/howto/enum.rst:1035
msgid "_Private__names"
msgstr "_Private__names"

#: ../Doc/howto/enum.rst:1037
msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""
":ref:`Private names <private-name-mangling>` no se convierten en miembros de "
"enumeración, sino que siguen siendo atributos normales."

#: ../Doc/howto/enum.rst:1044
msgid "``Enum`` member type"
msgstr "Tipo de miembro ``Enum``"

#: ../Doc/howto/enum.rst:1046
msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In certain situations, such as writing custom enum "
"behavior, being able to access one member directly from another is useful, "
"and is supported; however, in order to avoid name clashes between member "
"names and attributes/methods from mixed-in classes, upper-case names are "
"strongly recommended."
msgstr ""
"Los miembros de una enumeración son instancias de su clase de enumeración y "
"se acceden normalmente como ``EnumClass.member``.  En ciertas situaciones, "
"como al escribir comportamiento personalizado para una enumeración, es útil "
"poder acceder a un miembro directamente desde otro, y esto está soportado; "
"sin embargo, para evitar conflictos de nombres entre los nombres de los "
"miembros y los atributos/métodos de las clases mezcladas, se recomienda "
"encarecidamente utilizar nombres en mayúsculas."

#: ../Doc/howto/enum.rst:1057
msgid "Creating members that are mixed with other data types"
msgstr "Creación de miembros que se mezclan con otros tipos de datos"

#: ../Doc/howto/enum.rst:1059
msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""
"Al crear subclases de otros tipos de datos, como :class:`int` o :class:"
"`str`, con un :class:`Enum`, todos los valores después de ``=`` se pasan al "
"constructor de ese tipo de datos. Por ejemplo::"

#: ../Doc/howto/enum.rst:1063
msgid ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"
msgstr ""
">>> class MyEnum(IntEnum):      # help(int) -> int(x, base=10) -> integer\n"
"...     example = '11', 16      # so x='11' and base=16\n"
"...\n"
">>> MyEnum.example.value        # and hex(11) is...\n"
"17"

#: ../Doc/howto/enum.rst:1071
msgid "Boolean value of ``Enum`` classes and members"
msgstr "Valor booleano de clases y miembros ``Enum``"

#: ../Doc/howto/enum.rst:1073
msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"Las clases de enumeración que se mezclan con tipos que no son :class:`Enum` "
"(como :class:`int`, :class:`str`, etc.) se evalúan de acuerdo con las reglas "
"del tipo combinado; de lo contrario, todos los miembros se evalúan como :"
"data:`True`. Para hacer que la evaluación booleana de su propia enumeración "
"dependa del valor del miembro, agregue lo siguiente a su clase:"

#: ../Doc/howto/enum.rst:1079
msgid ""
"def __bool__(self):\n"
"    return bool(self.value)"
msgstr ""
"def __bool__(self):\n"
"    return bool(self.value)"

#: ../Doc/howto/enum.rst:1082
msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "Las clases simples :class:`Enum` siempre se evalúan como :data:`True`."

#: ../Doc/howto/enum.rst:1086
msgid "``Enum`` classes with methods"
msgstr "Clases ``Enum`` con métodos"

#: ../Doc/howto/enum.rst:1088
msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""
"Si le da a su subclase de enumeración métodos adicionales, como la clase "
"`Planet`_ a continuación, esos métodos aparecerán en un :func:`dir` del "
"miembro, pero no de la clase:"

#: ../Doc/howto/enum.rst:1092
msgid ""
">>> dir(Planet)                         \n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', "
"'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)                   \n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', "
"'surface_gravity', 'value']"
msgstr ""
">>> dir(Planet)\n"
"['EARTH', 'JUPITER', 'MARS', 'MERCURY', 'NEPTUNE', 'SATURN', 'URANUS', "
"'VENUS', '__class__', '__doc__', '__members__', '__module__']\n"
">>> dir(Planet.EARTH)\n"
"['__class__', '__doc__', '__module__', 'mass', 'name', 'radius', "
"'surface_gravity', 'value']"

#: ../Doc/howto/enum.rst:1099
msgid "Combining members of ``Flag``"
msgstr "Combinación de miembros de ``Flag``"

#: ../Doc/howto/enum.rst:1101
msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"La iteración sobre una combinación de miembros :class:`Flag` solo devolverá "
"los miembros que se componen de un solo bit:"

#: ../Doc/howto/enum.rst:1104
msgid ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  # named combination\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # not named combination\n"
"<Color.RED|GREEN|BLUE: 7>"
msgstr ""
">>> class Color(Flag):\n"
"...     RED = auto()\n"
"...     GREEN = auto()\n"
"...     BLUE = auto()\n"
"...     MAGENTA = RED | BLUE\n"
"...     YELLOW = RED | GREEN\n"
"...     CYAN = GREEN | BLUE\n"
"...\n"
">>> Color(3)  #combinación con nombre\n"
"<Color.YELLOW: 3>\n"
">>> Color(7)      # combinación sin nombre\n"
"<Color.RED|GREEN|BLUE: 7>"

#: ../Doc/howto/enum.rst:1119
msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "Minuciosidades ``Flag`` y ``IntFlag``"

#: ../Doc/howto/enum.rst:1121
msgid "Using the following snippet for our examples::"
msgstr "Usando el siguiente fragmento para nuestros ejemplos:"

#: ../Doc/howto/enum.rst:1123
msgid ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."
msgstr ""
">>> class Color(IntFlag):\n"
"...     BLACK = 0\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 4\n"
"...     PURPLE = RED | BLUE\n"
"...     WHITE = RED | GREEN | BLUE\n"
"..."

#: ../Doc/howto/enum.rst:1132
msgid "the following are true:"
msgstr "lo siguiente es cierto:"

#: ../Doc/howto/enum.rst:1134
msgid "single-bit flags are canonical"
msgstr "las banderas de un solo bit son canónicas"

#: ../Doc/howto/enum.rst:1135
msgid "multi-bit and zero-bit flags are aliases"
msgstr "las banderas multibit y zero-bit son alias"

#: ../Doc/howto/enum.rst:1136
msgid "only canonical flags are returned during iteration::"
msgstr "solo se retornan banderas canónicas durante la iteración:"

#: ../Doc/howto/enum.rst:1138
msgid ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color.WHITE)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

#: ../Doc/howto/enum.rst:1141
msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"negar una bandera o un conjunto de banderas retorna una nueva bandera/"
"conjunto de banderas con el valor entero positivo correspondiente:"

#: ../Doc/howto/enum.rst:1144
msgid ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"
msgstr ""
">>> Color.BLUE\n"
"<Color.BLUE: 4>\n"
"\n"
">>> ~Color.BLUE\n"
"<Color.RED|GREEN: 3>"

#: ../Doc/howto/enum.rst:1150
msgid "names of pseudo-flags are constructed from their members' names::"
msgstr ""
"los nombres de las pseudo-banderas se construyen a partir de los nombres de "
"sus miembros:"

#: ../Doc/howto/enum.rst:1152
msgid ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # effectively Perm(0)\n"
"True"
msgstr ""
">>> (Color.RED | Color.GREEN).name\n"
"'RED|GREEN'\n"
"\n"
">>> class Perm(IntFlag):\n"
"...     R = 4\n"
"...     W = 2\n"
"...     X = 1\n"
"...\n"
">>> (Perm.R & Perm.W).name is None  # efectivamente Perm(0)\n"
"True"

#: ../Doc/howto/enum.rst:1163
msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr ""
"las banderas de varios bits, también conocidas como alias, se pueden "
"devolver desde las operaciones:"

#: ../Doc/howto/enum.rst:1165
msgid ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"
msgstr ""
">>> Color.RED | Color.BLUE\n"
"<Color.PURPLE: 5>\n"
"\n"
">>> Color(7)  # or Color(-1)\n"
"<Color.WHITE: 7>\n"
"\n"
">>> Color(0)\n"
"<Color.BLACK: 0>"

#: ../Doc/howto/enum.rst:1174
msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""
"comprobación de pertenencia / contención: las banderas de valor cero siempre "
"se consideran contenidas:"

#: ../Doc/howto/enum.rst:1177
msgid ""
">>> Color.BLACK in Color.WHITE\n"
"True"
msgstr ""
">>> Color.BLACK in Color.WHITE\n"
"True"

#: ../Doc/howto/enum.rst:1180
msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""
"de lo contrario, solo si todos los bits de una bandera están en la otra "
"bandera, se devolverá True:"

#: ../Doc/howto/enum.rst:1183
msgid ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"
msgstr ""
">>> Color.PURPLE in Color.WHITE\n"
"True\n"
"\n"
">>> Color.GREEN in Color.PURPLE\n"
"False"

#: ../Doc/howto/enum.rst:1189
msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Hay un nuevo mecanismo de límite que controla cómo se manejan los bits no "
"válidos/fuera de rango: ``STRICT``, ``CONFORM``, ``EJECT`` y ``KEEP``:"

#: ../Doc/howto/enum.rst:1192
msgid "STRICT --> raises an exception when presented with invalid values"
msgstr "STRICT --> lanza una excepción cuando se presentan valores no válidos"

#: ../Doc/howto/enum.rst:1193
msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> descarta cualquier bit inválido"

#: ../Doc/howto/enum.rst:1194
msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"EJECT -> pierde el estado de la bandera y se convierte en un int normal con "
"el valor dado"

#: ../Doc/howto/enum.rst:1195
msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> mantener los bits adicionales"

#: ../Doc/howto/enum.rst:1197
msgid "keeps Flag status and extra bits"
msgstr "mantiene el estado de la bandera y bits adicionales"

#: ../Doc/howto/enum.rst:1198
msgid "extra bits do not show up in iteration"
msgstr "los bits adicionales no aparecen en la iteración"

#: ../Doc/howto/enum.rst:1199
msgid "extra bits do show up in repr() and str()"
msgstr "bits adicionales aparecen en repr() y str()"

#: ../Doc/howto/enum.rst:1201
msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"El valor predeterminado para Flag es ``STRICT``, el valor predeterminado "
"para ``IntFlag`` es ``EJECT`` y el valor predeterminado para ``_convert_`` "
"es ``KEEP`` (consulte ``ssl.Options`` para ver un ejemplo de cuándo se "
"necesita ``KEEP``)."

#: ../Doc/howto/enum.rst:1209
msgid "How are Enums and Flags different?"
msgstr ""
"¿En qué se diferencian las Enumeraciones (Enums) y las Banderas (Flags)?"

#: ../Doc/howto/enum.rst:1211
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Las enumeraciones tienen una metaclase personalizada que afecta a muchos "
"aspectos de las clases :class:`Enum` derivadas y sus instancias (miembros)."

#: ../Doc/howto/enum.rst:1216
msgid "Enum Classes"
msgstr "Clases de enumeración"

#: ../Doc/howto/enum.rst:1218
msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as ``list(Color)`` or ``some_enum_var in Color``.  :class:"
"`EnumType` is responsible for ensuring that various other methods on the "
"final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""
"La metaclase :class:`EnumType` es responsable de proporcionar :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` y otros métodos que "
"permiten hacer cosas con una clase :class:`Enum` que fallan en una clase "
"típica, como ``list(Color)`` o ``some_enum_var in Color``. :class:`EnumType` "
"es responsable de garantizar que varios otros métodos en la clase :class:"
"`Enum` final sean correctos (como :meth:`__new__`, :meth:`__getnewargs__`, :"
"meth:`__str__` y :meth:`__repr__`)."

#: ../Doc/howto/enum.rst:1227
msgid "Flag Classes"
msgstr "Clases de Banderas"

#: ../Doc/howto/enum.rst:1229
msgid ""
"Flags have an expanded view of aliasing: to be canonical, the value of a "
"flag needs to be a power-of-two value, and not a duplicate name.  So, in "
"addition to the :class:`Enum` definition of alias, a flag with no value (a.k."
"a. ``0``) or with more than one power-of-two value (e.g. ``3``) is "
"considered an alias."
msgstr ""
"Las banderas tienen una vista ampliada de la creación de alias: para ser "
"canónico, el valor de una bandera debe ser un valor de potencia de dos y no "
"un nombre duplicado.  Por lo tanto, además de la definición de alias de :"
"class:`Enum`, una bandera sin valor (también conocida como ``0``) o con más "
"de un valor de potencia de dos (por ejemplo, ``3``) se considera un alias."

#: ../Doc/howto/enum.rst:1235
msgid "Enum Members (aka instances)"
msgstr "Miembros de enumeración (también conocidos como instancias)"

#: ../Doc/howto/enum.rst:1237
msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Lo más interesante de los miembros de la enumeración es que son únicos. :"
"class:`EnumType` los crea a todos mientras crea la propia clase de "
"enumeración, y luego coloca un :meth:`__new__` personalizado para garantizar "
"que nunca se creen instancias nuevas al devolver solo las instancias de "
"miembros existentes."

#: ../Doc/howto/enum.rst:1243
msgid "Flag Members"
msgstr "Miembros de Banderas"

#: ../Doc/howto/enum.rst:1245
msgid ""
"Flag members can be iterated over just like the :class:`Flag` class, and "
"only the canonical members will be returned.  For example::"
msgstr ""
"Los miembros de las Banderas se pueden recorrer de la misma manera que la "
"clase :class:`Flag`, y solo se devolverán los miembros canónicos.  Por "
"ejemplo::"

#: ../Doc/howto/enum.rst:1248
msgid ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"
msgstr ""
">>> list(Color)\n"
"[<Color.RED: 1>, <Color.GREEN: 2>, <Color.BLUE: 4>]"

#: ../Doc/howto/enum.rst:1251
msgid "(Note that ``BLACK``, ``PURPLE``, and ``WHITE`` do not show up.)"
msgstr "(Note que ``BLACK``, ``PURPLE``, y ``WHITE`` no se muestran.)"

#: ../Doc/howto/enum.rst:1253
msgid ""
"Inverting a flag member returns the corresponding positive value, rather "
"than a negative value --- for example::"
msgstr ""
"Invertir un miembro de la bandera devuelve el valor positivo "
"correspondiente, en lugar de un valor negativo --- por ejemplo::"

#: ../Doc/howto/enum.rst:1256
msgid ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"
msgstr ""
">>> ~Color.RED\n"
"<Color.GREEN|BLUE: 6>"

#: ../Doc/howto/enum.rst:1259
msgid ""
"Flag members have a length corresponding to the number of power-of-two "
"values they contain.  For example::"
msgstr ""
"Los miembros de las Banderas tienen una longitud que corresponde al número "
"de valores de potencia de dos que contienen.  Por ejemplo::"

#: ../Doc/howto/enum.rst:1262
msgid ""
">>> len(Color.PURPLE)\n"
"2"
msgstr ""
">>> len(Color.PURPLE)\n"
"2"

#: ../Doc/howto/enum.rst:1269
msgid "Enum Cookbook"
msgstr "Recetario de Enumeraciones"

#: ../Doc/howto/enum.rst:1272
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
"Si bien se espera que :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :"
"class:`Flag` y :class:`IntFlag` cubran la mayoría de los casos de uso, no "
"pueden cubrirlos todos. Aquí hay recetas para algunos tipos diferentes de "
"enumeraciones que se pueden usar directamente o como ejemplos para crear las "
"propias."

#: ../Doc/howto/enum.rst:1279
msgid "Omitting values"
msgstr "Omitir valores"

#: ../Doc/howto/enum.rst:1281
msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""
"En muchos casos de uso, a uno no le importa cuál es el valor real de una "
"enumeración. Hay varias formas de definir este tipo de enumeración simple:"

#: ../Doc/howto/enum.rst:1284
msgid "use instances of :class:`auto` for the value"
msgstr "usar instancias de :class:`auto` para el valor"

#: ../Doc/howto/enum.rst:1285
msgid "use instances of :class:`object` as the value"
msgstr "usar instancias de :class:`object` como valor"

#: ../Doc/howto/enum.rst:1286
msgid "use a descriptive string as the value"
msgstr "use una cadena descriptiva como el valor"

#: ../Doc/howto/enum.rst:1287
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"use una tupla como valor y un :meth:`__new__` personalizado para reemplazar "
"la tupla con un valor :class:`int`"

#: ../Doc/howto/enum.rst:1290
msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"El uso de cualquiera de estos métodos significa para el usuario que estos "
"valores no son importantes y también permite agregar, eliminar o reordenar "
"miembros sin tener que volver a numerar los miembros restantes."

#: ../Doc/howto/enum.rst:1296
msgid "Using :class:`auto`"
msgstr "Usando :class:`auto`"

#: ../Doc/howto/enum.rst:1298
msgid "Using :class:`auto` would look like::"
msgstr "El uso de :class:`auto` se vería así:"

#: ../Doc/howto/enum.rst:1300
msgid ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = auto()\n"
"...     BLUE = auto()\n"
"...     GREEN = auto()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 3>"

#: ../Doc/howto/enum.rst:1310
msgid "Using :class:`object`"
msgstr "Usando :class:`object`"

#: ../Doc/howto/enum.rst:1312
msgid "Using :class:`object` would look like::"
msgstr "El uso de :class:`object` se vería así:"

#: ../Doc/howto/enum.rst:1314
msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN                         \n"
"<Color.GREEN: <object object at 0x...>>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: <object object at 0x...>>"

#: ../Doc/howto/enum.rst:1322
msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`__repr__`::"
msgstr ""
"Este también es un buen ejemplo de por qué es posible que desee escribir su "
"propio :meth:`__repr__`::"

#: ../Doc/howto/enum.rst:1325
#, python-format
msgid ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = object()\n"
"...     GREEN = object()\n"
"...     BLUE = object()\n"
"...     def __repr__(self):\n"
"...         return \"<%s.%s>\" % (self.__class__.__name__, self._name_)\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN>"

#: ../Doc/howto/enum.rst:1338
msgid "Using a descriptive string"
msgstr "Usar una cadena descriptiva"

#: ../Doc/howto/enum.rst:1340
msgid "Using a string as the value would look like::"
msgstr "Usando una cadena como el valor se vería así:"

#: ../Doc/howto/enum.rst:1342
msgid ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"
msgstr ""
">>> class Color(Enum):\n"
"...     RED = 'stop'\n"
"...     GREEN = 'go'\n"
"...     BLUE = 'too fast!'\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 'go'>"

#: ../Doc/howto/enum.rst:1352
msgid "Using a custom :meth:`__new__`"
msgstr "Usando un :meth:`__new__` personalizado"

#: ../Doc/howto/enum.rst:1354
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "El uso de un :meth:`__new__` de numeración automática se vería así:"

#: ../Doc/howto/enum.rst:1356
msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls):\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"...\n"
">>> class Color(AutoNumber):\n"
"...     RED = ()\n"
"...     GREEN = ()\n"
"...     BLUE = ()\n"
"...\n"
">>> Color.GREEN\n"
"<Color.GREEN: 2>"

#: ../Doc/howto/enum.rst:1371
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"Para hacer un ``AutoNumber`` de uso más general, agregue ``*args`` a la "
"firma:"

#: ../Doc/howto/enum.rst:1373
msgid ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # this is the only change from above\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."
msgstr ""
">>> class AutoNumber(Enum):\n"
"...     def __new__(cls, *args):      # éste es el único cambio respecto a "
"lo anterior\n"
"...         value = len(cls.__members__) + 1\n"
"...         obj = object.__new__(cls)\n"
"...         obj._value_ = value\n"
"...         return obj\n"
"..."

#: ../Doc/howto/enum.rst:1381
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"Luego, cuando hereda de ``AutoNumber``, puede escribir su propio "
"``__init__`` para manejar cualquier argumento adicional:"

#: ../Doc/howto/enum.rst:1384
msgid ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # New color, no Pantone code yet!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"
msgstr ""
">>> class Swatch(AutoNumber):\n"
"...     def __init__(self, pantone='unknown'):\n"
"...         self.pantone = pantone\n"
"...     AUBURN = '3497'\n"
"...     SEA_GREEN = '1246'\n"
"...     BLEACHED_CORAL = () # ¡Nuevo color, aún sin código Pantone!\n"
"...\n"
">>> Swatch.SEA_GREEN\n"
"<Swatch.SEA_GREEN: 2>\n"
">>> Swatch.SEA_GREEN.pantone\n"
"'1246'\n"
">>> Swatch.BLEACHED_CORAL.pantone\n"
"'unknown'"

#: ../Doc/howto/enum.rst:1400
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
"El método :meth:`__new__`, si está definido, se usa durante la creación de "
"los miembros de Enum; luego se reemplaza por :meth:`__new__` de Enum, que se "
"usa después de la creación de clases para buscar miembros existentes."

#: ../Doc/howto/enum.rst:1406
msgid ""
"*Do not* call ``super().__new__()``, as the lookup-only ``__new__`` is the "
"one that is found; instead, use the data type directly -- e.g.::"
msgstr ""
"*No* llame a ``super().__new__()``, ya que encontrará el ``__new__`` de solo "
"búsqueda; en su lugar, utilice directamente el tipo de datos -- por ejemplo::"

#: ../Doc/howto/enum.rst:1409
msgid "obj = int.__new__(cls, value)"
msgstr "obj = int.__new__(cls, value)"

#: ../Doc/howto/enum.rst:1413
msgid "OrderedEnum"
msgstr "Enum ordenado"

#: ../Doc/howto/enum.rst:1415
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Una enumeración ordenada que no se basa en :class:`IntEnum` y, por lo tanto, "
"mantiene las invariantes normales de :class:`Enum` (como no ser comparable "
"con otras enumeraciones):"

#: ../Doc/howto/enum.rst:1419
msgid ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"
msgstr ""
">>> class OrderedEnum(Enum):\n"
"...     def __ge__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value >= other.value\n"
"...         return NotImplemented\n"
"...     def __gt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value > other.value\n"
"...         return NotImplemented\n"
"...     def __le__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value <= other.value\n"
"...         return NotImplemented\n"
"...     def __lt__(self, other):\n"
"...         if self.__class__ is other.__class__:\n"
"...             return self.value < other.value\n"
"...         return NotImplemented\n"
"...\n"
">>> class Grade(OrderedEnum):\n"
"...     A = 5\n"
"...     B = 4\n"
"...     C = 3\n"
"...     D = 2\n"
"...     F = 1\n"
"...\n"
">>> Grade.C < Grade.A\n"
"True"

#: ../Doc/howto/enum.rst:1449
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../Doc/howto/enum.rst:1451
msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""
"Lanza un error si se encuentra un nombre de miembro duplicado en lugar de "
"crear un alias::"

#: ../Doc/howto/enum.rst:1454
#, python-format
msgid ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> "
"%r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"
msgstr ""
">>> class DuplicateFreeEnum(Enum):\n"
"...     def __init__(self, *args):\n"
"...         cls = self.__class__\n"
"...         if any(self.value == e.value for e in cls):\n"
"...             a = self.name\n"
"...             e = cls(self.value).name\n"
"...             raise ValueError(\n"
"...                 \"aliases not allowed in DuplicateFreeEnum:  %r --> "
"%r\"\n"
"...                 % (a, e))\n"
"...\n"
">>> class Color(DuplicateFreeEnum):\n"
"...     RED = 1\n"
"...     GREEN = 2\n"
"...     BLUE = 3\n"
"...     GRENE = 2\n"
"...\n"
"Traceback (most recent call last):\n"
"  ...\n"
"ValueError: aliases not allowed in DuplicateFreeEnum:  'GRENE' --> 'GREEN'"

#: ../Doc/howto/enum.rst:1476
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Este es un ejemplo útil para subclasificar Enum para agregar o cambiar otros "
"comportamientos, así como para no permitir alias. Si el único cambio deseado "
"es prohibir los alias, se puede usar el decorador :func:`unique` en su lugar."

#: ../Doc/howto/enum.rst:1482
msgid "MultiValueEnum"
msgstr "MultiValueEnum"

#: ../Doc/howto/enum.rst:1484
msgid "Supports having more than one value per member::"
msgstr "Soporta tener más de un valor por miembro:"

#: ../Doc/howto/enum.rst:1486
msgid ""
">>> class MultiValueEnum(Enum):\n"
"...     def __new__(cls, value, *values):\n"
"...         self = object.__new__(cls)\n"
"...         self._value_ = value\n"
"...         for v in values:\n"
"...             self._add_value_alias_(v)\n"
"...         return self\n"
"...\n"
">>> class DType(MultiValueEnum):\n"
"...     float32 = 'f', 8\n"
"...     double64 = 'd', 9\n"
"...\n"
">>> DType('f')\n"
"<DType.float32: 'f'>\n"
">>> DType(9)\n"
"<DType.double64: 'd'>"
msgstr ""
">>> class MultiValueEnum(Enum):\n"
"...     def __new__(cls, value, *values):\n"
"...         self = object.__new__(cls)\n"
"...         self._value_ = value\n"
"...         for v in values:\n"
"...             self._add_value_alias_(v)\n"
"...         return self\n"
"...\n"
">>> class DType(MultiValueEnum):\n"
"...     float32 = 'f', 8\n"
"...     double64 = 'd', 9\n"
"...\n"
">>> DType('f')\n"
"<DType.float32: 'f'>\n"
">>> DType(9)\n"
"<DType.double64: 'd'>"

#: ../Doc/howto/enum.rst:1505
msgid "Planet"
msgstr "Planeta"

#: ../Doc/howto/enum.rst:1507
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr ""
"Si se define :meth:`__new__` o :meth:`__init__`, el valor del miembro de "
"enumeración se pasará a esos métodos:"

#: ../Doc/howto/enum.rst:1510
msgid ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"
msgstr ""
">>> class Planet(Enum):\n"
"...     MERCURY = (3.303e+23, 2.4397e6)\n"
"...     VENUS   = (4.869e+24, 6.0518e6)\n"
"...     EARTH   = (5.976e+24, 6.37814e6)\n"
"...     MARS    = (6.421e+23, 3.3972e6)\n"
"...     JUPITER = (1.9e+27,   7.1492e7)\n"
"...     SATURN  = (5.688e+26, 6.0268e7)\n"
"...     URANUS  = (8.686e+25, 2.5559e7)\n"
"...     NEPTUNE = (1.024e+26, 2.4746e7)\n"
"...     def __init__(self, mass, radius):\n"
"...         self.mass = mass       # in kilograms\n"
"...         self.radius = radius   # in meters\n"
"...     @property\n"
"...     def surface_gravity(self):\n"
"...         # universal gravitational constant  (m3 kg-1 s-2)\n"
"...         G = 6.67300E-11\n"
"...         return G * self.mass / (self.radius * self.radius)\n"
"...\n"
">>> Planet.EARTH.value\n"
"(5.976e+24, 6378140.0)\n"
">>> Planet.EARTH.surface_gravity\n"
"9.802652743337129"

#: ../Doc/howto/enum.rst:1536
msgid "TimePeriod"
msgstr "Periodo de tiempo"

#: ../Doc/howto/enum.rst:1538
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "Un ejemplo para mostrar el atributo :attr:`_ignore_` en uso:"

#: ../Doc/howto/enum.rst:1540
#, python-format
msgid ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime."
"timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime."
"timedelta(days=366)>]"
msgstr ""
">>> from datetime import timedelta\n"
">>> class Period(timedelta, Enum):\n"
"...     \"different lengths of time\"\n"
"...     _ignore_ = 'Period i'\n"
"...     Period = vars()\n"
"...     for i in range(367):\n"
"...         Period['day_%d' % i] = i\n"
"...\n"
">>> list(Period)[:2]\n"
"[<Period.day_0: datetime.timedelta(0)>, <Period.day_1: datetime."
"timedelta(days=1)>]\n"
">>> list(Period)[-2:]\n"
"[<Period.day_365: datetime.timedelta(days=365)>, <Period.day_366: datetime."
"timedelta(days=366)>]"

#: ../Doc/howto/enum.rst:1557
msgid "Subclassing EnumType"
msgstr "Subclase EnumType"

#: ../Doc/howto/enum.rst:1559
msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"Si bien la mayoría de las necesidades de enumeración se pueden satisfacer "
"mediante la personalización de las subclases :class:`Enum`, ya sea con "
"decoradores de clase o funciones personalizadas, :class:`EnumType` se puede "
"dividir en subclases para proporcionar una experiencia de enumeración "
"diferente."
