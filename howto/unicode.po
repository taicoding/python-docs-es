# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-21 16:38-0300\n"
"PO-Revision-Date: 2021-08-04 20:36+0200\n"
"Last-Translator: Cristi√°n Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es (https://mail.python.org/mailman3/lists/docs-es."
"python.org)\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../Doc/howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "C√ìMO (*HOWTO*) Unicode"

#: ../Doc/howto/unicode.rst
msgid "Release"
msgstr "Lanzamiento"

#: ../Doc/howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../Doc/howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"Este C√ìMO (*HOWTO*) debate el soporte de Python para la especificaci√≥n "
"Unicode para representar datos textuales, y explica varios problemas que "
"com√∫nmente encuentra la gente cuando tratan de trabajar con Unicode."

#: ../Doc/howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "Introducci√≥n a Unicode"

#: ../Doc/howto/unicode.rst:18
msgid "Definitions"
msgstr "Definiciones"

#: ../Doc/howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters.  "
"Applications are often internationalized to display messages and output in a "
"variety of user-selectable languages; the same program might need to output "
"an error message in English, French, Japanese, Hebrew, or Russian.  Web "
"content can be written in any of these languages and can also include a "
"variety of emoji symbols. Python's string type uses the Unicode Standard for "
"representing characters, which lets Python programs work with all these "
"different possible characters."
msgstr ""
"Los programas de hoy necesitan poder manejar una amplia variedad de "
"caracteres. Las aplicaciones son a menudo internacionalizadas para mostrar "
"mensajes y resultados en una variedad de idiomas seleccionables por el "
"usuario; Es posible que el mismo programa necesite generar un mensaje de "
"error en ingl√©s, franc√©s, japon√©s, hebreo o ruso. El contenido web se puede "
"escribir en cualquiera de estos idiomas y tambi√©n puede incluir una variedad "
"de s√≠mbolos *emoji*. El tipo cadena de Python utiliza el est√°ndar Unicode "
"para representar caracteres, lo que permite a los programas de Python "
"trabajar con todos estos caracteres posibles diferentes."

#: ../Doc/howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and updated "
"to add new languages and symbols."
msgstr ""
"Unicode (https://www.unicode.org/) es una especificaci√≥n que apunta a listar "
"cada car√°cter usado por lenguajes humanos y darle a cada car√°cter su propio "
"c√≥digo √∫nico. La especificaci√≥n Unicode es continuamente revisada y "
"actualizada para a√±adir nuevos lenguajes y s√≠mbolos."

#: ../Doc/howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are '√à' and '√ç'.  Characters "
"vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", '‚Ö†', that's separate "
"from the uppercase letter 'I'.  They'll usually look the same, but these are "
"two different characters that have different meanings."
msgstr ""
"Un **car√°cter** es el componente mas peque√±o posible de un texto.  'A', 'B', "
"'C', etc., son todos diferentes caracteres. Tambi√©n lo son *'√à'* e *'√ç'*. "
"Los caracteres var√≠an dependiendo del lenguaje o del contexto en el que "
"est√°s hablando. Por ejemplo, Existe un car√°cter para el \"N√∫mero Uno "
"Romano\",  'I', que es distinto de la letra 'I' may√∫scula. Estos usualmente "
"lucen igual, pero son dos caracteres diferentes que tienen distintos "
"significados."

#: ../Doc/howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned <https://www.unicode."
"org/versions/latest/#Summary>`_ is less than that). In the standard and in "
"this document, a code point is written using the notation ``U+265E`` to mean "
"the character with value ``0x265e`` (9,822 in decimal)."
msgstr ""
"El est√°ndar Unicode describe c√≥mo se representan los caracteres mediante "
"**puntos de c√≥digo**. Un valor de punto de c√≥digo es un n√∫mero entero en el "
"rango de 0 a 0x10FFFF (aproximadamente 1.1 millones de valores, el `n√∫mero "
"real asignado <https://www.unicode.org/versions/latest/#Summary>`_ es menor "
"que eso). En el est√°ndar y en este documento, un punto de c√≥digo se escribe "
"usando la notaci√≥n ``U+265E`` para significar el car√°cter con valor "
"``0x265e`` (9,822 en decimal)."

#: ../Doc/howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and their "
"corresponding code points:"
msgstr ""
"El est√°ndar Unicode contiene muchas tablas que enumeran caracteres y sus "
"puntos de c√≥digo correspondientes:"

#: ../Doc/howto/unicode.rst:53
msgid ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    '‚Öß'; ROMAN NUMERAL EIGHT\n"
"2168    '‚Ö®'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    '‚ôû'; BLACK CHESS KNIGHT\n"
"265F    '‚ôü'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'üòÄ'; GRINNING FACE\n"
"1F609   'üòâ'; WINKING FACE\n"
"..."
msgstr ""

#: ../Doc/howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some "
"particular character; in this case, it represents the character 'BLACK CHESS "
"KNIGHT', '‚ôû'.  In informal contexts, this distinction between code points "
"and characters will sometimes be forgotten."
msgstr ""
"Estrictamente, estas definiciones implican que no tiene sentido decir 'este "
"es el car√°cter ``U+265E``. ``U+265E`` es un punto de c√≥digo, que representa "
"alg√∫n car√°cter en particular; en este caso, representa el car√°cter "
"'CABALLERO AJEDREZ NEGRO', '‚ôû'. En contextos informales, esta distinci√≥n "
"entre puntos de c√≥digo y caracteres a veces se olvidar√°."

#: ../Doc/howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the exact "
"details will depend on the font being used.  Most Python code doesn't need "
"to worry about glyphs; figuring out the correct glyph to display is "
"generally the job of a GUI toolkit or a terminal's font renderer."
msgstr ""
"Un car√°cter es representado en una pantalla o en papel por un conjunto de "
"elementos gr√°ficos llamado **glifo**. El glifo para una A may√∫scula, por "
"ejemplo, es dos trazos diagonales y uno horizontal, aunque los detalles "
"exactos van a depender de la fuente utilizada. La mayor√≠a del c√≥digo de "
"Python no necesita preocuparse por los glifos; averiguar el glifo correcto "
"para mostrar es generalmente el trabajo de un kit de herramientas GUI o el "
"renderizador de fuentes de una terminal."

#: ../Doc/howto/unicode.rst:87
msgid "Encodings"
msgstr "Codificaciones"

#: ../Doc/howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code "
"points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 decimal).  "
"This sequence of code points needs to be represented in memory as a set of "
"**code units**, and **code units** are then mapped to 8-bit bytes.  The "
"rules for translating a Unicode string into a sequence of bytes are called a "
"**character encoding**, or just an **encoding**."
msgstr ""
"Para resumir la secci√≥n anterior: Una cadena Unicode es una secuencia de "
"c√≥digo de posiciones que son n√∫meros desde 0 hasta ``0x10FFFF`` (1114111 "
"decimal). Esta secuencia de c√≥digo de posiciones necesita ser representada "
"en memoria como un conjunto de **unidades de c√≥digo**,  y las **unidades de "
"c√≥digo** son mapeadas a bytes de 8 bits. Las reglas para traducir una cadena "
"Unicode a una secuencia de bytes son llamadas **Codificaci√≥n de car√°cter**, "
"o s√≥lo una **codificaci√≥n**."

#: ../Doc/howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the code "
"unit, and then using the CPU's representation of 32-bit integers. In this "
"representation, the string \"Python\" might look like this:"
msgstr ""
"La primera codificaci√≥n en que podr√≠as pensar es usar enteros de 32 bits "
"como unidad de c√≥digo, y luego usar la representaci√≥n de la CPU de enteros "
"de 32 bits. En esta representaci√≥n, la cadena \"Python\" podr√≠a verse as√≠:"

#: ../Doc/howto/unicode.rst:101
msgid ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
msgstr ""

#: ../Doc/howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr ""
"Esta representaci√≥n es sencilla pero utilizarla presenta una serie de "
"problemas."

#: ../Doc/howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr ""
"No es portable; diferentes procesadores ordenan los bytes de manera "
"diferente."

#: ../Doc/howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code points "
"are less than 127, or less than 255, so a lot of space is occupied by "
"``0x00`` bytes.  The above string takes 24 bytes compared to the 6 bytes "
"needed for an ASCII representation.  Increased RAM usage doesn't matter too "
"much (desktop computers have gigabytes of RAM, and strings aren't usually "
"that large), but expanding our usage of disk and network bandwidth by a "
"factor of 4 is intolerable."
msgstr ""
"Es un desperdicio de espacio. En la mayor√≠a de los textos, la mayor√≠a de los "
"c√≥digos de posici√≥n son menos de 127, o menos de 255, por lo que una gran "
"cantidad de espacio est√° ocupado por bytes ``0x00``. La cadena anterior toma "
"24 bytes en comparaci√≥n con los 6 bytes necesarios para una representaci√≥n "
"ASCII. El aumento en el uso de RAM no importa demasiado (las computadoras de "
"escritorio tienen *gigabytes* de RAM, y las cadenas no suelen ser tan "
"grandes), pero expandir nuestro uso del disco y el ancho de banda de la red "
"en un factor de 4 es intolerable."

#: ../Doc/howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a new "
"family of wide string functions would need to be used."
msgstr ""
"No es compatible con funciones existentes en C como ``strlen()``, para eso "
"se necesitar√≠a una nueva familia de funciones de cadenas."

#: ../Doc/howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""
"Por lo tanto esta codificaci√≥n no es muy utilizada, y la gente prefiere "
"elegir codificaciones que son mas eficientes y convenientes, como UTF-8."

#: ../Doc/howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often defaults "
"to using it.  UTF stands for \"Unicode Transformation Format\", and the '8' "
"means that 8-bit values are used in the encoding.  (There are also UTF-16 "
"and UTF-32 encodings, but they are less frequently used than UTF-8.)  UTF-8 "
"uses the following rules:"
msgstr ""
"UTF-8 es una de las codificaciones mas utilizadas, y Python generalmente la "
"usa de forma predeterminada. UTF significa *\"Unicode Transformation "
"Format\"*, y el \"8\" significa que se utilizan valores de 8 bits en la "
"codificaci√≥n. (Tambi√©n hay codificaciones UTF-16 y UTF-32, pero son menos "
"frecuentes que UTF-8.) UTF-8 usa las siguientes reglas:"

#: ../Doc/howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte value."
msgstr ""
"Si el c√≥digo de posici√≥n is < 128, es representado por el valor de byte "
"correspondiente."

#: ../Doc/howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, or "
"four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"Si el c√≥digo de posici√≥n es >= 128, se transforma en una secuencia de dos, "
"tres, o cuatro bytes, donde cada byte de la secuencia est√° entre 128 y 255."

#: ../Doc/howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8 tiene varias propiedades convenientes:"

#: ../Doc/howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "Puede manejar cualquier punto de c√≥digo Unicode."

#: ../Doc/howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains embedded "
"zero bytes only where they represent the null character (U+0000). This means "
"that UTF-8 strings can be processed by C functions such as ``strcpy()`` and "
"sent through protocols that can't handle zero bytes for anything other than "
"end-of-string markers."
msgstr ""
"Una cadena Unicode se convierte en una secuencia de bytes que contiene cero "
"bytes incrustados solo donde representan el car√°cter nulo (U+0000). Esto "
"significa que las cadenas UTF-8 pueden ser procesadas por funciones C como "
"``strcpy()`` y enviadas a trav√©s de protocolos que no pueden manejar cero "
"bytes para nada m√°s que marcadores de fin de cadena de caracteres."

#: ../Doc/howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "Una cadena de texto ASCII es tambi√©n texto UTF-8."

#: ../Doc/howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr ""
"UTF-8 es bastante compacto; La mayor√≠a de los caracteres com√∫nmente usados "
"pueden ser representados con uno o dos bytes."

#: ../Doc/howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of the "
"next UTF-8-encoded code point and resynchronize.  It's also unlikely that "
"random 8-bit data will look like valid UTF-8."
msgstr ""
"Si los bytes est√°n corruptos o perdidos, es posible determinar el comienzo "
"del pr√≥ximo c√≥digo de posici√≥n y re-sincronizar. Tambi√©n es poco probable "
"que datos aleatorios de 8 bit se vean como UTF-8 v√°lido."

#: ../Doc/howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. This "
"avoids the byte-ordering issues that can occur with integer and word "
"oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8 es una codificaci√≥n orientada a bytes. La codificaci√≥n especifica que "
"cada car√°cter est√° representado por una secuencia espec√≠fica de uno o m√°s "
"bytes. Esto evita los problemas de ordenamiento de bytes que pueden ocurrir "
"con codificaciones orientadas a n√∫meros enteros y palabras, como UTF-16 y "
"UTF-32, donde la secuencia de bytes var√≠a seg√∫n el hardware en el que se "
"codific√≥ la cadena."

#: ../Doc/howto/unicode.rst:158 ../Doc/howto/unicode.rst:514
#: ../Doc/howto/unicode.rst:735
msgid "References"
msgstr "Referencias"

#: ../Doc/howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology <https://www.unicode.org/"
"history/>`_ of the origin and development of Unicode is also available on "
"the site."
msgstr ""
"El `sitio del Consorcio Unicode <https://www.unicode.org>`_ tiene gr√°ficos "
"de caracteres, un glosario y versiones en PDF de la especificaci√≥n Unicode. "
"Est√© preparado para una lectura dif√≠cil. `Una cronolog√≠a <https://www."
"unicode.org/history/>`_ del origen y desarrollo de Unicode tambi√©n est√° "
"disponible en el sitio."

#: ../Doc/howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutes 36 seconds)."
msgstr ""
"En el canal de *Youtube* *Computerphile*, *Tom Scott* `discute brevemente la "
"historia de Unicode y UTF-8 <https://www.youtube.com/watch?v=MijmeoH9LT4>`_ "
"(9 minutos 36 segundos)."

#: ../Doc/howto/unicode.rst:169
#, fuzzy
msgid ""
"To help understand the standard, Jukka Korpela has written `an introductory "
"guide <https://jkorpela.fi/unicode/guide.html>`_ to reading the Unicode "
"character tables."
msgstr ""
"Para ayudar a entender el est√°ndar, *Jukka Korpela* escribi√≥ `una gu√≠a "
"introductoria <http://jkorpela.fi/unicode/guide.html>`_ para leer tablas de "
"caracteres Unicode."

#: ../Doc/howto/unicode.rst:173
msgid ""
"Another `good introductory article <https://www.joelonsoftware."
"com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-"
"positively-must-know-about-unicode-and-character-sets-no-excuses/>`_ was "
"written by Joel Spolsky. If this introduction didn't make things clear to "
"you, you should try reading this alternate article before continuing."
msgstr ""
"Otro `buen articulo introductorio <https://www.joelonsoftware.com/2003/10/08/"
"the-absolute-minimum-every-software-developer-absolutely-positively-must-"
"know-about-unicode-and-character-sets-no-excuses/>`_ fue escrito por *Joel "
"Spolsky*. Si esta introducci√≥n no aclara las cosas para usted, deber√≠a "
"tratar leyendo este articulo alternativo antes de continuar."

#: ../Doc/howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"Art√≠culos de *Wikipedia* son a menudo √∫tiles. Mire los art√≠culos para "
"\"`codificaci√≥n de caracteres <https://es.wikipedia.org/wiki/"
"Codificaci%C3%B3n_de_caracteres>`_\" y `UTF-8 <https://es.wikipedia.org/wiki/"
"UTF-8>`_, por ejemplo."

#: ../Doc/howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "Soporte Unicode de Python"

#: ../Doc/howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's "
"Unicode features."
msgstr ""
"Ahora que ya ha aprendido los rudimentos de Unicode, podemos mirar las "
"caracter√≠sticas de Unicode de Python."

#: ../Doc/howto/unicode.rst:190
msgid "The String Type"
msgstr "El tipo cadena"

#: ../Doc/howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"Desde Python 3.0, el tipo :class:`str` del lenguaje contiene caracteres "
"Unicode, lo que significa que cualquier cadena creada usando ``\"unicode "
"rocks!\"``, ``'unicode rocks!'``, o la sintaxis de cadena entre comillas "
"triples es almacenado como Unicode."

#: ../Doc/howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr ""
"La codificaci√≥n predeterminada para el c√≥digo fuente de Python es UTF-8, por "
"lo que simplemente puede incluir un car√°cter Unicode en un literal de cadena "
"de caracteres::"

#: ../Doc/howto/unicode.rst:199
msgid ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouv√©\")"
msgstr ""

#: ../Doc/howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in identifiers::"
msgstr ""
"Nota al margen: Python 3 tambi√©n soporta el uso de caracteres Unicode en "
"identificadores::"

#: ../Doc/howto/unicode.rst:208
msgid ""
"r√©pertoire = \"/tmp/records.log\"\n"
"with open(r√©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"
msgstr ""

#: ../Doc/howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep the "
"source code ASCII-only for some reason, you can also use escape sequences in "
"string literals. (Depending on your system, you may see the actual capital-"
"delta glyph instead of a \\u escape.) ::"
msgstr ""
"Si no puede ingresar un car√°cter en particular en su editor o desea mantener "
"el c√≥digo fuente solo ASCII por alguna raz√≥n, tambi√©n puede usar secuencias "
"de escape en cadenas de caracteres literales. (Dependiendo de su sistema, es "
"posible que vea el glifo delta de may√∫sculas en lugar de un escape \\u)::"

#: ../Doc/howto/unicode.rst:217
msgid ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"
msgstr ""

#: ../Doc/howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` method "
"of :class:`bytes`.  This method takes an *encoding* argument, such as "
"``UTF-8``, and optionally an *errors* argument."
msgstr ""
"Adem√°s, uno puede crear una cadena usando el m√©todo :func:`~bytes.decode` de "
"la clase :class:`bytes`. Este m√©todo recibe una *codificaci√≥n* como "
"argumento, como ``UTF-8``, y opcionalmente un argumento *errores*."

#: ../Doc/howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't be "
"converted according to the encoding's rules.  Legal values for this argument "
"are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The following "
"examples show the differences::"
msgstr ""
"El argumento *errores* especifica la respuesta cuando la cadena ingresada no "
"puede ser convertida de acuerdo a las reglas de codificaci√≥n. Los posibles "
"valores para este argumento son ``'strict'`` (levanta una excepci√≥n :exc:"
"`UnicodeDecodeError`), ``'replace'`` (use ``U+FFFD``, ``CARACTER DE "
"REEMPLAZO``), ``'ignore'`` (solo deje el car√°cter fuera del resultado "
"Unicode), o ``'backslahsreplace'`` (inserta una secuencia de escape "
"``\\xNN``). Los siguientes ejemplos muestran las diferencias ::"

#: ../Doc/howto/unicode.rst:236
msgid ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")  \n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"
msgstr ""

#: ../Doc/howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  Python "
"comes with roughly 100 different encodings; see the Python Library Reference "
"at :ref:`standard-encodings` for a list.  Some encodings have multiple "
"names; for example, ``'latin-1'``, ``'iso_8859_1'`` and ``'8859``' are all "
"synonyms for the same encoding."
msgstr ""
"Las codificaciones son especificadas como cadenas que contienen el nombre de "
"la codificaci√≥n. Python viene con cerca de 100 codificaciones diferentes; "
"consulta la referencia de la biblioteca de Python en :ref:`standard-"
"encodings` para una lista. Algunas codificaciones tienen m√∫ltiples nombres; "
"por ejemplo, ``'latin-1'``, ``'iso_8859_1'`` y ``'8859``' son sin√≥nimos para "
"la misma codificaci√≥n."

#: ../Doc/howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` built-"
"in function, which takes integers and returns a Unicode string of length 1 "
"that contains the corresponding code point.  The reverse operation is the "
"built-in :func:`ord` function that takes a one-character Unicode string and "
"returns the code point value::"
msgstr ""
"Las cadenas de un solo car√°cter pueden ser creadas tambi√©n con la funci√≥n "
"incorporada :func:`chr`, que toma un entero y retorna una cadena Unicode de "
"longitud 1 que contiene el correspondiente c√≥digo de posici√≥n. La operaci√≥n "
"inversa es la funci√≥n incorporada :func:`ord` que toma una cadena Unicode de "
"un car√°cter y retorna el c√≥digo de posici√≥n::"

#: ../Doc/howto/unicode.rst:260
msgid ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"
msgstr ""

#: ../Doc/howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "Convirtiendo a Bytes"

#: ../Doc/howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in "
"the requested *encoding*."
msgstr ""
"El m√©todo opuesto a :meth:`bytes.decode` es :meth:`str.encode`, que retorna "
"una representaci√≥n de :class:`bytes` de la cadena Unicode, codificada en la "
"codificaci√≥n solicitada."

#: ../Doc/howto/unicode.rst:272
msgid ""
"The *errors* parameter is the same as the parameter of the :meth:`~bytes."
"decode` method but supports a few more possible handlers. As well as "
"``'strict'``, ``'ignore'``, and ``'replace'`` (which in this case inserts a "
"question mark instead of the unencodable character), there is also "
"``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"El par√°metro *errores* es el mismo que el par√°metro del m√©todo :meth:`~bytes."
"decode` pero soporta algunos manejadores mas."

#: ../Doc/howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "El siguiente ejemplo muestra los diferentes resultados::"

#: ../Doc/howto/unicode.rst:282
msgid ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')  \n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"
msgstr ""

#: ../Doc/howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available encodings "
"are found in the :mod:`codecs` module.  Implementing new encodings also "
"requires understanding the :mod:`codecs` module. However, the encoding and "
"decoding functions returned by this module are usually more low-level than "
"is comfortable, and writing new encodings is a specialized task, so the "
"module won't be covered in this HOWTO."
msgstr ""
"Las rutinas de bajo nivel para registrar y acceder a las codificaciones "
"disponibles se encuentran en el m√≥dulo :mod:`codecs`. La implementaci√≥n de "
"nuevas codificaciones tambi√©n requiere comprender el m√≥dulo :mod:`codecs`. "
"Sin embargo, las funciones de codificaci√≥n y decodificaci√≥n retornadas por "
"este m√≥dulo generalmente son de nivel m√°s bajo de lo que es c√≥modo, y "
"escribir nuevas codificaciones es una tarea especializada, por lo que el "
"m√≥dulo no se cubrir√° en este C√ìMO."

#: ../Doc/howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "Literales Unicode en c√≥digo fuente Python"

#: ../Doc/howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using the "
"``\\u`` escape sequence, which is followed by four hex digits giving the "
"code point.  The ``\\U`` escape sequence is similar, but expects eight hex "
"digits, not four::"
msgstr ""
"En el c√≥digo fuente de Python, se pueden escribir puntos de c√≥digo Unicode "
"espec√≠ficos utilizando la secuencia de escape ``\\u``, que es seguida por "
"cuatro d√≠gitos hexadecimales que dan el punto de c√≥digo. La secuencia de "
"escape ``\\U`` es similar, pero espera ocho d√≠gitos hexadecimales, no "
"cuatro::"

#: ../Doc/howto/unicode.rst:317
msgid ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"
msgstr ""

#: ../Doc/howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters, as "
"you would in a program with messages in French or some other accent-using "
"language.  You can also assemble strings using the :func:`chr` built-in "
"function, but this is even more tedious."
msgstr ""
"El uso de secuencias de escape para puntos de c√≥digo superiores a 127 est√° "
"bien en peque√±as dosis, pero se convierte en una molestia si est√° utilizando "
"muchos caracteres acentuados, como lo har√≠a en un programa con mensajes en "
"franc√©s o alg√∫n otro lenguaje que utilice acento. Tambi√©n puede ensamblar "
"cadenas usando la funci√≥n incorporada :func:`chr`, pero esto es a√∫n m√°s "
"tedioso."

#: ../Doc/howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's natural "
"encoding.  You could then edit Python source code with your favorite editor "
"which would display the accented characters naturally, and have the right "
"characters used at runtime."
msgstr ""
"Idealmente, desear√≠a poder escribir literales en la codificaci√≥n natural de "
"su idioma. Luego, puede editar el c√≥digo fuente de Python con su editor "
"favorito, que mostrar√° los caracteres acentuados de forma natural y tendr√° "
"los caracteres correctos utilizados en tiempo de ejecuci√≥n."

#: ../Doc/howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done by "
"including a special comment as either the first or second line of the source "
"file::"
msgstr ""
"Python soporta la escritura de c√≥digo fuente en UTF-8 de forma "
"predeterminada, pero puede usar casi cualquier codificaci√≥n si declara la "
"codificaci√≥n que est√° utilizando. Esto se hace mediante la inclusi√≥n de un "
"comentario especial en la primera o segunda l√≠nea del archivo fuente::"

#: ../Doc/howto/unicode.rst:339
msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcd√©'\n"
"print(ord(u[-1]))"
msgstr ""

#: ../Doc/howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local to "
"a file.  Emacs supports many different variables, but Python only supports "
"'coding'.  The ``-*-`` symbols indicate to Emacs that the comment is "
"special; they have no significance to Python but are a convention.  Python "
"looks for ``coding: name`` or ``coding=name`` in the comment."
msgstr ""
"La sintaxis est√° inspirada en la notaci√≥n de Emacs para especificar "
"variables locales a un archivo. Emacs admite muchas variables diferentes, "
"pero Python solo admite *'coding'*. Los s√≠mbolos ``- * -`` indican a Emacs "
"que el comentario es especial; no tienen importancia para Python pero son "
"una convenci√≥n. Python busca ``coding: name`` o ``coding=name`` en el "
"comentario."

#: ../Doc/howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be UTF-8 "
"as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"Si no incluye dicho comentario, la codificaci√≥n predeterminada utilizada "
"ser√° UTF-8 como ya se mencion√≥. Ver tambi√©n :pep:`263` para m√°s informaci√≥n."

#: ../Doc/howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "Propiedades Unicode"

#: ../Doc/howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also display-"
"related properties, such as how to use the code point in bidirectional text."
msgstr ""
"La especificaci√≥n Unicode incluye una base de datos de informaci√≥n sobre "
"puntos de c√≥digo. Para cada punto de c√≥digo definido, la informaci√≥n incluye "
"el nombre del car√°cter, su categor√≠a, el valor num√©rico si corresponde (para "
"caracteres que representan conceptos num√©ricos como los n√∫meros romanos, "
"fracciones como un tercio y cuatro quintos, etc.). Tambi√©n hay propiedades "
"relacionadas con la visualizaci√≥n, como c√≥mo usar el punto de c√≥digo en "
"texto bidireccional."

#: ../Doc/howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters, "
"and prints the numeric value of one particular character::"
msgstr ""
"El siguiente programa muestra informaci√≥n sobre varios caracteres e imprime "
"el valor num√©rico de un car√°cter en particular::"

#: ../Doc/howto/unicode.rst:369
#, python-format
msgid ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"
msgstr ""

#: ../Doc/howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "Cuando se ejecuta, este imprime:"

#: ../Doc/howto/unicode.rst:382
msgid ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"
msgstr ""

#: ../Doc/howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the character. "
"These are grouped into categories such as \"Letter\", \"Number\", "
"\"Punctuation\", or \"Symbol\", which in turn are broken up into "
"subcategories.  To take the codes from the above output, ``'Ll'`` means "
"'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is \"Mark, "
"nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the General Category "
"Values section of the Unicode Character Database documentation <https://www."
"unicode.org/reports/tr44/#General_Category_Values>`_ for a list of category "
"codes."
msgstr ""
"Los c√≥digos de categor√≠a son abreviaturas que describen la naturaleza del "
"personaje. Estos se agrupan en categor√≠as como \"Letra\", \"N√∫mero\", "
"\"Puntuaci√≥n\" o \"S√≠mbolo\", que a su vez se dividen en subcategor√≠as. Para "
"tomar los c√≥digos de la salida anterior, ``'Ll'`` significa 'Letra, "
"min√∫scula ', ``'No'`` significa \"N√∫mero, otro\", ``'Mn'`` es \"Marca, sin "
"espacios\" , y ``'So'`` es \"S√≠mbolo, otro\". Consulte `la secci√≥n Valores "
"de categor√≠a generales de la documentaci√≥n de la base de datos de caracteres "
"Unicode <https://www.unicode.org/reports/tr44/#General_Category_Values>`_ "
"para obtener una lista de c√≥digos de categor√≠a."

#: ../Doc/howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "Comparando cadenas"

#: ../Doc/howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set of "
"characters can be represented by different sequences of code points.  For "
"example, a letter like '√™' can be represented as a single code point U+00EA, "
"or as U+0065 U+0302, which is the code point for 'e' followed by a code "
"point for 'COMBINING CIRCUMFLEX ACCENT'.  These will produce the same output "
"when printed, but one is a string of length 1 and the other is of length 2."
msgstr ""
"Unicode agrega algunas complicaciones a la comparaci√≥n de cadenas, porque el "
"mismo conjunto de caracteres puede representarse mediante diferentes "
"secuencias de puntos de c√≥digo. Por ejemplo, una letra como '√™' puede "
"representarse como un √∫nico punto de c√≥digo U+00EA, o como U+0065 U+0302, "
"que es el punto de c√≥digo para 'e' seguido de un punto de c√≥digo para "
"'COMBINING CIRCUMFLEX ACCENT' . Estos producir√°n la misma salida cuando se "
"impriman, pero uno es una cadena de longitud 1 y el otro es de longitud 2."

#: ../Doc/howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following an "
"algorithm described by the Unicode Standard.  This algorithm has special "
"handling for characters such as the German letter '√ü' (code point U+00DF), "
"which becomes the pair of lowercase letters 'ss'."
msgstr ""
"Una herramienta para una comparaci√≥n que no distingue entre may√∫sculas y "
"min√∫sculas es el m√©todo :meth:`~str.casefold` que convierte una cadena en "
"una forma que no distingue entre may√∫sculas y min√∫sculas siguiendo un "
"algoritmo descrito por el est√°ndar Unicode. Este algoritmo tiene un manejo "
"especial para caracteres como la letra Alemana '√ü' (punto de c√≥digo U+00DF), "
"que se convierte en el par de letras min√∫sculas 'ss'."

#: ../Doc/howto/unicode.rst:421
msgid ""
">>> street = 'G√ºrzenichstra√üe'\n"
">>> street.casefold()\n"
"'g√ºrzenichstrasse'"
msgstr ""

#: ../Doc/howto/unicode.rst:425
#, fuzzy
msgid ""
"A second tool is the :mod:`unicodedata` module's :func:`~unicodedata."
"normalize` function that converts strings to one of several normal forms, "
"where letters followed by a combining character are replaced with single "
"characters.  :func:`~unicodedata.normalize` can be used to perform string "
"comparisons that won't falsely report inequality if two strings use "
"combining characters differently:"
msgstr ""
"Una segunda herramienta es la funci√≥n :func:`~unicodedata.normalize` del "
"m√≥dulo :mod:`unicodedata` que convierte las cadenas en una de varias formas "
"normales, donde las letras seguidas de un car√°cter de combinaci√≥n se "
"reemplazan con caracteres individuales. :func:`normalize` puede usarse para "
"realizar comparaciones de cadenas que no informar√°n falsamente la "
"desigualdad si dos cadenas usan caracteres combinados de manera diferente:"

#: ../Doc/howto/unicode.rst:434
msgid ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"
msgstr ""

#: ../Doc/howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "Cuando se ejecuta, esto genera:"

#: ../Doc/howto/unicode.rst:450
msgid ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"
msgstr ""

#: ../Doc/howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
"El primer argumento para la funci√≥n :func:`~unicodedata.normalize` es una "
"cadena que proporciona la forma de normalizaci√≥n deseada, que puede ser una "
"de 'NFC', 'NFKC', 'NFD' y 'NFKD'."

#: ../Doc/howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr ""
"El est√°ndar Unicode tambi√©n especifica c√≥mo hacer comparaciones sin "
"may√∫sculas y min√∫sculas::"

#: ../Doc/howto/unicode.rst:463
msgid ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = '√™'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"
msgstr ""

#: ../Doc/howto/unicode.rst:477
#, fuzzy
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See section "
"3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"Esto imprimir√° ``Verdadero``. (¬øPor qu√© se invoca dos veces :func:`NFD`? "
"Debido a que hay algunos caracteres que hacen que :meth:`casefold` retorne "
"una cadena no normalizada, por lo que el resultado debe normalizarse "
"nuevamente. Consulte la secci√≥n 3.13 del Est√°ndar Unicode para una discusi√≥n "
"y un ejemplo.)"

#: ../Doc/howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "Expresiones regulares Unicode"

#: ../Doc/howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided "
"either as bytes or strings.  Some of the special character sequences such as "
"``\\d`` and ``\\w`` have different meanings depending on whether the pattern "
"is supplied as bytes or a string.  For example, ``\\d`` will match the "
"characters ``[0-9]`` in bytes but in strings will match any character that's "
"in the ``'Nd'`` category."
msgstr ""
"Las expresiones regulares soportadas por el m√≥dulo :mod:`re` se pueden "
"proporcionar como bytes o cadenas. Algunas de las secuencias de caracteres "
"especiales como ``\\d`` y ``\\w`` tienen diferentes significados dependiendo "
"de si el patr√≥n se suministra como bytes o una cadena. Por ejemplo, ``\\d`` "
"coincidir√° con los caracteres ``[0-9]`` en bytes, pero en las cadenas "
"coincidir√° con cualquier car√°cter que est√© en la categor√≠a ``'Nd'``."

#: ../Doc/howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and Arabic "
"numerals::"
msgstr ""
"La cadena en este ejemplo tiene el n√∫mero 57 escrito en n√∫meros tailandeses "
"y √°rabes::"

#: ../Doc/howto/unicode.rst:496
msgid ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"
msgstr ""

#: ../Doc/howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out.  If "
"you supply the :const:`re.ASCII` flag to :func:`~re.compile`, ``\\d+`` will "
"match the substring \"57\" instead."
msgstr ""
"Cuando se ejecuta, ``\\d+`` coincidir√° con los n√∫meros tailandeses y los "
"imprimir√°. Si proporciona el indicador :const:`re.ASCII` a :func:`~re."
"compile`, ``\\d+`` coincidir√° con la subcadena \"57\" en su lugar."

#: ../Doc/howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and ``\\s`` "
"will match either Unicode whitespace characters or ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Del mismo modo, ``\\w`` coincide con una amplia variedad de caracteres "
"Unicode pero solo ``[a-zA-Z0-9_]`` en bytes o si :const:`re.ASCII` se "
"suministra, y ``\\s`` coincidir√° con los caracteres de espacio en blanco "
"Unicode o ``[ \\t\\n\\r\\f\\v]``."

#: ../Doc/howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr ""
"Algunas buenas discusiones alternativas sobre el soporte Unicode de Python "
"son:"

#: ../Doc/howto/unicode.rst:520
#, fuzzy
msgid ""
"`Processing Text Files in Python 3 <https://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, by Nick Coghlan."
msgstr ""
"`Processing Text Files in Python 3 <http://python-notes.curiousefficiency."
"org/en/latest/python3/text_file_processing.html>`_, por *Nick Coghlan*."

#: ../Doc/howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a PyCon "
"2012 presentation by Ned Batchelder."
msgstr ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, una "
"presentaci√≥n de *Ned Batchelder* en PyCon 2012."

#: ../Doc/howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at :ref:"
"`textseq`."
msgstr ""
"El tipo :class:`str` se describe en la referencia de la biblioteca de Python "
"en :ref:`textseq`."

#: ../Doc/howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr "La documentaci√≥n para el m√≥dulo :mod:`unicodedata`."

#: ../Doc/howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr "La documentaci√≥n para el m√≥dulo :mod:`codecs`."

#: ../Doc/howto/unicode.rst:530
msgid ""
"Marc-Andr√© Lemburg gave `a presentation titled \"Python and Unicode\" (PDF "
"slides) <https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>`_ at "
"EuroPython 2002.  The slides are an excellent overview of the design of "
"Python 2's Unicode features (where the Unicode string type is called "
"``unicode`` and literals start with ``u``)."
msgstr ""
"*Marc-Andr√© Lemburg* hizo `una presentaci√≥n titulada \"Python and Unicode\" "
"(diapositivas en PDF) <https://downloads.egenix.com/python/Unicode-EPC2002-"
"Talk.pdf>`_ en EuroPython 2002. Las diapositivas son una excelente "
"descripci√≥n general del dise√±o de las caracter√≠sticas Unicode de Python 2 "
"(donde el tipo de cadena Unicode se llama ``unicode`` y los literales "
"comienzan con ``u``)."

#: ../Doc/howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "Leyendo y escribiendo datos Unicode"

#: ../Doc/howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next problem "
"is input/output.  How do you get Unicode strings into your program, and how "
"do you convert Unicode into a form suitable for storage or transmission?"
msgstr ""
"Una vez que haya escrito un c√≥digo que funcione con datos Unicode, el "
"siguiente problema es la entrada/salida. ¬øC√≥mo obtiene cadenas Unicode en su "
"programa y c√≥mo convierte Unicode en una forma adecuada para almacenamiento "
"o transmisi√≥n?"

#: ../Doc/howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your input "
"sources and output destinations; you should check whether the libraries used "
"in your application support Unicode natively.  XML parsers often return "
"Unicode data, for example.  Many relational databases also support Unicode-"
"valued columns and can return Unicode values from an SQL query."
msgstr ""
"Es posible que no necesite hacer nada dependiendo de sus fuentes de entrada "
"y destinos de salida; debe verificar si las bibliotecas utilizadas en su "
"aplicaci√≥n son compatibles con Unicode de forma nativa. Los analizadores XML "
"a menudo retornan datos Unicode, por ejemplo. Muchas bases de datos "
"relacionales tambi√©n admiten columnas con valores Unicode y pueden retornar "
"valores Unicode de una consulta SQL."

#: ../Doc/howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets "
"written to disk or sent over a socket.  It's possible to do all the work "
"yourself: open a file, read an 8-bit bytes object from it, and convert the "
"bytes with ``bytes.decode(encoding)``.  However, the manual approach is not "
"recommended."
msgstr ""
"Los datos Unicode generalmente se convierten a una codificaci√≥n particular "
"antes de escribirse en el disco o enviarse a trav√©s de un socket. Es posible "
"hacer todo el trabajo usted mismo: abra un archivo, lea un objeto de bytes "
"de 8 bits y convierta los bytes con ``bytes.decode(codificaci√≥n)``. Sin "
"embargo, no se recomienda el enfoque manual."

#: ../Doc/howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character can "
"be represented by several bytes.  If you want to read the file in arbitrary-"
"sized chunks (say, 1024 or 4096 bytes), you need to write error-handling "
"code to catch the case where only part of the bytes encoding a single "
"Unicode character are read at the end of a chunk.  One solution would be to "
"read the entire file into memory and then perform the decoding, but that "
"prevents you from working with files that are extremely large; if you need "
"to read a 2 GiB file, you need 2 GiB of RAM. (More, really, since for at "
"least a moment you'd need to have both the encoded string and its Unicode "
"version in memory.)"
msgstr ""
"Un problema es la naturaleza de m√∫ltiples bytes de las codificaciones; Un "
"car√°cter Unicode puede ser representado por varios bytes. Si desea leer el "
"archivo en fragmentos de tama√±o arbitrario (por ejemplo, 1024 o 4096 bytes), "
"debe escribir un c√≥digo de manejo de errores para detectar el caso en el que "
"solo una parte de los bytes que codifican un solo car√°cter Unicode se leen "
"al final de Un trozo. Una soluci√≥n ser√≠a leer todo el archivo en la memoria "
"y luego realizar la decodificaci√≥n, pero eso le impide trabajar con archivos "
"que son extremadamente grandes; si necesita leer un archivo de 2 GB, "
"necesita 2 GB de RAM. (M√°s, realmente, ya que por al menos un momento "
"necesitar√≠as tener tanto la cadena codificada como su versi√≥n Unicode en la "
"memoria)."

#: ../Doc/howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch the "
"case of partial coding sequences.  The work of implementing this has already "
"been done for you: the built-in :func:`open` function can return a file-like "
"object that assumes the file's contents are in a specified encoding and "
"accepts Unicode parameters for methods such as :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.write`.  This works through :func:`open`\\'s "
"*encoding* and *errors* parameters which are interpreted just like those in :"
"meth:`str.encode` and :meth:`bytes.decode`."
msgstr ""
"La soluci√≥n ser√≠a utilizar la interfaz de decodificaci√≥n de bajo nivel para "
"detectar el caso de secuencias de codificaci√≥n parcial. El trabajo de "
"implementar esto ya se ha realizado para usted: la funci√≥n incorporada :func:"
"`open` puede retornar un objeto similar a un archivo que asume que el "
"contenido del archivo est√° en una codificaci√≥n especificada y acepta "
"par√°metros Unicode para m√©todos como :meth:`~io.TextIOBase.read` y :meth:"
"`~io.TextIOBase.write`. Esto funciona a trav√©s de los par√°metros *enconding* "
"y *errors* de :func:`open` que se interpretan como los de :meth:`str.encode` "
"y :meth:`bytes.decode`."

#: ../Doc/howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "Por lo tanto, leer Unicode de un archivo es simple::"

#: ../Doc/howto/unicode.rst:576
msgid ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"
msgstr ""

#: ../Doc/howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading and "
"writing::"
msgstr ""
"Tambi√©n es posible abrir archivos en modo de actualizaci√≥n, lo que permite "
"leer y escribir::"

#: ../Doc/howto/unicode.rst:583
msgid ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"
msgstr ""

#: ../Doc/howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and is "
"often written as the first character of a file in order to assist with "
"autodetection of the file's byte ordering.  Some encodings, such as UTF-16, "
"expect a BOM to be present at the start of a file; when such an encoding is "
"used, the BOM will be automatically written as the first character and will "
"be silently dropped when the file is read.  There are variants of these "
"encodings, such as 'utf-16-le' and 'utf-16-be' for little-endian and big-"
"endian encodings, that specify one particular byte ordering and don't skip "
"the BOM."
msgstr ""
"El car√°cter Unicode ``U+FEFF`` se usa como marca de orden de bytes (BOM), y "
"a menudo se escribe como el primer car√°cter de un archivo para ayudar a la "
"auto detecci√≥n del orden de bytes del archivo. Algunas codificaciones, como "
"UTF-16, esperan que haya una BOM al comienzo de un archivo; cuando se "
"utiliza dicha codificaci√≥n, la BOM se escribir√° autom√°ticamente como el "
"primer car√°cter y se descartar√° en silencio cuando se lea el archivo. "
"Existen variantes de estas codificaciones, como 'utf-16-le' y 'utf-16-be' "
"para codificaciones 'little-endian' y 'big-endian', que especifican un orden "
"de bytes particular y no omiten la BOM."

#: ../Doc/howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of UTF-8 "
"encoded files; the name is misleading since UTF-8 is not byte-order "
"dependent. The mark simply announces that the file is encoded in UTF-8.  For "
"reading such files, use the 'utf-8-sig' codec to automatically skip the mark "
"if present."
msgstr ""
"En algunas √°reas, tambi√©n es convencional usar una \"BOM\" al comienzo de "
"los archivos codificados UTF-8; el nombre es enga√±oso ya que UTF-8 no "
"depende del orden de bytes. La marca simplemente anuncia que el archivo est√° "
"codificado en UTF-8. Para leer dichos archivos, use el c√≥dec 'utf-8-sig' "
"para omitir autom√°ticamente la marca si est√° presente."

#: ../Doc/howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "Nombres de archivos Unicode"

#: ../Doc/howto/unicode.rst:606
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on "
"the system.  Today Python is converging on using UTF-8: Python on MacOS has "
"used UTF-8 for several versions, and Python 3.6 switched to using UTF-8 on "
"Windows as well.  On Unix systems, there will only be a :term:`filesystem "
"encoding <filesystem encoding and error handler>`. if you've set the "
"``LANG`` or ``LC_CTYPE`` environment variables; if you haven't, the default "
"encoding is again UTF-8."
msgstr ""
"La mayor√≠a de los sistemas operativos de uso com√∫n en la actualidad admiten "
"nombres de archivo que contienen caracteres Unicode arbitrarios. Por lo "
"general, esto se implementa convirtiendo la cadena Unicode en una "
"codificaci√≥n que var√≠a seg√∫n el sistema. Hoy Python est√° convergiendo en el "
"uso de UTF-8: Python en MacOS ha usado UTF-8 para varias versiones, y Python "
"3.6 tambi√©n ha cambiado a usar UTF-8 en Windows. En los sistemas Unix, solo "
"habr√° un :term:`filesystem encoding <filesystem encoding and error "
"handler>`. si ha configurado las variables de entorno ``LANG`` o "
"``LC_CTYPE``; si no lo ha hecho, la codificaci√≥n predeterminada es "
"nuevamente UTF-8."

#: ../Doc/howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to use "
"on your current system, in case you want to do the encoding manually, but "
"there's not much reason to bother.  When opening a file for reading or "
"writing, you can usually just provide the Unicode string as the filename, "
"and it will be automatically converted to the right encoding for you::"
msgstr ""
"La funci√≥n :func:`sys.getfilesystemencoding` retorna la codificaci√≥n para "
"usar en su sistema actual, en caso de que desee realizar la codificaci√≥n "
"manualmente, pero no hay muchas razones para molestarse. Al abrir un archivo "
"para leer o escribir, generalmente puede proporcionar la cadena Unicode como "
"nombre de archivo, y se convertir√° autom√°ticamente a la codificaci√≥n "
"correcta para usted::"

#: ../Doc/howto/unicode.rst:622
msgid ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"
msgstr ""

#: ../Doc/howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also accept "
"Unicode filenames."
msgstr ""
"Las funciones en el m√≥dulo :mod:`os` como :func:`os.stat` tambi√©n aceptar√°n "
"nombres de archivo Unicode."

#: ../Doc/howto/unicode.rst:629
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue: "
"should it return the Unicode version of filenames, or should it return bytes "
"containing the encoded versions?  :func:`os.listdir` can do both, depending "
"on whether you provided the directory path as bytes or a Unicode string.  If "
"you pass a Unicode string as the path, filenames will be decoded using the "
"filesystem's encoding and a list of Unicode strings will be returned, while "
"passing a byte path will return the filenames as bytes.  For example, "
"assuming the default :term:`filesystem encoding <filesystem encoding and "
"error handler>` is UTF-8, running the following program::"
msgstr ""
"La funci√≥n :func:`os.listdir` retorna nombres de archivo, lo que plantea un "
"problema: ¬ødeber√≠a devolver la versi√≥n Unicode de los nombres de archivo o "
"deber√≠a devolver bytes que contienen las versiones codificadas? :func:`os."
"listdir` puede hacer ambas cosas, dependiendo de si proporcion√≥ la ruta del "
"directorio como bytes o una cadena Unicode. Si pasa una cadena Unicode como "
"ruta, los nombres de archivo se decodificar√°n utilizando la codificaci√≥n del "
"sistema de archivos y se devolver√° una lista de cadenas Unicode, mientras "
"que pasar una ruta de bytes devolver√° los nombres de archivo como bytes. Por "
"ejemplo, suponiendo que el :term:`filesystem encoding <filesystem encoding "
"and error handler>` predeterminado es UTF-8, al ejecutar el siguiente "
"programa:"

#: ../Doc/howto/unicode.rst:639
msgid ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"
msgstr ""

#: ../Doc/howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "producir√° la siguiente salida:"

#: ../Doc/howto/unicode.rst:649
msgid ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"
msgstr ""

#: ../Doc/howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr ""
"La primera lista contiene nombres de archivos codificados con UTF-8, y la "
"segunda lista contiene las versiones Unicode."

#: ../Doc/howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode "
"with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix systems "
"now."
msgstr ""
"Tenga en cuenta que en la mayor√≠a de las ocasiones, debe seguir usando "
"Unicode con estas API. Las API de bytes solo deben usarse en sistemas donde "
"pueden estar presentes nombres de archivo no codificables; eso es "
"pr√°cticamente solo sistemas Unix ahora."

#: ../Doc/howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "Consejos para escribir programas compatibles con Unicode"

#: ../Doc/howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals with "
"Unicode."
msgstr ""
"Esta secci√≥n proporciona algunas sugerencias sobre c√≥mo escribir software "
"que maneje Unicode."

#: ../Doc/howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "El consejo m√°s importante es:"

#: ../Doc/howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"El software solo deber√≠a funcionar con cadenas Unicode internamente, "
"decodificando los datos de entrada lo antes posible y codificando la salida "
"solo al final."

#: ../Doc/howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and "
"byte strings, you will find your program vulnerable to bugs wherever you "
"combine the two different kinds of strings.  There is no automatic encoding "
"or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` will be "
"raised."
msgstr ""
"Si intenta escribir funciones de procesamiento que acepten cadenas Unicode y "
"de bytes, encontrar√° que su programa es vulnerable a errores dondequiera que "
"combine los dos tipos diferentes de cadenas. No hay codificaci√≥n o "
"decodificaci√≥n autom√°tica: si hace, por ejemplo: ``str+bytes``, un :exc:"
"`TypeError` se generar√°."

#: ../Doc/howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source, a "
"common technique is to check for illegal characters in a string before using "
"the string in a generated command line or storing it in a database.  If "
"you're doing this, be careful to check the decoded string, not the encoded "
"bytes data; some encodings may have interesting properties, such as not "
"being bijective or not being fully ASCII-compatible.  This is especially "
"true if the input data also specifies the encoding, since the attacker can "
"then choose a clever way to hide malicious text in the encoded bytestream."
msgstr ""
"Cuando se usan datos que provienen de un navegador web u otra fuente no "
"confiable, una t√©cnica com√∫n es verificar si hay caracteres ilegales en una "
"cadena antes de usar la cadena en una l√≠nea de comando generada o "
"almacenarla en una base de datos. Si est√° haciendo esto, tenga cuidado de "
"verificar la cadena decodificada, no los datos de bytes codificados; Algunas "
"codificaciones pueden tener propiedades interesantes, como no ser biyectivo "
"o no ser totalmente compatible con ASCII. Esto es especialmente cierto si "
"los datos de entrada tambi√©n especifican la codificaci√≥n, ya que el atacante "
"puede elegir una forma inteligente de ocultar el texto malicioso en el flujo "
"de bytes codificado."

#: ../Doc/howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "Conversi√≥n entre codificaciones de archivo"

#: ../Doc/howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert between "
"encodings, taking a stream that returns data in encoding #1 and behaving "
"like a stream returning data in encoding #2."
msgstr ""
"La clase :class:`~codecs.StreamRecoder` puede convertir de forma "
"transparente entre codificaciones, tomar una secuencia que retorna datos en "
"la codificaci√≥n 1 y comportarse como una secuencia que retorna datos en la "
"codificaci√≥n 2."

#: ../Doc/howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can wrap "
"it with a :class:`~codecs.StreamRecoder` to return bytes encoded in UTF-8::"
msgstr ""
"Por ejemplo, si tiene un archivo de entrada *f* que est√° en Latin-1, puede "
"envolverlo con :class:`~codecs.StreamRecoder` para retornar bytes "
"codificados en UTF-8::"

#: ../Doc/howto/unicode.rst:701
msgid ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"
msgstr ""

#: ../Doc/howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "Archivos en una codificaci√≥n desconocida"

#: ../Doc/howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know the "
"file's encoding?  If you know the encoding is ASCII-compatible and only want "
"to examine or modify the ASCII parts, you can open the file with the "
"``surrogateescape`` error handler::"
msgstr ""
"¬øQu√© puede hacer si necesita hacer un cambio en un archivo, pero no conoce "
"la codificaci√≥n del archivo? Si sabe que la codificaci√≥n es compatible con "
"ASCII y solo desea examinar o modificar las partes ASCII, puede abrir el "
"archivo con el manejador de errores ``surrogateescape``::"

#: ../Doc/howto/unicode.rst:718
msgid ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"
msgstr ""

#: ../Doc/howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code "
"points will then turn back into the same bytes when the ``surrogateescape`` "
"error handler is used to encode the data and write it back out."
msgstr ""
"El manejador de errores ``surrogateescape`` decodificar√° los bytes que no "
"sean ASCII como puntos de c√≥digo en un rango especial que va desde U+DC80 a "
"U+DCFF. Estos puntos de c√≥digo volver√°n a convertirse en los mismos bytes "
"cuando se use el controlador de error ``subrogateescape`` para codificar los "
"datos y volver a escribirlos."

#: ../Doc/howto/unicode.rst:737
#, fuzzy
msgid ""
"One section of `Mastering Python 3 Input/Output <https://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, a PyCon 2010 talk by David "
"Beazley, discusses text processing and binary data handling."
msgstr ""
"Una secci√≥n de  `Mastering Python 3 Input/Output <http://pyvideo.org/"
"video/289/pycon-2010--mastering-python-3-i-o>`_, una charla de *David "
"Beazley* en la PyCon 2010, analiza el procesamiento de texto y el manejo de "
"datos binarios."

#: ../Doc/howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-Andr√© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discuss questions of "
"character encodings as well as how to internationalize and localize an "
"application.  These slides cover Python 2.x only."
msgstr ""
"El `PDF slides for Marc-Andr√© Lemburg's presentation \"Writing Unicode-aware "
"Applications in Python\" <https://downloads.egenix.com/python/LSM2005-"
"Developing-Unicode-aware-applications-in-Python.pdf>`_ discute cuestiones de "
"codificaciones de caracteres, as√≠ como tambi√©n c√≥mo internacionalizar y "
"localizar una aplicaci√≥n. Estas diapositivas cubren solo Python 2.x."

#: ../Doc/howto/unicode.rst:747
#, fuzzy
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"`The Guts of Unicode in Python <http://pyvideo.org/video/1768/the-guts-of-"
"unicode-in-python>`_ es una charla de *Benjamin Peterson* en PyCon 2013 que "
"analiza la representaci√≥n interna de Unicode en Python 3.3."

#: ../Doc/howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "Agradecimientos"

#: ../Doc/howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has "
"since been revised further by Alexander Belopolsky, Georg Brandl, Andrew "
"Kuchling, and Ezio Melotti."
msgstr ""
"El borrador inicial de este documento fue escrito por *Andrew Kuchling*. "
"Desde entonces ha sido revisado por *Alexander Belopolsky, Georg Brandl, "
"Andrew Kuchling y Ezio Melotti*."

#: ../Doc/howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered suggestions "
"on this article: √âric Araujo, Nicholas Bastin, Nick Coghlan, Marius "
"Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, Martin von L√∂wis, "
"Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, Graham Wideman."
msgstr ""
"293/5000\n"
"Gracias a las siguientes personas que notaron errores u ofrecieron "
"sugerencias sobre este art√≠culo: *√âric Araujo, Nicholas Bastin, Nick "
"Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-Andr√© Lemburg, "
"Martin von L√∂wis, Terry J. Reedy, Serhiy Storchaka , Eryk Sun, Chad "
"Whitacre, Graham Wideman*."
