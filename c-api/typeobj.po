# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-21 16:38-0300\n"
"PO-Revision-Date: 2022-11-03 04:57-0400\n"
"Last-Translator: Cristián Maureira-Fredes <cmaureirafredes@gmail.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../Doc/c-api/typeobj.rst:6
msgid "Type Objects"
msgstr "Objetos tipo"

#: ../Doc/c-api/typeobj.rst:8
#, fuzzy
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Quizás una de las estructuras más importantes del sistema de objetos Python "
"es la estructura que define un nuevo tipo: la "
"estructura :c:type:`PyTypeObject`. Los objetos tipo se pueden manejar "
"utilizando cualquiera de las funciones :c:func:`PyObject_\\*` "
"o :c:func:`PyType_\\*`, pero no ofrecen mucho que sea interesante para la "
"mayoría de las aplicaciones de Python. Estos objetos son fundamentales para "
"el comportamiento de los objetos, por lo que son muy importantes para el "
"propio intérprete y para cualquier módulo de extensión que implemente nuevos "
"tipos."

#: ../Doc/c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Los objetos de tipo son bastante grandes en comparación con la mayoría de "
"los tipos estándar. La razón del tamaño es que cada objeto de tipo almacena "
"una gran cantidad de valores, principalmente punteros de función C, cada uno "
"de los cuales implementa una pequeña parte de la funcionalidad del tipo. Los "
"campos del objeto tipo se examinan en detalle en esta sección. Los campos se "
"describirán en el orden en que aparecen en la estructura."

#: ../Doc/c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use "
"of :c:type:`PyTypeObject`."
msgstr ""
"Además de la siguiente referencia rápida, la sección :ref:`typedef-examples` "
"proporciona una visión rápida del significado y uso "
"de :c:type:`PyTypeObject`."

#: ../Doc/c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Referencia rápida"

#: ../Doc/c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"ranuras *tp*\" (*tp slots*)"

#: ../Doc/c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "Ranura ``PyTypeObject`` [#slots]_"

#: ../Doc/c-api/typeobj.rst:40 ../Doc/c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Type <slot-typedefs-table>`"

#: ../Doc/c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "métodos/atributos especiales"

#: ../Doc/c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Información [#cols]_"

#: ../Doc/c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../Doc/c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../Doc/c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../Doc/c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../Doc/c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../Doc/c-api/typeobj.rst ../Doc/c-api/typeobj.rst:44
#: ../Doc/c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../Doc/c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../Doc/c-api/typeobj.rst:44 ../Doc/c-api/typeobj.rst:46
#: ../Doc/c-api/typeobj.rst:48 ../Doc/c-api/typeobj.rst:50
#: ../Doc/c-api/typeobj.rst:52 ../Doc/c-api/typeobj.rst:62
#: ../Doc/c-api/typeobj.rst:70 ../Doc/c-api/typeobj.rst:72
#: ../Doc/c-api/typeobj.rst:74 ../Doc/c-api/typeobj.rst:76
#: ../Doc/c-api/typeobj.rst:79 ../Doc/c-api/typeobj.rst:84
#: ../Doc/c-api/typeobj.rst:86 ../Doc/c-api/typeobj.rst:88
#: ../Doc/c-api/typeobj.rst:90 ../Doc/c-api/typeobj.rst:92
#: ../Doc/c-api/typeobj.rst:99 ../Doc/c-api/typeobj.rst:101
#: ../Doc/c-api/typeobj.rst:103 ../Doc/c-api/typeobj.rst:105
#: ../Doc/c-api/typeobj.rst:107 ../Doc/c-api/typeobj.rst:109
#: ../Doc/c-api/typeobj.rst:111 ../Doc/c-api/typeobj.rst:115
#: ../Doc/c-api/typeobj.rst:117 ../Doc/c-api/typeobj.rst:120
#: ../Doc/c-api/typeobj.rst:122 ../Doc/c-api/typeobj.rst:124
#: ../Doc/c-api/typeobj.rst:126 ../Doc/c-api/typeobj.rst:128
#: ../Doc/c-api/typeobj.rst:130 ../Doc/c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../Doc/c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../Doc/c-api/typeobj.rst ../Doc/c-api/typeobj.rst:46
#: ../Doc/c-api/typeobj.rst:48 ../Doc/c-api/typeobj.rst:52
#: ../Doc/c-api/typeobj.rst:99 ../Doc/c-api/typeobj.rst:120
#: ../Doc/c-api/typeobj.rst:416
#, fuzzy
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`ssizeargfunc`"

#: ../Doc/c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../Doc/c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../Doc/c-api/typeobj.rst:50 ../Doc/c-api/typeobj.rst:142
#: ../Doc/c-api/typeobj.rst:146 ../Doc/c-api/typeobj.rst:346
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../Doc/c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../Doc/c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../Doc/c-api/typeobj.rst:54 ../Doc/c-api/typeobj.rst:370
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../Doc/c-api/typeobj.rst:54 ../Doc/c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../Doc/c-api/typeobj.rst:54 ../Doc/c-api/typeobj.rst:57
#: ../Doc/c-api/typeobj.rst:70 ../Doc/c-api/typeobj.rst:76
#: ../Doc/c-api/typeobj.rst:79 ../Doc/c-api/typeobj.rst:88
#: ../Doc/c-api/typeobj.rst:90 ../Doc/c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../Doc/c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../Doc/c-api/typeobj.rst:57 ../Doc/c-api/typeobj.rst:375
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../Doc/c-api/typeobj.rst:57 ../Doc/c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../Doc/c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../Doc/c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../Doc/c-api/typeobj.rst:60 ../Doc/c-api/typeobj.rst:64
#: ../Doc/c-api/typeobj.rst:66 ../Doc/c-api/typeobj.rst:68
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../Doc/c-api/typeobj.rst:60 ../Doc/c-api/typeobj.rst:64
#: ../Doc/c-api/typeobj.rst:66 ../Doc/c-api/typeobj.rst:68
#: ../Doc/c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../Doc/c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../Doc/c-api/typeobj.rst:62 ../Doc/c-api/typeobj.rst:74
#: ../Doc/c-api/typeobj.rst:368
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../Doc/c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../Doc/c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../Doc/c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../Doc/c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../Doc/c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../Doc/c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../Doc/c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../Doc/c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../Doc/c-api/typeobj.rst:70 ../Doc/c-api/typeobj.rst:404
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../Doc/c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../Doc/c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../Doc/c-api/typeobj.rst:72 ../Doc/c-api/typeobj.rst:237
#: ../Doc/c-api/typeobj.rst:240 ../Doc/c-api/typeobj.rst:440
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../Doc/c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../Doc/c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../Doc/c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../Doc/c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../Doc/c-api/typeobj.rst:76 ../Doc/c-api/typeobj.rst:381
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../Doc/c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../Doc/c-api/typeobj.rst:79 ../Doc/c-api/typeobj.rst:386
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../Doc/c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../Doc/c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../Doc/c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../Doc/c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../Doc/c-api/typeobj.rst:84 ../Doc/c-api/typeobj.rst:99
#: ../Doc/c-api/typeobj.rst:113 ../Doc/c-api/typeobj.rst:120
#: ../Doc/c-api/typeobj.rst:124 ../Doc/c-api/typeobj.rst:126
#: ../Doc/c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../Doc/c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../Doc/c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../Doc/c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../Doc/c-api/typeobj.rst:88 ../Doc/c-api/typeobj.rst:350
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../Doc/c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../Doc/c-api/typeobj.rst:90 ../Doc/c-api/typeobj.rst:130
#: ../Doc/c-api/typeobj.rst:248 ../Doc/c-api/typeobj.rst:429
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../Doc/c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../Doc/c-api/typeobj.rst:92 ../Doc/c-api/typeobj.rst:406
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../Doc/c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../Doc/c-api/typeobj.rst:99
#, fuzzy
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr ":c:member:`~PyTypeObject.tp_weaklistoffset`"

#: ../Doc/c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../Doc/c-api/typeobj.rst:101 ../Doc/c-api/typeobj.rst:412
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../Doc/c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../Doc/c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../Doc/c-api/typeobj.rst:103 ../Doc/c-api/typeobj.rst:414
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../Doc/c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../Doc/c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../Doc/c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../Doc/c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../Doc/c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../Doc/c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../Doc/c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../Doc/c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../Doc/c-api/typeobj.rst ../Doc/c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../Doc/c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../Doc/c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../Doc/c-api/typeobj.rst ../Doc/c-api/typeobj.rst:113
#: ../Doc/c-api/typeobj.rst:132 ../Doc/c-api/typeobj.rst:134
#: ../Doc/c-api/typeobj.rst:136 ../Doc/c-api/typeobj.rst:140
#: ../Doc/c-api/typeobj.rst:341 ../Doc/c-api/typeobj.rst:346
#: ../Doc/c-api/typeobj.rst:356 ../Doc/c-api/typeobj.rst:368
#: ../Doc/c-api/typeobj.rst:370 ../Doc/c-api/typeobj.rst:381
#: ../Doc/c-api/typeobj.rst:392 ../Doc/c-api/typeobj.rst:404
#: ../Doc/c-api/typeobj.rst:406 ../Doc/c-api/typeobj.rst:412
#: ../Doc/c-api/typeobj.rst:414 ../Doc/c-api/typeobj.rst:416
#: ../Doc/c-api/typeobj.rst:429 ../Doc/c-api/typeobj.rst:431
#: ../Doc/c-api/typeobj.rst:435 ../Doc/c-api/typeobj.rst:440
#: ../Doc/c-api/typeobj.rst:446
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../Doc/c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../Doc/c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../Doc/c-api/typeobj.rst:115 ../Doc/c-api/typeobj.rst:392
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../Doc/c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../Doc/c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../Doc/c-api/typeobj.rst:117 ../Doc/c-api/typeobj.rst:398
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../Doc/c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../Doc/c-api/typeobj.rst:120
#, fuzzy
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr ":c:member:`~PyTypeObject.tp_dictoffset`"

#: ../Doc/c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../Doc/c-api/typeobj.rst:122 ../Doc/c-api/typeobj.rst:362
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../Doc/c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../Doc/c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../Doc/c-api/typeobj.rst:124 ../Doc/c-api/typeobj.rst:341
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../Doc/c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../Doc/c-api/typeobj.rst:126 ../Doc/c-api/typeobj.rst:356
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../Doc/c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../Doc/c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../Doc/c-api/typeobj.rst:128 ../Doc/c-api/typeobj.rst:348
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../Doc/c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../Doc/c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../Doc/c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../Doc/c-api/typeobj.rst:132 ../Doc/c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../Doc/c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../Doc/c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../Doc/c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../Doc/c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../Doc/c-api/typeobj.rst ../Doc/c-api/typeobj.rst:138
#: ../Doc/c-api/typeobj.rst:279 ../Doc/c-api/typeobj.rst:348
msgid "void *"
msgstr "void *"

#: ../Doc/c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../Doc/c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../Doc/c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../Doc/c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../Doc/c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../Doc/c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../Doc/c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../Doc/c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../Doc/c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../Doc/c-api/typeobj.rst:150
#, fuzzy
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../Doc/c-api/typeobj.rst:150
#, fuzzy
msgid "unsigned char"
msgstr "unsigned int"

#: ../Doc/c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""

#: ../Doc/c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""

#: ../Doc/c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr ""

#: ../Doc/c-api/typeobj.rst:162
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""

#: ../Doc/c-api/typeobj.rst:164
msgid "Columns:"
msgstr "Columnas:"

#: ../Doc/c-api/typeobj.rst:166
#, fuzzy
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: establecido en :c:type:`PyBaseObject_Type`"

#: ../Doc/c-api/typeobj.rst:168
#, fuzzy
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**:  establecido en :c:type:`PyType_Type`"

#: ../Doc/c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**:  por defecto (si la ranura está establecida como ``NULL``)"

#: ../Doc/c-api/typeobj.rst:172
msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""

#: ../Doc/c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**:  herencia"

#: ../Doc/c-api/typeobj.rst:182
msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"
msgstr ""

#: ../Doc/c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Tenga en cuenta que algunos espacios se heredan efectivamente a través de la "
"cadena de búsqueda de atributos normal."

#: ../Doc/c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "sub-ranuras (*sub-slots*)"

#: ../Doc/c-api/typeobj.rst:201
msgid "Slot"
msgstr "Ranuras (*Slot*)"

#: ../Doc/c-api/typeobj.rst:201
msgid "special methods"
msgstr "métodos especiales"

#: ../Doc/c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../Doc/c-api/typeobj.rst:204 ../Doc/c-api/typeobj.rst:206
#: ../Doc/c-api/typeobj.rst:208 ../Doc/c-api/typeobj.rst:242
#: ../Doc/c-api/typeobj.rst:244 ../Doc/c-api/typeobj.rst:246
#: ../Doc/c-api/typeobj.rst:250 ../Doc/c-api/typeobj.rst:277
#: ../Doc/c-api/typeobj.rst:281 ../Doc/c-api/typeobj.rst:291
#: ../Doc/c-api/typeobj.rst:431
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../Doc/c-api/typeobj.rst:204
msgid "__await__"
msgstr "__await__"

#: ../Doc/c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../Doc/c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../Doc/c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../Doc/c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../Doc/c-api/typeobj.rst:210
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../Doc/c-api/typeobj.rst:210
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../Doc/c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../Doc/c-api/typeobj.rst:214 ../Doc/c-api/typeobj.rst:217
#: ../Doc/c-api/typeobj.rst:219 ../Doc/c-api/typeobj.rst:222
#: ../Doc/c-api/typeobj.rst:224 ../Doc/c-api/typeobj.rst:227
#: ../Doc/c-api/typeobj.rst:229 ../Doc/c-api/typeobj.rst:232
#: ../Doc/c-api/typeobj.rst:234 ../Doc/c-api/typeobj.rst:252
#: ../Doc/c-api/typeobj.rst:255 ../Doc/c-api/typeobj.rst:257
#: ../Doc/c-api/typeobj.rst:260 ../Doc/c-api/typeobj.rst:262
#: ../Doc/c-api/typeobj.rst:265 ../Doc/c-api/typeobj.rst:267
#: ../Doc/c-api/typeobj.rst:270 ../Doc/c-api/typeobj.rst:272
#: ../Doc/c-api/typeobj.rst:275 ../Doc/c-api/typeobj.rst:283
#: ../Doc/c-api/typeobj.rst:285 ../Doc/c-api/typeobj.rst:287
#: ../Doc/c-api/typeobj.rst:289 ../Doc/c-api/typeobj.rst:293
#: ../Doc/c-api/typeobj.rst:296 ../Doc/c-api/typeobj.rst:302
#: ../Doc/c-api/typeobj.rst:311 ../Doc/c-api/typeobj.rst:322
#: ../Doc/c-api/typeobj.rst:435
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../Doc/c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../Doc/c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../Doc/c-api/typeobj.rst:217 ../Doc/c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../Doc/c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../Doc/c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../Doc/c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../Doc/c-api/typeobj.rst:222
msgid "__isub__"
msgstr "__isub__"

#: ../Doc/c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../Doc/c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../Doc/c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../Doc/c-api/typeobj.rst:227 ../Doc/c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../Doc/c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../Doc/c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../Doc/c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../Doc/c-api/typeobj.rst:232
msgid "__imod__"
msgstr "__imod__"

#: ../Doc/c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../Doc/c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../Doc/c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../Doc/c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../Doc/c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../Doc/c-api/typeobj.rst:240
msgid "__ipow__"
msgstr "__ipow__"

#: ../Doc/c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../Doc/c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../Doc/c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../Doc/c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../Doc/c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../Doc/c-api/typeobj.rst:246
msgid "__abs__"
msgstr "__abs__"

#: ../Doc/c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../Doc/c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool__"

#: ../Doc/c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../Doc/c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invert__"

#: ../Doc/c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../Doc/c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../Doc/c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../Doc/c-api/typeobj.rst:255
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../Doc/c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../Doc/c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../Doc/c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../Doc/c-api/typeobj.rst:260
msgid "__irshift__"
msgstr "__irshift__"

#: ../Doc/c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../Doc/c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../Doc/c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../Doc/c-api/typeobj.rst:265
msgid "__iand__"
msgstr "__iand__"

#: ../Doc/c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../Doc/c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../Doc/c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../Doc/c-api/typeobj.rst:270
msgid "__ixor__"
msgstr "__ixor__"

#: ../Doc/c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../Doc/c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../Doc/c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../Doc/c-api/typeobj.rst:275
msgid "__ior__"
msgstr "__ior__"

#: ../Doc/c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../Doc/c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../Doc/c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../Doc/c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../Doc/c-api/typeobj.rst:281
msgid "__float__"
msgstr "__float__"

#: ../Doc/c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../Doc/c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../Doc/c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../Doc/c-api/typeobj.rst:285
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../Doc/c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../Doc/c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../Doc/c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../Doc/c-api/typeobj.rst:289
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../Doc/c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../Doc/c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../Doc/c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../Doc/c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../Doc/c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../Doc/c-api/typeobj.rst:296
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../Doc/c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../Doc/c-api/typeobj.rst:300 ../Doc/c-api/typeobj.rst:309
#: ../Doc/c-api/typeobj.rst:416
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../Doc/c-api/typeobj.rst:300 ../Doc/c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../Doc/c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../Doc/c-api/typeobj.rst:302 ../Doc/c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__getitem__"

#: ../Doc/c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../Doc/c-api/typeobj.rst:304 ../Doc/c-api/typeobj.rst:462
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../Doc/c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../Doc/c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../Doc/c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../Doc/c-api/typeobj.rst:311
msgid "__add__"
msgstr "__add__"

#: ../Doc/c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../Doc/c-api/typeobj.rst:313 ../Doc/c-api/typeobj.rst:315
#: ../Doc/c-api/typeobj.rst:324 ../Doc/c-api/typeobj.rst:446
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../Doc/c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../Doc/c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../Doc/c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../Doc/c-api/typeobj.rst:317 ../Doc/c-api/typeobj.rst:451
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../Doc/c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../Doc/c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../Doc/c-api/typeobj.rst:320 ../Doc/c-api/typeobj.rst:457
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../Doc/c-api/typeobj.rst:320
msgid "__contains__"
msgstr "__contains__"

#: ../Doc/c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../Doc/c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../Doc/c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../Doc/c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../Doc/c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../Doc/c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../Doc/c-api/typeobj.rst:336
msgid "slot typedefs"
msgstr "ranura de *typedefs*"

#: ../Doc/c-api/typeobj.rst:339
msgid "typedef"
msgstr "typedef"

#: ../Doc/c-api/typeobj.rst:339
msgid "Parameter Types"
msgstr "Tipos parámetros"

#: ../Doc/c-api/typeobj.rst:339
msgid "Return Type"
msgstr "Tipo de retorno"

#: ../Doc/c-api/typeobj.rst:346 ../Doc/c-api/typeobj.rst:348
#: ../Doc/c-api/typeobj.rst:424
msgid "void"
msgstr "void"

#: ../Doc/c-api/typeobj.rst
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../Doc/c-api/typeobj.rst ../Doc/c-api/typeobj.rst:350
#: ../Doc/c-api/typeobj.rst:362 ../Doc/c-api/typeobj.rst:375
#: ../Doc/c-api/typeobj.rst:386 ../Doc/c-api/typeobj.rst:398
#: ../Doc/c-api/typeobj.rst:418 ../Doc/c-api/typeobj.rst:429
#: ../Doc/c-api/typeobj.rst:451 ../Doc/c-api/typeobj.rst:457
#: ../Doc/c-api/typeobj.rst:462
msgid "int"
msgstr "int"

#: ../Doc/c-api/typeobj.rst:404
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../Doc/c-api/typeobj.rst:418
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../Doc/c-api/typeobj.rst
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../Doc/c-api/typeobj.rst:424
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../Doc/c-api/typeobj.rst:469
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Vea :ref:`slot-typedefs` abajo para más detalles."

#: ../Doc/c-api/typeobj.rst:473
msgid "PyTypeObject Definition"
msgstr "Definición de ``PyTypeObject``"

#: ../Doc/c-api/typeobj.rst:475
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found "
"in :file:`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"La definición de estructura para :c:type:`PyTypeObject` se puede encontrar "
"en :file:`Include/object.h`. Por conveniencia de referencia, esto repite la "
"definición encontrada allí:"

#: ../Doc/c-api/typeobj.rst:481
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    struct PyMethodDef *tp_methods;\n"
"    struct PyMemberDef *tp_members;\n"
"    struct PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    struct _typeobject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache;\n"
"    PyObject *tp_subclasses;\n"
"    PyObject *tp_weaklist;\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6 */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"} PyTypeObject;\n"
msgstr ""

#: ../Doc/c-api/typeobj.rst:485
msgid "PyObject Slots"
msgstr "Ranuras (*Slots*) ``PyObject``"

#: ../Doc/c-api/typeobj.rst:487
#, fuzzy
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. "
"The :c:member:`~PyVarObject.ob_size` field is used for dynamic types "
"(created by :c:func:`!type_new`, usually called from a class statement). "
"Note that :c:data:`PyType_Type` (the metatype) "
"initializes :c:member:`~PyTypeObject.tp_itemsize`, which means that its "
"instances (i.e. type objects) *must* have "
"the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"La estructura de objeto de tipo extiende la "
"estructura :c:type:`PyVarObject`. El campo :attr:`ob_size` se usa para tipos "
"dinámicos (creado por :func:`type_new`, generalmente llamado desde una "
"declaración de clase). Tenga en cuenta que :c:data:`PyType_Type` (el "
"metatipo) inicializa :c:member:`~PyTypeObject.tp_itemsize`, lo que significa "
"que sus instancias (es decir, objetos de tipo) *deben* tener el "
"campo :attr:`ob_size`."

#: ../Doc/c-api/typeobj.rst:496
#, fuzzy
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects "
"whose :c:member:`~PyObject.ob_type` points back to the type) do *not* count "
"as references.  But for :ref:`dynamically allocated type objects <heap-"
"types>`, the instances *do* count as references."
msgstr ""
"Este es el recuento de referencias del objeto de tipo, inicializado a ``1`` "
"por la macro ``PyObject_HEAD_INIT``. Tenga en cuenta que para :ref:`objetos "
"de tipo estáticamente asignados <static-types>`, las instancias del tipo "
"(objetos cuyo :attr:`ob_type` apunta al tipo) *no* cuentan como referencias. "
"Pero para :ref:`objetos de tipo asignados dinámicamente <heap-types>`, las "
"instancias *sí* cuentan como referencias."

#: ../Doc/c-api/typeobj.rst:503 ../Doc/c-api/typeobj.rst:526
#: ../Doc/c-api/typeobj.rst:540 ../Doc/c-api/typeobj.rst:584
#: ../Doc/c-api/typeobj.rst:627 ../Doc/c-api/typeobj.rst:686
#: ../Doc/c-api/typeobj.rst:727 ../Doc/c-api/typeobj.rst:744
#: ../Doc/c-api/typeobj.rst:761 ../Doc/c-api/typeobj.rst:779
#: ../Doc/c-api/typeobj.rst:803 ../Doc/c-api/typeobj.rst:820
#: ../Doc/c-api/typeobj.rst:832 ../Doc/c-api/typeobj.rst:844
#: ../Doc/c-api/typeobj.rst:877 ../Doc/c-api/typeobj.rst:899
#: ../Doc/c-api/typeobj.rst:919 ../Doc/c-api/typeobj.rst:940
#: ../Doc/c-api/typeobj.rst:966 ../Doc/c-api/typeobj.rst:985
#: ../Doc/c-api/typeobj.rst:1001 ../Doc/c-api/typeobj.rst:1040
#: ../Doc/c-api/typeobj.rst:1051 ../Doc/c-api/typeobj.rst:1061
#: ../Doc/c-api/typeobj.rst:1071 ../Doc/c-api/typeobj.rst:1085
#: ../Doc/c-api/typeobj.rst:1103 ../Doc/c-api/typeobj.rst:1126
#: ../Doc/c-api/typeobj.rst:1144 ../Doc/c-api/typeobj.rst:1157
#: ../Doc/c-api/typeobj.rst:1179 ../Doc/c-api/typeobj.rst:1223
#: ../Doc/c-api/typeobj.rst:1244 ../Doc/c-api/typeobj.rst:1263
#: ../Doc/c-api/typeobj.rst:1293 ../Doc/c-api/typeobj.rst:1315
#: ../Doc/c-api/typeobj.rst:1341 ../Doc/c-api/typeobj.rst:1426
#: ../Doc/c-api/typeobj.rst:1500 ../Doc/c-api/typeobj.rst:1561
#: ../Doc/c-api/typeobj.rst:1597 ../Doc/c-api/typeobj.rst:1622
#: ../Doc/c-api/typeobj.rst:1645 ../Doc/c-api/typeobj.rst:1658
#: ../Doc/c-api/typeobj.rst:1673 ../Doc/c-api/typeobj.rst:1687
#: ../Doc/c-api/typeobj.rst:1717 ../Doc/c-api/typeobj.rst:1749
#: ../Doc/c-api/typeobj.rst:1775 ../Doc/c-api/typeobj.rst:1793
#: ../Doc/c-api/typeobj.rst:1822 ../Doc/c-api/typeobj.rst:1866
#: ../Doc/c-api/typeobj.rst:1883 ../Doc/c-api/typeobj.rst:1924
#: ../Doc/c-api/typeobj.rst:1946 ../Doc/c-api/typeobj.rst:1978
#: ../Doc/c-api/typeobj.rst:2006 ../Doc/c-api/typeobj.rst:2019
#: ../Doc/c-api/typeobj.rst:2029 ../Doc/c-api/typeobj.rst:2046
#: ../Doc/c-api/typeobj.rst:2063 ../Doc/c-api/typeobj.rst:2077
#: ../Doc/c-api/typeobj.rst:2123 ../Doc/c-api/typeobj.rst:2146
msgid "**Inheritance:**"
msgstr "**Herencia:**"

#: ../Doc/c-api/typeobj.rst:505 ../Doc/c-api/typeobj.rst:542
#: ../Doc/c-api/typeobj.rst:586
msgid "This field is not inherited by subtypes."
msgstr "Este campo no es heredado por los subtipos."

#: ../Doc/c-api/typeobj.rst:510
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Este es el tipo del tipo, en otras palabras, su metatipo. Se inicializa "
"mediante el argumento de la macro ``PyObject_HEAD_INIT``, y su valor "
"normalmente debería ser ``&PyType_Type``. Sin embargo, para los módulos de "
"extensión cargables dinámicamente que deben ser utilizables en Windows (al "
"menos), el compilador se queja de que este no es un inicializador válido. "
"Por lo tanto, la convención es pasar ``NULL`` al macro "
"``PyObject_HEAD_INIT`` e inicializar este campo explícitamente al comienzo "
"de la función de inicialización del módulo, antes de hacer cualquier otra "
"cosa. Esto normalmente se hace así:"

#: ../Doc/c-api/typeobj.rst:519
msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr ""

#: ../Doc/c-api/typeobj.rst:521
#, fuzzy
msgid ""
"This should be done before any instances of the type are "
"created. :c:func:`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is "
"``NULL``, and if so, initializes it to the :c:member:`~PyObject.ob_type` "
"field of the base class. :c:func:`PyType_Ready` will not change this field "
"if it is non-zero."
msgstr ""
"Esto debe hacerse antes de que se creen instancias del "
"tipo. :c:func:`PyType_Ready` comprueba si :attr:`ob_type` es ``NULL``, y si "
"es así, lo inicializa en el campo :attr:`ob_type` de la clase "
"base. :c:func:`PyType_Ready` no cambiará este campo si no es cero."

#: ../Doc/c-api/typeobj.rst:528 ../Doc/c-api/typeobj.rst:688
#: ../Doc/c-api/typeobj.rst:805 ../Doc/c-api/typeobj.rst:901
#: ../Doc/c-api/typeobj.rst:921 ../Doc/c-api/typeobj.rst:1624
#: ../Doc/c-api/typeobj.rst:1647 ../Doc/c-api/typeobj.rst:1777
#: ../Doc/c-api/typeobj.rst:1795 ../Doc/c-api/typeobj.rst:1868
#: ../Doc/c-api/typeobj.rst:1980 ../Doc/c-api/typeobj.rst:2125
msgid "This field is inherited by subtypes."
msgstr "Este campo es heredado por subtipos."

#: ../Doc/c-api/typeobj.rst:532
msgid "PyVarObject Slots"
msgstr "Ranuras ``PyVarObject``"

#: ../Doc/c-api/typeobj.rst:536
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"Para :ref:`objetos de tipo estáticamente asignados <static-types>`, debe "
"inicializarse a cero. Para :ref:`objetos de tipo dinámicamente asignados "
"<heap-types>`, este campo tiene un significado interno especial."

#: ../Doc/c-api/typeobj.rst:546
msgid "PyTypeObject Slots"
msgstr "Ranuras ``PyTypeObject``"

#: ../Doc/c-api/typeobj.rst:548
#, fuzzy
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set "
"on :c:data:`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as "
"defaults.)"
msgstr ""
"Cada ranura tiene una sección que describe la herencia. "
"Si :c:func:`PyType_Ready` puede establecer un valor cuando el campo se "
"establece en ``NULL``, entonces también habrá una sección "
"\"Predeterminada\". (Tenga en cuenta que muchos campos establecidos "
"en :c:type:`PyBaseObject_Type` y :c:type:`PyType_Type` actúan efectivamente "
"como valores predeterminados)."

#: ../Doc/c-api/typeobj.rst:555
#, fuzzy
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in "
"subpackage :mod:`!Q` in package :mod:`!P` should have "
"the :c:member:`~PyTypeObject.tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Puntero a una cadena de caracteres terminada en ``NULL`` que contiene el "
"nombre del tipo. Para los tipos que son accesibles como módulos globales, la "
"cadena debe ser el nombre completo del módulo, seguido de un punto, seguido "
"del nombre del tipo; para los tipos integrados, debe ser solo el nombre del "
"tipo. Si el módulo es un submódulo de un paquete, el nombre completo del "
"paquete es parte del nombre completo del módulo. Por ejemplo, un tipo "
"llamado :class:`T` definido en el módulo :mod:`M` en el subpaquete :mod:`Q` "
"en el paquete :mod:`P` debe tener el "
"inicializador :c:member:`~PyTypeObject.tp_name` ``\"PQMT\"``."

#: ../Doc/c-api/typeobj.rst:563
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"Para :ref:`objetos de tipo dinámicamente asignados <heap-types>`, éste debe "
"ser sólo el nombre del tipo, y el nombre del módulo almacenado "
"explícitamente en el dict tipo que el valor de ``'__module__'`` clave."

#: ../Doc/c-api/typeobj.rst:568
#, fuzzy
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`~type.__module__` attribute, and everything after "
"the last dot is made accessible as the :attr:`~type.__name__` attribute."
msgstr ""
"Para :ref:`objetos de tipo estáticamente asignados <static-types>`, el campo "
"*tp_name* debe contener un punto. Todo lo que está antes del último punto se "
"hace accesible como el atributo :attr:`__module__`, y todo lo que está "
"después del último punto se hace accesible como el "
"atributo :attr:`~definition.__name__`."

#: ../Doc/c-api/typeobj.rst:574
#, fuzzy
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~type.__name__` attribute, and "
"the :attr:`~type.__module__` attribute is undefined (unless explicitly set "
"in the dictionary, as explained above).  This means your type will be "
"impossible to pickle.  Additionally, it will not be listed in module "
"documentations created with pydoc."
msgstr ""
"Si no hay ningún punto, todo el campo :c:member:`~PyTypeObject.tp_name` se "
"hace accesible como el atributo :attr:`~definition.__name__`, y el "
"atributo :attr:`__module__` no está definido (a menos que sea explícitamente "
"establecido en el diccionario, como se explicó anteriormente). Esto "
"significa que su tipo será imposible de guardar como *pickle*. Además, no "
"figurará en la documentación del módulo creado con *pydoc*."

#: ../Doc/c-api/typeobj.rst:580
msgid ""
"This field must not be ``NULL``.  It is the only required field "
"in :c:func:`PyTypeObject` (other than "
"potentially :c:member:`~PyTypeObject.tp_itemsize`)."
msgstr ""
"Este campo no debe ser ``NULL``. Es el único campo obligatorio "
"en :c:func:`PyTypeObject` (que no sea "
"potencialmente :c:member:`~PyTypeObject.tp_itemsize`)."

#: ../Doc/c-api/typeobj.rst:592
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"Estos campos permiten calcular el tamaño en bytes de instancias del tipo."

#: ../Doc/c-api/typeobj.rst:594
msgid ""
"There are two kinds of types: types with fixed-length instances have a "
"zero :c:member:`~PyTypeObject.tp_itemsize` field, types with variable-length "
"instances have a non-zero :c:member:`~PyTypeObject.tp_itemsize` field.  For "
"a type with fixed-length instances, all instances have the same size, given "
"in :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"Hay dos tipos de tipos: los tipos con instancias de longitud fija tienen un "
"campo cero :c:member:`~PyTypeObject.tp_itemsize`, los tipos con instancias "
"de longitud variable tienen un campo distinto de "
"cero :c:member:`~PyTypeObject.tp_itemsize`. Para un tipo con instancias de "
"longitud fija, todas las instancias tienen el mismo tamaño, dado "
"en :c:member:`~PyTypeObject.tp_basicsize`."

#: ../Doc/c-api/typeobj.rst:599
#, fuzzy
msgid ""
"For a type with variable-length instances, the instances must have "
"an :c:member:`~PyVarObject.ob_size` field, and the instance size "
"is :c:member:`~PyTypeObject.tp_basicsize` plus N "
"times :c:member:`~PyTypeObject.tp_itemsize`, where N is the \"length\" of "
"the object.  The value of N is typically stored in the "
"instance's :c:member:`~PyVarObject.ob_size` field.  There are exceptions:  "
"for example, ints use a negative :c:member:`~PyVarObject.ob_size` to "
"indicate a negative number, and N is ``abs(ob_size)`` there.  Also, the "
"presence of an :c:member:`~PyVarObject.ob_size` field in the instance layout "
"doesn't mean that the instance structure is variable-length (for example, "
"the structure for the list type has fixed-length instances, yet those "
"instances have a meaningful :c:member:`~PyVarObject.ob_size` field)."
msgstr ""
"Para un tipo con instancias de longitud variable, las instancias deben tener "
"un campo :attr:`ob_size`, y el tamaño de la instancia "
"es :c:member:`~PyTypeObject.tp_basicsize` más *N* "
"veces :c:member:`~PyTypeObject. tp_itemsize`, donde N es la \"longitud\" del "
"objeto. El valor de *N* generalmente se almacena en el campo :attr:`ob_size` "
"de la instancia. Hay excepciones: por ejemplo, los *ints* usan un "
"negativo :attr:`ob_size` para indicar un número negativo, y *N* es "
"``abs(ob_size)`` allí. Además, la presencia de un campo :attr:`ob_size` en "
"el diseño de la instancia no significa que la estructura de la instancia sea "
"de longitud variable (por ejemplo, la estructura para el tipo de lista tiene "
"instancias de longitud fija, aunque esas instancias tienen un significativo "
"campo :attr:`ob_size`)."

#: ../Doc/c-api/typeobj.rst:610
#, fuzzy
msgid ""
"The basic size includes the fields in the instance declared by the "
"macro :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is "
"used to declare the instance struct) and this in turn includes "
"the  :c:member:`~PyObject._ob_prev` and :c:member:`~PyObject._ob_next` "
"fields if they are present.  This means that the only correct way to get an "
"initializer for the :c:member:`~PyTypeObject.tp_basicsize` is to use the "
"``sizeof`` operator on the struct used to declare the instance layout. The "
"basic size does not include the GC header size."
msgstr ""
"El tamaño básico incluye los campos en la instancia declarada por el "
"macro :c:macro:`PyObject_HEAD` o :c:macro:`PyObject_VAR_HEAD` (lo que se use "
"para declarar la estructura de la instancia) y esto a su vez incluye "
"campos :attr:`_ob_prev` y :attr:`_ob_next` si están presentes. Esto "
"significa que la única forma correcta de obtener un inicializador "
"para :c:member:`~PyTypeObject.tp_basicsize` es usar el operador ``sizeof`` "
"en la estructura utilizada para declarar el diseño de la instancia. El "
"tamaño básico no incluye el tamaño del encabezado del GC."

#: ../Doc/c-api/typeobj.rst:618
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value "
"of :c:member:`~PyTypeObject.tp_basicsize`.  Example: suppose a type "
"implements an array of ``double``. :c:member:`~PyTypeObject.tp_itemsize` is "
"``sizeof(double)``. It is the programmer's responsibility "
"that :c:member:`~PyTypeObject.tp_basicsize` is a multiple of "
"``sizeof(double)`` (assuming this is the alignment requirement for "
"``double``)."
msgstr ""
"Una nota sobre la alineación: si los elementos variables requieren una "
"alineación particular, esto debe ser atendido por el valor "
"de :c:member:`~PyTypeObject.tp_basicsize`. Ejemplo: supongamos que un tipo "
"implementa un arreglo de dobles "
"(``double``). :c:member:`~PyTypeObject.tp_itemsize` es ``sizeof(double)``. "
"Es responsabilidad del programador "
"que :c:member:`~PyTypeObject.tp_basicsize` es un múltiplo de "
"``sizeof(double)`` (suponiendo que este sea el requisito de alineación para "
"``double``)."

#: ../Doc/c-api/typeobj.rst:625
msgid ""
"For any type with variable-length instances, this field must not be ``NULL``."
msgstr ""
"Para cualquier tipo con instancias de longitud variable, este campo no debe "
"ser ``NULL``."

#: ../Doc/c-api/typeobj.rst:629
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is generally not safe to "
"set :c:member:`~PyTypeObject.tp_itemsize` to a different non-zero value in a "
"subtype (though this depends on the implementation of the base type)."
msgstr ""
"Estos campos se heredan por separado por subtipos. Si el tipo base tiene un "
"miembro distinto de cero :c:member:`~PyTypeObject.tp_itemsize`, generalmente "
"no es seguro establecer :c:member:`~PyTypeObject.tp_itemsize` en un valor "
"diferente de cero en un subtipo ( aunque esto depende de la implementación "
"del tipo base)."

#: ../Doc/c-api/typeobj.rst:637
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``).  "
"The function signature is::"
msgstr ""
"Un puntero a la función destructor de instancias. Esta función debe "
"definirse a menos que el tipo garantice que sus instancias nunca se "
"desasignarán (como es el caso de los singletons ``None`` y ``Ellipsis``). La "
"firma de la función es::"

#: ../Doc/c-api/typeobj.rst:641
msgid "void tp_dealloc(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:643
#, fuzzy
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` "
"and :c:func:`Py_XDECREF` macros when the new reference count is zero.  At "
"this point, the instance is still in existence, but there are no references "
"to it.  The destructor function should free all references which the "
"instance owns, free all memory buffers owned by the instance (using the "
"freeing function corresponding to the allocation function used to allocate "
"the buffer), and call the type's :c:member:`~PyTypeObject.tp_free` "
"function.  If the type is not subtypable (doesn't have "
"the :c:macro:`Py_TPFLAGS_BASETYPE` flag bit set), it is permissible to call "
"the object deallocator directly instead of "
"via :c:member:`~PyTypeObject.tp_free`.  The object deallocator should be the "
"one used to allocate the instance; this is normally :c:func:`PyObject_Del` "
"if the instance was allocated using :c:macro:`PyObject_New` "
"or :c:macro:`PyObject_NewVar`, or :c:func:`PyObject_GC_Del` if the instance "
"was allocated using :c:macro:`PyObject_GC_New` "
"or :c:macro:`PyObject_GC_NewVar`."
msgstr ""
"La función destructor es llamada por las macros :c:func:`Py_DECREF` "
"y :c:func:`Py_XDECREF` cuando el nuevo recuento de referencia es cero. En "
"este punto, la instancia todavía existe, pero no hay referencias a ella. La "
"función destructor debe liberar todas las referencias que posee la "
"instancia, liberar todos los búferes de memoria que posee la instancia "
"(utilizando la función de liberación correspondiente a la función de "
"asignación utilizada para asignar el búfer) y llamar a los tipos "
"función :c:member:`~PyTypeObject.tp_free`. Si el tipo no es subtipable (no "
"tiene establecido el bit de indicador :const:`Py_TPFLAGS_BASETYPE`), está "
"permitido llamar al objeto desasignador directamente en lugar de a través "
"de :c:member:`~PyTypeObject.tp_free`. El objeto desasignador debe ser el "
"utilizado para asignar la instancia; normalmente es :c:func:`PyObject_Del` "
"si la instancia se asignó usando :c:func:`PyObject_New` "
"o :c:func:`PyObject_VarNew`, o :c:func:`PyObject_GC_Del` si la instancia se "
"asignó usando :c:func:`PyObject_GC_New` o :c:func:`PyObject_GC_NewVar`."

#: ../Doc/c-api/typeobj.rst:658
#, fuzzy
msgid ""
"If the type supports garbage collection (has "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit set), the destructor should "
"call :c:func:`PyObject_GC_UnTrack` before clearing any member fields."
msgstr ""
"Si el tipo admite la recolección de elementos no utilizados (tiene "
"establecido el bit indicador :const:`Py_TPFLAGS_HAVE_GC`), el destructor "
"debe llamar a :c:func:`PyObject_GC_UnTrack` antes de borrar cualquier campo "
"miembro."

#: ../Doc/c-api/typeobj.rst:662
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyObject_GC_UnTrack(self);\n"
"    Py_CLEAR(self->ref);\n"
"    Py_TYPE(self)->tp_free((PyObject *)self);\n"
"}"
msgstr ""

#: ../Doc/c-api/typeobj.rst:670
#, fuzzy
msgid ""
"Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object "
"(via :c:func:`Py_DECREF`)  after calling the type deallocator. In order to "
"avoid dangling pointers, the recommended way to achieve this is:"
msgstr ""
"Finalmente, si el tipo está asignado en el heap "
"(:const:`Py_TPFLAGS_HEAPTYPE`), el desasignador debería disminuir el conteo "
"de referencia para su objeto tipo después de llamar al desasignador del "
"tipo. Para evitar punteros colgantes, la forma recomendada de lograr esto es:"

#: ../Doc/c-api/typeobj.rst:676
msgid ""
"static void foo_dealloc(foo_object *self) {\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"    // free references and buffers here\n"
"    tp->tp_free(self);\n"
"    Py_DECREF(tp);\n"
"}"
msgstr ""

#: ../Doc/c-api/typeobj.rst:693
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Un desplazamiento opcional a una función por instancia que implementa la "
"llamada al objeto usando :ref:`vectorcall protocol <vectorcall>`, una "
"alternativa más eficiente del simple :c:member:`~PyTypeObject.tp_call`."

#: ../Doc/c-api/typeobj.rst:698
#, fuzzy
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Este campo solo se usa si se establece el "
"flag :const:`Py_TPFLAGS_HAVE_VECTORCALL`. Si es así, debe ser un entero "
"positivo que contenga el desplazamiento en la instancia de un "
"puntero :c:type:`vectorcallfunc`."

#: ../Doc/c-api/typeobj.rst:702
#, fuzzy
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"El puntero *vectorcallfunc* puede ser ``NULL``, en cuyo caso la instancia se "
"comporta como si :const:`Py_TPFLAGS_HAVE_VECTORCALL` no estuviera "
"configurado: llamar a la instancia vuelve "
"a :c:member:`~PyTypeObject.tp_call`."

#: ../Doc/c-api/typeobj.rst:706
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also "
"set :c:member:`~PyTypeObject.tp_call` and make sure its behaviour is "
"consistent with the *vectorcallfunc* function. This can be done by setting "
"*tp_call* to :c:func:`PyVectorcall_Call`."
msgstr ""
"Cualquier clase que establezca ``_Py_TPFLAGS_HAVE_VECTORCALL`` también debe "
"establecer :c:member:`~PyTypeObject.tp_call` y asegurarse de que su "
"comportamiento sea coherente con la función *vectorcallfunc*. Esto se puede "
"hacer configurando *tp_call* en :c:func:`PyVectorcall_Call`."

#: ../Doc/c-api/typeobj.rst:713
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"Antes de la versión 3.8, este slot se llamaba ``tp_print``. En Python 2.x, "
"se usó para imprimir en un archivo. En Python 3.0 a 3.7, no se usó."

#: ../Doc/c-api/typeobj.rst:719
#, fuzzy
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user "
"sets :attr:`~object.__call__` in Python code, only *tp_call* is updated, "
"likely making it inconsistent with the vectorcall function. Since 3.12, "
"setting ``__call__`` will disable vectorcall optimization by clearing "
"the :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
"No se recomienda para :ref:`tipos heap <heap-types>` para implementar el "
"protocolo vectorcall. Cuando un usuario establece :attr:`__call__` en código "
"Python, solo se actualiza *tp_call*, lo que probablemente lo haga "
"inconsistente con la función vectorcall."

#: ../Doc/c-api/typeobj.rst:729
#, fuzzy
msgid ""
"This field is always inherited. However, "
"the :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If "
"it's not set, then the subclass won't use :ref:`vectorcall <vectorcall>`, "
"except when :c:func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"Este campo siempre se hereda. Sin embargo, la "
"bandera :const:`Py_TPFLAGS_HAVE_VECTORCALL` no siempre se hereda. Si no es "
"así, la subclase no usará :ref:`vectorcall <vectorcall>`, excepto cuando se "
"llame explícitamente a :c:func:`PyVectorcall_Call`. Este es en particular el "
"caso de :ref:`tipos heap <heap-types>` (incluidas las subclases definidas en "
"Python)."

#: ../Doc/c-api/typeobj.rst:738
msgid "An optional pointer to the get-attribute-string function."
msgstr ""
"Un puntero opcional a la función \"obtener atributo cadena de caracteres\" "
"(*get-attribute-string*)."

#: ../Doc/c-api/typeobj.rst:740
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está en desuso. Cuando se define, debe apuntar a una función que "
"actúe igual que la función :c:member:`~PyTypeObject.tp_getattro`, pero "
"tomando una cadena de caracteres C en lugar de un objeto de cadena Python "
"para dar el nombre del atributo."

#: ../Doc/c-api/typeobj.rst:746 ../Doc/c-api/typeobj.rst:942
#, fuzzy
msgid "Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject.tp_getattro`"
msgstr "Consulte :c:member:`~PyTypeObject.tp_getattro`."

#: ../Doc/c-api/typeobj.rst:748
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_getattro`: a subtype inherits "
"both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto "
"con :c:member:`~PyTypeObject.tp_getattro`: un subtipo hereda "
"ambos :c:member:`~PyTypeObject.tp_getattr` "
"y :c:member:`~PyTypeObject.tp_getattro` de su base escriba cuando los "
"subtipos :c:member:`~PyTypeObject.tp_getattr` "
"y :c:member:`~PyTypeObject.tp_getattro` son ambos ``NULL``."

#: ../Doc/c-api/typeobj.rst:755 ../Doc/c-api/typeobj.rst:955
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr "Un puntero opcional a la función para configurar y eliminar atributos."

#: ../Doc/c-api/typeobj.rst:757
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está en desuso. Cuando se define, debe apuntar a una función que "
"actúe igual que la función :c:member:`~PyTypeObject.tp_setattro`, pero "
"tomando una cadena de caracteres C en lugar de un objeto de cadena Python "
"para dar el nombre del atributo."

#: ../Doc/c-api/typeobj.rst:763 ../Doc/c-api/typeobj.rst:968
#, fuzzy
msgid "Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject.tp_setattro`"
msgstr "Consulte :c:member:`~PyTypeObject.tp_setattro`."

#: ../Doc/c-api/typeobj.rst:765
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_setattro`: a subtype inherits "
"both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto "
"con :c:member:`~PyTypeObject.tp_setattro`: un subtipo hereda "
"ambos :c:member:`~PyTypeObject.tp_setattr` "
"y :c:member:`~PyTypeObject.tp_setattro` de su base escriba cuando los "
"subtipos :c:member:`~PyTypeObject.tp_setattr` "
"y :c:member:`~PyTypeObject.tp_setattro` son ambos ``NULL``."

#: ../Doc/c-api/typeobj.rst:772
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes solo para "
"los objetos que implementan los protocolos \"esperable\" (:term:`awaitable`) "
"y \"iterador asíncrono\" (:term:`asynchronous iterator`) en el nivel C. "
"Ver :ref:`async-structs` para más detalles."

#: ../Doc/c-api/typeobj.rst:776
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Anteriormente conocidos como ``tp_compare`` y ``tp_reserved``."

#: ../Doc/c-api/typeobj.rst:781
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_async` no se hereda, pero los campos "
"contenidos se heredan individualmente."

#: ../Doc/c-api/typeobj.rst:789
msgid ""
"An optional pointer to a function that implements the built-in "
"function :func:`repr`."
msgstr ""
"Un puntero opcional a una función que implementa la función "
"incorporada :func:`repr`."

#: ../Doc/c-api/typeobj.rst:792
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Repr`::"

#: ../Doc/c-api/typeobj.rst:794
msgid "PyObject *tp_repr(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:796
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"La función debe retornar una cadena de caracteres o un objeto Unicode. "
"Idealmente, esta función debería retornar una cadena que, cuando se pasa "
"a :func:`eval`, dado un entorno adecuado, retorna un objeto con el mismo "
"valor. Si esto no es factible, debe retornar una cadena que comience con "
"``'<'`` y termine con ``'>'`` desde la cual se puede deducir tanto el tipo "
"como el valor del objeto."

#: ../Doc/c-api/typeobj.rst:807 ../Doc/c-api/typeobj.rst:886
#: ../Doc/c-api/typeobj.rst:923 ../Doc/c-api/typeobj.rst:948
#: ../Doc/c-api/typeobj.rst:974 ../Doc/c-api/typeobj.rst:1015
#: ../Doc/c-api/typeobj.rst:1570 ../Doc/c-api/typeobj.rst:1604
#: ../Doc/c-api/typeobj.rst:1721 ../Doc/c-api/typeobj.rst:1754
#: ../Doc/c-api/typeobj.rst:1829 ../Doc/c-api/typeobj.rst:1870
#: ../Doc/c-api/typeobj.rst:1888 ../Doc/c-api/typeobj.rst:1930
#: ../Doc/c-api/typeobj.rst:1951 ../Doc/c-api/typeobj.rst:1982
msgid "**Default:**"
msgstr "**Por defecto:**"

#: ../Doc/c-api/typeobj.rst:809
#, python-format
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Cuando este campo no está configurado, se retorna una cadena de caracteres "
"de la forma ``<%s object at %p>``, donde ``%s`` se reemplaza por el nombre "
"del tipo y ``%p`` por dirección de memoria del objeto."

#: ../Doc/c-api/typeobj.rst:816
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes solo para "
"objetos que implementan el protocolo numérico. Estos campos están "
"documentados en :ref:`number-structs`."

#: ../Doc/c-api/typeobj.rst:822
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_number` no se hereda, pero los "
"campos contenidos se heredan individualmente."

#: ../Doc/c-api/typeobj.rst:828
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes solo para "
"objetos que implementan el protocolo de secuencia. Estos campos están "
"documentados en :ref:`estructuras de secuencia <sequence-structs>`."

#: ../Doc/c-api/typeobj.rst:834
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_sequence` no se hereda, pero los "
"campos contenidos se heredan individualmente."

#: ../Doc/c-api/typeobj.rst:840
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes solo para "
"objetos que implementan el protocolo de mapeo. Estos campos están "
"documentados en :ref:`mapping-structs`."

#: ../Doc/c-api/typeobj.rst:846
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_mapping` no se hereda, pero los "
"campos contenidos se heredan individualmente."

#: ../Doc/c-api/typeobj.rst:854
msgid ""
"An optional pointer to a function that implements the built-in "
"function :func:`hash`."
msgstr ""
"Un puntero opcional a una función que implementa la función "
"incorporada :func:`hash`."

#: ../Doc/c-api/typeobj.rst:857
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Hash`::"

#: ../Doc/c-api/typeobj.rst:859
msgid "Py_hash_t tp_hash(PyObject *);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:861
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"El valor ``-1`` no debe retornarse como un valor de retorno normal; Cuando "
"se produce un error durante el cálculo del valor *hash*, la función debe "
"establecer una excepción y retornar ``-1``."

#: ../Doc/c-api/typeobj.rst:865
#, fuzzy
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object "
"raises :exc:`TypeError`. This is the same as setting it "
"to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"Cuando este campo no está establecido (*y* :attr:`tp_richcompare` no está "
"establecido), se lanza :exc:`TypeError` cuando hay un intento de tomar el "
"*hash* del objeto. Esto es lo mismo que establecerlo "
"en :c:func:`PyObject_HashNotImplemented`."

#: ../Doc/c-api/typeobj.rst:869
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set "
"to :c:func:`PyObject_HashNotImplemented`."
msgstr ""
"Este campo se puede establecer explícitamente "
"en :c:func:`PyObject_HashNotImplemented` para bloquear la herencia del "
"método *hash* de un tipo primario. Esto se interpreta como el equivalente de "
"``__hash__ = None`` en el nivel de Python, lo que hace que ``isinstance(o, "
"collections.Hashable)`` retorne correctamente ``False``. Tenga en cuenta que "
"lo contrario también es cierto: establecer ``__hash__ = None`` en una clase "
"en el nivel de Python dará como resultado que la ranura ``tp_hash`` se "
"establezca en :c:func:`PyObject_HashNotImplemented`."

#: ../Doc/c-api/typeobj.rst:879 ../Doc/c-api/typeobj.rst:1563
#, fuzzy
msgid "Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject.tp_richcompare`"
msgstr "Consulte :c:member:`~PyTypeObject.tp_richcompare`."

#: ../Doc/c-api/typeobj.rst:881
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_richcompare`: a subtype inherits both "
"of :c:member:`~PyTypeObject.tp_richcompare` "
"and :c:member:`~PyTypeObject.tp_hash`, when the "
"subtype's :c:member:`~PyTypeObject.tp_richcompare` "
"and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Este campo es heredado por subtipos junto "
"con :c:member:`~PyTypeObject.tp_richcompare`: un subtipo hereda "
"ambos :c:member:`~PyTypeObject.tp_richcompare` "
"y :c:member:`~PyTypeObject.tp_hash`, cuando los "
"subtipos :c:member:`~PyTypeObject.tp_richcompare` "
"y :c:member:`~PyTypeObject.tp_hash` son ambos ``NULL``."

#: ../Doc/c-api/typeobj.rst:888
#, fuzzy
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:type:`PyBaseObject_Type` usa :c:func:`PyObject_GenericSetAttr`."

#: ../Doc/c-api/typeobj.rst:893
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Un puntero opcional a una función que implementa la llamada al objeto. Esto "
"debería ser ``NULL`` si el objeto no es invocable. La firma es la misma que "
"para :c:func:`PyObject_Call`::"

#: ../Doc/c-api/typeobj.rst:897
msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:906
msgid ""
"An optional pointer to a function that implements the built-in "
"operation :func:`str`.  (Note that :class:`str` is a type now, "
"and :func:`str` calls the constructor for that type.  This constructor "
"calls :c:func:`PyObject_Str` to do the actual work, "
"and :c:func:`PyObject_Str` will call this handler.)"
msgstr ""
"Un puntero opcional a una función que implementa la operación "
"integrada :func:`str`. (Tenga en cuenta que :class:`str` es un tipo ahora, "
"y :func:`str` llama al constructor para ese tipo. Este constructor llama "
"a :c:func:`PyObject_Str` para hacer el trabajo real, "
"y :c:func:`PyObject_Str` llamará a este controlador.)"

#: ../Doc/c-api/typeobj.rst:911
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "La firma es la misma que para :c:func:`PyObject_Str`::"

#: ../Doc/c-api/typeobj.rst:913
msgid "PyObject *tp_str(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:915
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"La función debe retornar una cadena de caracteres o un objeto Unicode. Debe "
"ser una representación de cadena \"amigable\" del objeto, ya que esta es la "
"representación que será utilizada, entre otras cosas, por la "
"función :func:`print`."

#: ../Doc/c-api/typeobj.rst:925
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Cuando este campo no está configurado, se llama a :c:func:`PyObject_Repr` "
"para retornar una representación de cadena de caracteres."

#: ../Doc/c-api/typeobj.rst:931
msgid "An optional pointer to the get-attribute function."
msgstr ""
"Un puntero opcional a la función \"obtener atributo\" (*get-attribute*)."

#: ../Doc/c-api/typeobj.rst:933
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_GetAttr`::"

#: ../Doc/c-api/typeobj.rst:935
msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:937
msgid ""
"It is usually convenient to set this field "
"to :c:func:`PyObject_GenericGetAttr`, which implements the normal way of "
"looking for object attributes."
msgstr ""
"Por lo general, es conveniente establecer este campo "
"en :c:func:`PyObject_GenericGetAttr`, que implementa la forma normal de "
"buscar atributos de objeto."

#: ../Doc/c-api/typeobj.rst:944
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_getattr`: a subtype inherits "
"both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` are both ``NULL``."
msgstr ""
"Este campo es heredado por los subtipos junto "
"con :c:member:`~PyTypeObject.tp_getattr`: un subtipo hereda "
"ambos :c:member:`~PyTypeObject.tp_getattr` "
"y :c:member:`~PyTypeObject.tp_getattro` de su base escriba cuando los "
"subtipos :c:member:`~PyTypeObject.tp_getattr` "
"y :c:member:`~PyTypeObject.tp_getattro` son ambos ``NULL``."

#: ../Doc/c-api/typeobj.rst:950
#, fuzzy
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ":c:type:`PyBaseObject_Type` usa :c:func:`PyObject_GenericGetAttr`."

#: ../Doc/c-api/typeobj.rst:957
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "La firma es la misma que para :c:func:`PyObject_SetAttr`::"

#: ../Doc/c-api/typeobj.rst:959
msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:961
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field "
"to :c:func:`PyObject_GenericSetAttr`, which implements the normal way of "
"setting object attributes."
msgstr ""
"Además, se debe admitir la configuración de *value* en ``NULL`` para "
"eliminar un atributo. Por lo general, es conveniente establecer este campo "
"en :c:func:`PyObject_GenericSetAttr`, que implementa la forma normal de "
"establecer los atributos del objeto."

#: ../Doc/c-api/typeobj.rst:970
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_setattr`: a subtype inherits "
"both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` are both ``NULL``."
msgstr ""
"Los subtipos heredan este campo junto "
"con :c:member:`~PyTypeObject.tp_setattr`: un subtipo hereda "
"ambos :c:member:`~PyTypeObject.tp_setattr` "
"y :c:member:`~PyTypeObject.tp_setattro` de su base escriba cuando los "
"subtipos :c:member:`~PyTypeObject.tp_setattr` "
"y :c:member:`~PyTypeObject.tp_setattro` son ambos ``NULL``."

#: ../Doc/c-api/typeobj.rst:976
#, fuzzy
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ":c:type:`PyBaseObject_Type` usa :c:func:`PyObject_GenericSetAttr`."

#: ../Doc/c-api/typeobj.rst:981
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Puntero a una estructura adicional que contiene campos relevantes solo para "
"objetos que implementan la interfaz del búfer. Estos campos están "
"documentados en :ref:`buffer-structs`."

#: ../Doc/c-api/typeobj.rst:987
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"El campo :c:member:`~PyTypeObject.tp_as_buffer` no se hereda, pero los "
"campos contenidos se heredan individualmente."

#: ../Doc/c-api/typeobj.rst:993
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced "
"via :c:member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, "
"and :c:member:`~PyTypeObject.tp_as_buffer`) that were historically not "
"always present are valid; if such a flag bit is clear, the type fields it "
"guards must not be accessed and must be considered to have a zero or "
"``NULL`` value instead."
msgstr ""
"Este campo es una máscara de bits de varias banderas. Algunas banderas "
"indican semántica variante para ciertas situaciones; otros se utilizan para "
"indicar que ciertos campos en el tipo de objeto (o en las estructuras de "
"extensión a las que se hace referencia a través "
"de :c:member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, "
"y :c:member:`~PyTypeObject.tp_as_buffer`) que históricamente no siempre "
"estuvieron presentes son válidos; si dicho bit de bandera está claro, no se "
"debe acceder a los campos de tipo que protege y se debe considerar que "
"tienen un valor cero o ``NULL``."

#: ../Doc/c-api/typeobj.rst:1003
#, fuzzy
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and "
"the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have "
"``NULL`` values. .. XXX are most flag bits *really* inherited individually?"
msgstr ""
"La herencia de este campo es complicada. La mayoría de los bits de bandera "
"se heredan individualmente, es decir, si el tipo base tiene un conjunto de "
"bits de bandera, el subtipo hereda este bit de bandera. Los bits de bandera "
"que pertenecen a las estructuras de extensión se heredan estrictamente si la "
"estructura de extensión se hereda, es decir, el valor del tipo base del bit "
"de bandera se copia en el subtipo junto con un puntero a la estructura de "
"extensión. El bit de bandera :const:`Py_TPFLAGS_HAVE_GC` se hereda junto "
"con :c:member:`~PyTypeObject.tp_traverse` "
"y :c:member:`~PyTypeObject.tp_clear`, es decir, si el bit de "
"bandera :const:`Py_TPFLAGS_HAVE_GC` está claro en el subtipo y los "
"campos :c:member:`~PyTypeObject.tp_traverse` "
"y :c:member:`~PyTypeObject.tp_clear` en el subtipo existen y tienen valores "
"``NULL``."

#: ../Doc/c-api/typeobj.rst:1017
#, fuzzy
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:type:`PyBaseObject_Type` usa ``Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE``."

#: ../Doc/c-api/typeobj.rst:1020
msgid "**Bit Masks:**"
msgstr "**Máscaras de bits:**"

#: ../Doc/c-api/typeobj.rst:1024
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of "
"the :c:member:`~PyTypeObject.tp_flags` field.  The "
"macro :c:func:`PyType_HasFeature` takes a type and a flags value, *tp* and "
"*f*, and checks whether ``tp->tp_flags & f`` is non-zero."
msgstr ""
"Las siguientes máscaras de bits están definidas actualmente; estos se pueden "
"unidos por *OR* usando el operador ``|`` para formar el valor del "
"campo :c:member:`~PyTypeObject.tp_flags`. El "
"macro :c:func:`PyType_HasFeature` toma un tipo y un valor de banderas, *tp* "
"y *f*, y comprueba si ``tp->tp_flags & f`` no es cero."

#: ../Doc/c-api/typeobj.rst:1031
#, fuzzy
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :c:member:`~PyObject.ob_type` field of its instances is considered "
"a reference to the type, and the type object is INCREF'ed when a new "
"instance is created, and DECREF'ed when an instance is destroyed (this does "
"not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should "
"also :ref:`support garbage collection <supporting-cycle-detection>` as they "
"can form a reference cycle with their own module object."
msgstr ""
"Este bit se establece cuando el objeto de tipo se asigna en el heap, por "
"ejemplo, los tipos creados dinámicamente usando :c:func:`PyType_FromSpec`. "
"En este caso, el campo :attr:`ob_type` de sus instancias se considera una "
"referencia al tipo, y el objeto de tipo se llama *INCREF* cuando se crea una "
"nueva instancia, y DECREF cuando se destruye una instancia (esto hace no se "
"aplica a instancias de subtipos; solo el tipo al que hace referencia el "
"*ob_type* de la instancia obtiene INCREF o DECREF)."

#: ../Doc/c-api/typeobj.rst:1042 ../Doc/c-api/typeobj.rst:1053
#: ../Doc/c-api/typeobj.rst:1063 ../Doc/c-api/typeobj.rst:1073
#: ../Doc/c-api/typeobj.rst:1105
msgid "???"
msgstr "???"

#: ../Doc/c-api/typeobj.rst:1047
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Este bit se establece cuando el tipo se puede usar como el tipo base de otro "
"tipo. Si este bit es claro, el tipo no puede subtiparse (similar a una clase "
"\"final\" en Java)."

#: ../Doc/c-api/typeobj.rst:1058
msgid ""
"This bit is set when the type object has been fully initialized "
"by :c:func:`PyType_Ready`."
msgstr ""
"Este bit se establece cuando el objeto tipo ha sido completamente "
"inicializado por :c:func:`PyType_Ready`."

#: ../Doc/c-api/typeobj.rst:1068
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Este bit se establece mientras :c:func:`PyType_Ready` está en el proceso de "
"inicialización del objeto tipo."

#: ../Doc/c-api/typeobj.rst:1078
#, fuzzy
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:macro:`PyObject_GC_New` and "
"destroyed using :c:func:`PyObject_GC_Del`.  More information in "
"section :ref:`supporting-cycle-detection`.  This bit also implies that the "
"GC-related fields :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` are present in the type object."
msgstr ""
"Este bit se establece cuando el objeto admite la recolección de elementos no "
"utilizados. Si se establece este bit, las instancias deben crearse "
"usando :c:func:`PyObject_GC_New` y destruirse "
"usando :c:func:`PyObject_GC_Del`. Más información en la "
"sección :ref:`supporting-cycle-detection`. Este bit también implica que los "
"campos relacionados con GC :c:member:`~PyTypeObject.tp_traverse` "
"y :c:member:`~PyTypeObject.tp_clear` están presentes en el objeto de tipo."

#: ../Doc/c-api/typeobj.rst:1087 ../Doc/c-api/typeobj.rst:1428
#: ../Doc/c-api/typeobj.rst:1502
#, fuzzy
msgid "Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr "Grupo: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`"

#: ../Doc/c-api/typeobj.rst:1089
#, fuzzy
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with "
"the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e.  if "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and "
"the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have "
"``NULL`` values."
msgstr ""
"El bit de indicador :const:`Py_TPFLAGS_HAVE_GC` se hereda junto con los "
"campos :attr:`tp_traverse` y :attr:`tp_clear`, es decir, si el bit de "
"indicador :const:`Py_TPFLAGS_HAVE_GC` está claro en el subtipo y los "
"campos :attr:`tp_traverse` y :attr:`tp_clear` en el subtipo existen y tienen "
"valores ``NULL``."

#: ../Doc/c-api/typeobj.rst:1099
#, fuzzy
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Esta es una máscara de bits de todos los bits que pertenecen a la existencia "
"de ciertos campos en el objeto de tipo y sus estructuras de extensión. "
"Actualmente, incluye los siguientes "
"bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

#: ../Doc/c-api/typeobj.rst:1110
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""
"Este bit indica que los objetos se comportan como métodos independientes."

#: ../Doc/c-api/typeobj.rst:1112
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Si este indicador está configurado para ``type(meth)``, entonces:"

#: ../Doc/c-api/typeobj.rst:1114
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (con ``obj`` no ``None``) debe ser "
"equivalente a ``meth(obj, *args, **kwds)``."

#: ../Doc/c-api/typeobj.rst:1117
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` debe ser equivalente a "
"``meth(*args, **kwds)``."

#: ../Doc/c-api/typeobj.rst:1120
msgid ""
"This flag enables an optimization for typical method calls like "
"``obj.meth()``: it avoids creating a temporary \"bound method\" object for "
"``obj.meth``."
msgstr ""
"Este indicador (*flag*) permite una optimización para llamadas a métodos "
"típicos como ``obj.meth()``: evita crear un objeto temporal de \"método "
"vinculado\" para ``obj.meth``."

#: ../Doc/c-api/typeobj.rst:1128
#, fuzzy
msgid ""
"This flag is never inherited by types without "
"the :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it "
"is inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"Esta bandera nunca es heredada por :ref:`tipos heap <heap-types>`. Para los "
"tipos de extensión, se hereda siempre que se "
"hereda :c:member:`~PyTypeObject.tp_descr_get`."

#: ../Doc/c-api/typeobj.rst:1134
msgid ""
"This bit indicates that instances of the class have a `~object.__dict__` "
"attribute, and that the space for the dictionary is managed by the VM."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1137
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1139
msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` and "
"its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1146
#, fuzzy
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr ""
"Este campo está en desuso. Use :c:member:`~PyTypeObject.tp_finalize` en su "
"lugar."

#: ../Doc/c-api/typeobj.rst:1152
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1159
#, fuzzy
msgid ""
"This flag is inherited unless "
"the :c:member:`~PyTypeObject.tp_weaklistoffset` field is set in a superclass."
msgstr ""
"Este campo está en desuso. Use :c:member:`~PyTypeObject.tp_finalize` en su "
"lugar."

#: ../Doc/c-api/typeobj.rst:1165
msgid ""
"Only usable with variable-size types, i.e. ones with non-"
"zero :c:member:`~PyTypeObject.tp_itemsize`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1168
msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of ``Py_TYPE(obj)-"
">tp_basicsize`` (which may be different in each subclass)."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1173
msgid ""
"When setting this flag, be sure that all superclasses either use this memory "
"layout, or are not variable-sized. Python does not check this."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1181
#, fuzzy
msgid "This flag is inherited."
msgstr "Este flag no se hereda."

#: ../Doc/c-api/typeobj.rst:1195
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have "
"their :c:member:`~PyTypeObject.tp_flags` set appropriately, or the code that "
"interacts with such types will behave differently depending on what kind of "
"check is used."
msgstr ""
"Estas marcas son utilizadas por funciones como :c:func:`PyLong_Check` para "
"determinar rápidamente si un tipo es una subclase de un tipo incorporado; "
"dichos controles específicos son más rápidos que un control genérico, "
"como :c:func:`PyObject_IsInstance`. Los tipos personalizados que heredan de "
"los elementos integrados deben tener su :c:member:`~PyTypeObject.tp_flags` "
"configurado correctamente, o el código que interactúa con dichos tipos se "
"comportará de manera diferente dependiendo del tipo de verificación que se "
"use."

#: ../Doc/c-api/typeobj.rst:1206
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Este bit se establece cuando la ranura :c:member:`~PyTypeObject.tp_finalize` "
"está presente en la estructura de tipo."

#: ../Doc/c-api/typeobj.rst:1211
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes "
"the :c:member:`~PyTypeObject.tp_finalize` slot is always present in the type "
"structure."
msgstr ""
"Este indicador ya no es necesario, ya que el intérprete asume que: el "
"espacio :c:member:`~PyTypeObject.tp_finalize` siempre está presente en la "
"estructura de tipos."

#: ../Doc/c-api/typeobj.rst:1219
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Este bit se establece cuando la clase implementa :ref:`protocolo vectorcall "
"<vectorcall>`. Consulte :c:member:`~PyTypeObject.tp_vectorcall_offset` para "
"obtener más detalles."

#: ../Doc/c-api/typeobj.rst:1225
#, fuzzy
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr ""
"Este campo está en desuso. Use :c:member:`~PyTypeObject.tp_finalize` en su "
"lugar."

#: ../Doc/c-api/typeobj.rst:1232
msgid ""
"This flag is now removed from a class when the "
"class's :py:meth:`~object.__call__` method is reassigned."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1235
#, fuzzy
msgid "This flag can now be inherited by mutable classes."
msgstr "Este campo no es heredado por los subtipos."

#: ../Doc/c-api/typeobj.rst:1239
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Este bit se establece para objetos de tipo que son inmutables: los atributos "
"de tipo no se pueden establecer ni eliminar."

#: ../Doc/c-api/typeobj.rst:1241
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` aplica automáticamente este indicador a :ref:`static "
"types <static-types>`."

#: ../Doc/c-api/typeobj.rst:1246
msgid "This flag is not inherited."
msgstr "Este flag no se hereda."

#: ../Doc/c-api/typeobj.rst:1252
msgid ""
"Disallow creating instances of the type: "
"set :c:member:`~PyTypeObject.tp_new` to NULL and don't create the "
"``__new__`` key in the type dictionary."
msgstr ""
"No permita la creación de instancias del tipo: "
"establezca :c:member:`~PyTypeObject.tp_new` en NULL y no cree la clave "
"``__new__`` en el diccionario de tipos."

#: ../Doc/c-api/typeobj.rst:1256
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"La bandera debe establecerse antes de crear el tipo, no después. Por "
"ejemplo, debe establecerse antes de que se llame a :c:func:`PyType_Ready` en "
"el tipo."

#: ../Doc/c-api/typeobj.rst:1259
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` "
"if :c:member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` "
"and :c:member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"La bandera se establece automáticamente en :ref:`static types <static-"
"types>` si :c:member:`~PyTypeObject.tp_base` es NULL o "
"``&PyBaseObject_Type`` y :c:member:`~PyTypeObject.tp_new` es NULL."

#: ../Doc/c-api/typeobj.rst:1265
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1272
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1283
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Este bit indica que las instancias de la clase pueden coincidir con los "
"patrones de correspondencia cuando se utilizan como sujeto de un "
"bloque :keyword:`match`. Se configura automáticamente al registrar o "
"subclasificar :class:`collections.abc.Mapping`, y se desarma al "
"registrar :class:`collections.abc.Sequence`."

#: ../Doc/c-api/typeobj.rst:1290 ../Doc/c-api/typeobj.rst:1312
#, fuzzy
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":const:`Py_TPFLAGS_MAPPING` y :const:`Py_TPFLAGS_SEQUENCE` se excluyen "
"mutuamente; es un error habilitar ambos indicadores simultáneamente."

#: ../Doc/c-api/typeobj.rst:1295
#, fuzzy
msgid ""
"This flag is inherited by types that do not already "
"set :c:macro:`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Esta bandera la heredan los tipos que aún no "
"configuran :const:`Py_TPFLAGS_SEQUENCE`."

#: ../Doc/c-api/typeobj.rst:1298 ../Doc/c-api/typeobj.rst:1320
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` - Coincidencia de patrones estructurales: especificación"

#: ../Doc/c-api/typeobj.rst:1305
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Este bit indica que las instancias de la clase pueden coincidir con los "
"patrones de secuencia cuando se utilizan como sujeto de un "
"bloque :keyword:`match`. Se configura automáticamente al registrar o "
"subclasificar :class:`collections.abc.Sequence`, y se desarma al "
"registrar :class:`collections.abc.Mapping`."

#: ../Doc/c-api/typeobj.rst:1317
#, fuzzy
msgid ""
"This flag is inherited by types that do not already "
"set :c:macro:`Py_TPFLAGS_MAPPING`."
msgstr ""
"Esta bandera la heredan los tipos que aún no "
"configuran :const:`Py_TPFLAGS_MAPPING`."

#: ../Doc/c-api/typeobj.rst:1327
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1331
msgid ""
"This flag is present in header files, but is not be used. It will be removed "
"in a future version of CPython"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1337
#, fuzzy
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`~type.__doc__` attribute on "
"the type and instances of the type."
msgstr ""
"Un puntero opcional a una cadena de caracteres de C terminada en ``NULL`` "
"que proporciona la cadena de documentación para este tipo de objeto. Esto se "
"expone como el atributo :attr:`__doc__` en el tipo y las instancias del tipo."

#: ../Doc/c-api/typeobj.rst:1343
msgid "This field is *not* inherited by subtypes."
msgstr "Este campo es *no* heredado por los subtipos."

#: ../Doc/c-api/typeobj.rst:1348
#, fuzzy
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Un puntero opcional a una función transversal para el recolector de basura. "
"Esto solo se usa si se establece el bit de la bandera "
"(*flag*) :const:`Py_TPFLAGS_HAVE_GC`. La firma es::"

#: ../Doc/c-api/typeobj.rst:1351
msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1353 ../Doc/c-api/typeobj.rst:1497
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Se puede encontrar más información sobre el esquema de recolección de basura "
"de Python en la sección :ref:`supporting-cycle-detection`."

#: ../Doc/c-api/typeobj.rst:1356
#, fuzzy
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of "
"a :c:member:`~PyTypeObject.tp_traverse` function simply "
"calls :c:func:`Py_VISIT` on each of the instance's members that are Python "
"objects that the instance owns. For example, this is function :c:func:`!"
"local_traverse` from the :mod:`!_thread` extension module::"
msgstr ""
"El puntero :c:member:`~PyTypeObject.tp_traverse` es utilizado por el "
"recolector de basura para detectar ciclos de referencia. Una implementación "
"típica de un :c:member:`~PyTypeObject.tp_traverse` simplemente llama "
"a :c:func:`Py_VISIT` en cada uno de los miembros de la instancia que son "
"objetos de Python que posee la instancia. Por ejemplo, esta es la "
"función :c:func:`local_traverse` del módulo de extensión :mod:`_thread`::"

#: ../Doc/c-api/typeobj.rst:1362
msgid ""
"static int\n"
"local_traverse(localobject *self, visitproc visit, void *arg)\n"
"{\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1371
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Tenga en cuenta que :c:func:`Py_VISIT` solo se llama a aquellos miembros que "
"pueden participar en los ciclos de referencia. Aunque también hay un miembro "
"``self->key``, solo puede ser ``NULL`` o una cadena de caracteres de Python "
"y, por lo tanto, no puede ser parte de un ciclo de referencia."

#: ../Doc/c-api/typeobj.rst:1375
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"Por otro lado, incluso si sabe que un miembro nunca puede ser parte de un "
"ciclo, como ayuda para la depuración puede visitarlo de todos modos solo "
"para que la función :func:`~gc.get_referents` del módulo :mod:`gc` lo "
"incluirá."

#: ../Doc/c-api/typeobj.rst:1379
msgid ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1381
msgid "Py_VISIT(Py_TYPE(self));"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1383
msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this "
"line must be conditional::"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1386
msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1390
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in "
"the :c:member:`~PyTypeObject.tp_flags` field, the traverse function must "
"call :c:func:`PyObject_VisitManagedDict` like this::"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1394
msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1397
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Al implementar :c:member:`~PyTypeObject.tp_traverse`, solo se deben visitar "
"los miembros que tienen la instancia *owns* (por tener :term:`referencias "
"fuertes <strong reference>`). Por ejemplo, si un objeto admite referencias "
"débiles a través de la ranura :c:member:`~PyTypeObject.tp_weaklist`, el "
"puntero que respalda la lista vinculada (a lo que apunta *tp_weaklist*) "
"**no** debe visitarse ya que la instancia no posee directamente las "
"referencias débiles a sí misma (la lista de referencias débiles está ahí "
"para respaldar la maquinaria de referencia débil, pero la instancia no tiene "
"una fuerte referencia a los elementos dentro de ella, ya que pueden "
"eliminarse incluso si la instancia todavía está viva)."

#: ../Doc/c-api/typeobj.rst:1408
#, fuzzy
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters "
"to :c:func:`!local_traverse` to have these specific names; don't name them "
"just anything."
msgstr ""
"Tenga en cuenta que :c:func:`Py_VISIT` requiere los parámetros *visit* y "
"*arg* para :c:func:`local_traverse` para tener estos nombres específicos; no "
"les llames de ninguna manera."

#: ../Doc/c-api/typeobj.rst:1412
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either "
"visit :c:func:`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by "
"calling ``tp_traverse`` of another heap-allocated type (such as a heap-"
"allocated superclass). If they do not, the type object may not be garbage-"
"collected."
msgstr ""
"Las instancias de :ref:`heap-allocated types <heap-types>` contienen una "
"referencia a su tipo. Por lo tanto, su función transversal debe "
"visitar :c:func:`Py_TYPE(self) <Py_TYPE>` o delegar esta responsabilidad "
"llamando a ``tp_traverse`` de otro tipo asignado al heap (como una "
"superclase asignada al heap). Si no es así, es posible que el objeto de tipo "
"no se recolecte como basura."

#: ../Doc/c-api/typeobj.rst:1421
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Se espera que los tipos asignados al heap visiten ``Py_TYPE(self)`` en "
"``tp_traverse``. En versiones anteriores de Python, debido al `bug 40217 "
"<https://bugs.python.org/issue40217>`_, hacer esto puede provocar fallas en "
"las subclases."

#: ../Doc/c-api/typeobj.rst:1430
#, fuzzy
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_clear` and "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag "
"bit, :c:member:`~PyTypeObject.tp_traverse`, "
"and :c:member:`~PyTypeObject.tp_clear` are all inherited from the base type "
"if they are all zero in the subtype."
msgstr ""
"Este campo es heredado por los subtipos junto "
"con :c:member:`~PyTypeObject.tp_clear` y el :const:`Py_TPFLAGS_HAVE_GC` bit "
"de bandera: el bit de bandera, :c:member:`~PyTypeObject.tp_traverse`, "
"y :c:member:`~PyTypeObject.tp_clear` se heredan todos del tipo base si todos "
"son cero en el subtipo."

#: ../Doc/c-api/typeobj.rst:1438
#, fuzzy
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Un puntero opcional a una función de limpieza (*clear function*) para el "
"recolector de basura. Esto solo se usa si se establece el bit de "
"bandera :const:`Py_TPFLAGS_HAVE_GC`. La firma es::"

#: ../Doc/c-api/typeobj.rst:1441
msgid "int tp_clear(PyObject *);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1443
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` member function is used to break "
"reference cycles in cyclic garbage detected by the garbage collector.  Taken "
"together, all :c:member:`~PyTypeObject.tp_clear` functions in the system "
"must combine to break all reference cycles.  This is subtle, and if in any "
"doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For example, "
"the tuple type does not implement a :c:member:`~PyTypeObject.tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore "
"the :c:member:`~PyTypeObject.tp_clear` functions of other types must be "
"sufficient to break any cycle containing a tuple.  This isn't immediately "
"obvious, and there's rarely a good reason to avoid "
"implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"La función miembro :c:member:`~PyTypeObject.tp_clear` se usa para romper los "
"ciclos de referencia en la basura cíclica detectada por el recolector de "
"basura. En conjunto, todas las funciones :c:member:`~PyTypeObject.tp_clear` "
"en el sistema deben combinarse para romper todos los ciclos de referencia. "
"Esto es sutil y, en caso de duda, proporcione una "
"función :c:member:`~PyTypeObject.tp_clear`. Por ejemplo, el tipo de tupla no "
"implementa una función :c:member:`~PyTypeObject.tp_clear`, porque es posible "
"demostrar que ningún ciclo de referencia puede estar compuesto completamente "
"de tuplas. Por lo tanto, las funciones :c:member:`~PyTypeObject.tp_clear` de "
"otros tipos deben ser suficientes para romper cualquier ciclo que contenga "
"una tupla. Esto no es inmediatamente obvio, y rara vez hay una buena razón "
"para evitar la implementación de :c:member:`~PyTypeObject.tp_clear`."

#: ../Doc/c-api/typeobj.rst:1453
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"Las implementaciones de :c:member:`~PyTypeObject.tp_clear` deberían "
"descartar las referencias de la instancia a las de sus miembros que pueden "
"ser objetos de Python, y establecer sus punteros a esos miembros en "
"``NULL``, como en el siguiente ejemplo::"

#: ../Doc/c-api/typeobj.rst:1457
msgid ""
"static int\n"
"local_clear(localobject *self)\n"
"{\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1467
#, fuzzy
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released "
"(via :c:func:`Py_DECREF`) until after the pointer to the contained object is "
"set to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"Se debe utilizar el macro :c:func:`Py_CLEAR`, porque borrar las referencias "
"es delicado: la referencia al objeto contenido no se debe disminuir hasta "
"después de que el puntero al objeto contenido se establezca en ``NULL``. "
"Esto se debe a que la disminución del conteo de referencias puede hacer que "
"el objeto contenido se convierta en basura, lo que desencadena una cadena de "
"actividad de recuperación que puede incluir la invocación de código "
"arbitrario de Python (debido a finalizadores o devoluciones de llamada de "
"reflujo débil, asociadas con el objeto contenido). Si es posible que dicho "
"código haga referencia a *self* nuevamente, es importante que el puntero al "
"objeto contenido sea ``NULL`` en ese momento, de modo que *self* sepa que el "
"objeto contenido ya no se puede usar. El macro :c:func:`Py_CLEAR` realiza "
"las operaciones en un orden seguro."

#: ../Doc/c-api/typeobj.rst:1479
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in "
"the :c:member:`~PyTypeObject.tp_flags` field, the traverse function must "
"call :c:func:`PyObject_ClearManagedDict` like this::"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1483
msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1485
msgid ""
"Note that :c:member:`~PyTypeObject.tp_clear` is not *always* called before "
"an instance is deallocated. For example, when reference counting is enough "
"to determine that an object is no longer used, the cyclic garbage collector "
"is not involved and :c:member:`~PyTypeObject.tp_dealloc` is called directly."
msgstr ""
"Tenga en cuenta que :c:member:`~PyTypeObject.tp_clear` no se llama *siempre* "
"antes de que se desasigne una instancia. Por ejemplo, cuando el recuento de "
"referencias es suficiente para determinar que un objeto ya no se utiliza, el "
"recolector de basura cíclico no está involucrado y se llama directamente "
"a :c:member:`~PyTypeObject.tp_dealloc`."

#: ../Doc/c-api/typeobj.rst:1491
msgid ""
"Because the goal of :c:member:`~PyTypeObject.tp_clear` functions is to break "
"reference cycles, it's not necessary to clear contained objects like Python "
"strings or Python integers, which can't participate in reference cycles. On "
"the other hand, it may be convenient to clear all contained Python objects, "
"and write the type's :c:member:`~PyTypeObject.tp_dealloc` function to "
"invoke :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Debido a que el objetivo de :c:member:`~PyTypeObject.tp_clear` es romper los "
"ciclos de referencia, no es necesario borrar objetos contenidos como cadenas "
"de caracteres de Python o enteros de Python, que no pueden participar en los "
"ciclos de referencia. Por otro lado, puede ser conveniente borrar todos los "
"objetos Python contenidos y escribir la "
"función :c:member:`~PyTypeObject.tp_dealloc` para "
"invocar :c:member:`~PyTypeObject.tp_clear`."

#: ../Doc/c-api/typeobj.rst:1504
#, fuzzy
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_traverse` and "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag "
"bit, :c:member:`~PyTypeObject.tp_traverse`, "
"and :c:member:`~PyTypeObject.tp_clear` are all inherited from the base type "
"if they are all zero in the subtype."
msgstr ""
"Este campo es heredado por subtipos junto "
"con :c:member:`~PyTypeObject.tp_traverse` y el :const:`Py_TPFLAGS_HAVE_GC` "
"bit de bandera: el bit de bandera, :c:member:`~PyTypeObject.tp_traverse`, "
"y :c:member:`~PyTypeObject.tp_clear` se heredan todos del tipo base si todos "
"son cero en el subtipo."

#: ../Doc/c-api/typeobj.rst:1512
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Un puntero opcional a la función de comparación enriquecida, cuya firma es::"

#: ../Doc/c-api/typeobj.rst:1514
msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1516
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"Se garantiza que el primer parámetro será una instancia del tipo definido "
"por :c:type:`PyTypeObject`."

#: ../Doc/c-api/typeobj.rst:1519
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"La función debería retornar el resultado de la comparación (generalmente "
"``Py_True`` o ``Py_False``). Si la comparación no está definida, debe "
"retornar ``Py_NotImplemented``, si se produce otro error, debe retornar "
"``NULL`` y establecer una condición de excepción."

#: ../Doc/c-api/typeobj.rst:1524
msgid ""
"The following constants are defined to be used as the third argument "
"for :c:member:`~PyTypeObject.tp_richcompare` and "
"for :c:func:`PyObject_RichCompare`:"
msgstr ""
"Las siguientes constantes se definen para ser utilizadas como el tercer "
"argumento para :c:member:`~PyTypeObject.tp_richcompare` y "
"para :c:func:`PyObject_RichCompare`:"

#: ../Doc/c-api/typeobj.rst:1530
msgid "Constant"
msgstr "Constante"

#: ../Doc/c-api/typeobj.rst:1530
msgid "Comparison"
msgstr "Comparación"

#: ../Doc/c-api/typeobj.rst:1532
msgid "``<``"
msgstr "``<``"

#: ../Doc/c-api/typeobj.rst:1534
msgid "``<=``"
msgstr "``<=``"

#: ../Doc/c-api/typeobj.rst:1536
msgid "``==``"
msgstr "``==``"

#: ../Doc/c-api/typeobj.rst:1538
msgid "``!=``"
msgstr "``!=``"

#: ../Doc/c-api/typeobj.rst:1540
msgid "``>``"
msgstr "``>``"

#: ../Doc/c-api/typeobj.rst:1542
msgid "``>=``"
msgstr "``>=``"

#: ../Doc/c-api/typeobj.rst:1545
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"El siguiente macro está definido para facilitar la escritura de funciones de "
"comparación enriquecidas:"

#: ../Doc/c-api/typeobj.rst:1549
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Retorna ``Py_True`` o ``Py_False`` de la función, según el resultado de una "
"comparación. ``VAL_A`` y ``VAL_B`` deben ser ordenados por operadores de "
"comparación C (por ejemplo, pueden ser enteros o punto flotantes de C). El "
"tercer argumento especifica la operación solicitada, como por "
"ejemplo :c:func:`PyObject_RichCompare`."

#: ../Doc/c-api/typeobj.rst:1555
msgid "The returned value is a new :term:`strong reference`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1557
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr ""
"En caso de error, establece una excepción y retorna ``NULL`` de la función."

#: ../Doc/c-api/typeobj.rst:1565
msgid ""
"This field is inherited by subtypes together "
"with :c:member:`~PyTypeObject.tp_hash`: a subtype "
"inherits :c:member:`~PyTypeObject.tp_richcompare` "
"and :c:member:`~PyTypeObject.tp_hash` when the "
"subtype's :c:member:`~PyTypeObject.tp_richcompare` "
"and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Este campo es heredado por subtipos junto "
"con :c:member:`~PyTypeObject.tp_hash`: un subtipo "
"hereda :c:member:`~PyTypeObject.tp_richcompare` "
"y :c:member:`~PyTypeObject.tp_hash` cuando el "
"subtipo :c:member:`~PyTypeObject.tp_richcompare` "
"y :c:member:`~PyTypeObject.tp_hash` son ambos ``NULL``."

#: ../Doc/c-api/typeobj.rst:1572
#, fuzzy
msgid ""
":c:data:`PyBaseObject_Type` provides "
"a :c:member:`~PyTypeObject.tp_richcompare` implementation, which may be "
"inherited.  However, if only :c:member:`~PyTypeObject.tp_hash` is defined, "
"not even the inherited function is used and instances of the type will not "
"be able to participate in any comparisons."
msgstr ""
":c:type:`PyBaseObject_Type` proporciona una "
"implementación :attr:`tp_richcompare`, que puede ser heredada. Sin embargo, "
"si solo se define :attr:`tp_hash`, ni siquiera se utiliza la función "
"heredada y las instancias del tipo no podrán participar en ninguna "
"comparación."

#: ../Doc/c-api/typeobj.rst:1581
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1584
#, fuzzy
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of "
"type :c:expr:`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Si las instancias de este tipo son débilmente referenciables, este campo es "
"mayor que cero y contiene el desplazamiento en la estructura de instancia "
"del encabezado de la lista de referencia débil (ignorando el encabezado GC, "
"si está presente); este desplazamiento es utilizado "
"por :c:func:`PyObject_ClearWeakRefs` y las "
"funciones :c:func:`PyWeakref_\\*`. La estructura de la instancia debe "
"incluir un campo de tipo :c:type:`PyObject*` que se inicializa en ``NULL``."

#: ../Doc/c-api/typeobj.rst:1591
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"No confunda este campo con :c:member:`~PyTypeObject.tp_weaklist`; ese es el "
"encabezado de la lista para referencias débiles al objeto de tipo en sí."

#: ../Doc/c-api/typeobj.rst:1594
#, fuzzy
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"Este bit se hereda para tipos con el indicador "
"establecido :const:`Py_TPFLAGS_IMMUTABLETYPE`, "
"si :c:member:`~PyTypeObject.tp_call` también se hereda."

#: ../Doc/c-api/typeobj.rst:1599
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Este campo es heredado por subtipos, pero consulte las reglas que se "
"enumeran a continuación. Un subtipo puede anular este desplazamiento; Esto "
"significa que el subtipo utiliza un encabezado de lista de referencia débil "
"diferente que el tipo base. Dado que el encabezado de la lista siempre se "
"encuentra a través de :c:member:`~PyTypeObject.tp_weaklistoffset`, esto no "
"debería ser un problema."

#: ../Doc/c-api/typeobj.rst:1606
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in "
"the :c:member:`~PyTypeObject.tp_flags` field, "
"then :c:member:`~PyTypeObject.tp_weaklistoffset` will be set to a negative "
"value, to indicate that it is unsafe to use this field."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1614
#, fuzzy
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type "
"are :term:`iterable` (although sequences may be iterable without this "
"function)."
msgstr ""
"Un puntero opcional a una función que retorna un iterador para el objeto. Su "
"presencia normalmente indica que las instancias de este tipo son iterables "
"(aunque las secuencias pueden ser iterables sin esta función)."

#: ../Doc/c-api/typeobj.rst:1618
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Esta función tiene la misma firma que :c:func:`PyObject_GetIter`::"

#: ../Doc/c-api/typeobj.rst:1620
msgid "PyObject *tp_iter(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1629
#, fuzzy
msgid ""
"An optional pointer to a function that returns the next item in "
"an :term:`iterator`. The signature is::"
msgstr ""
"Un puntero opcional a una función que retorna el siguiente elemento en un "
"iterador. La firma es::"

#: ../Doc/c-api/typeobj.rst:1632
msgid "PyObject *tp_iternext(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1634
msgid ""
"When the iterator is exhausted, it must return ``NULL``; "
"a :exc:`StopIteration` exception may or may not be set.  When another error "
"occurs, it must return ``NULL`` too.  Its presence signals that the "
"instances of this type are iterators."
msgstr ""
"Cuando el iterador está agotado, debe retornar ``NULL``; a la "
"excepción :exc:`StopIteration` puede o no establecerse. Cuando se produce "
"otro error, también debe retornar ``NULL``. Su presencia indica que las "
"instancias de este tipo son iteradores."

#: ../Doc/c-api/typeobj.rst:1639
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Los tipos de iterador también deberían definir la "
"función :c:member:`~PyTypeObject.tp_iter`, y esa función debería retornar la "
"instancia de iterador en sí (no una nueva instancia de iterador)."

#: ../Doc/c-api/typeobj.rst:1643
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Esta función tiene la misma firma que :c:func:`PyIter_Next`."

#: ../Doc/c-api/typeobj.rst:1652
msgid ""
"An optional pointer to a static ``NULL``-terminated array "
"of :c:type:`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Un puntero opcional a un arreglo estático terminado en ``NULL`` de "
"estructuras :c:type:`PyMethodDef`, declarando métodos regulares de este tipo."

#: ../Doc/c-api/typeobj.rst:1655
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Para cada entrada en el arreglo, se agrega una entrada al diccionario del "
"tipo (ver :c:member:`~PyTypeObject.tp_dict` a continuación) que contiene un "
"descriptor *method*."

#: ../Doc/c-api/typeobj.rst:1660
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Los subtipos no heredan este campo (los métodos se heredan mediante un "
"mecanismo diferente)."

#: ../Doc/c-api/typeobj.rst:1666
msgid ""
"An optional pointer to a static ``NULL``-terminated array "
"of :c:type:`PyMemberDef` structures, declaring regular data members (fields "
"or slots) of instances of this type."
msgstr ""
"Un puntero opcional a un arreglo estático terminado en ``NULL`` de "
"estructuras :c:type:`PyMemberDef`, declarando miembros de datos regulares "
"(campos o ranuras) de instancias de este tipo."

#: ../Doc/c-api/typeobj.rst:1670
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Para cada entrada en el arreglo, se agrega una entrada al diccionario del "
"tipo (ver :c:member:`~PyTypeObject.tp_dict` a continuación) que contiene un "
"descriptor *member*."

#: ../Doc/c-api/typeobj.rst:1675
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Los subtipos no heredan este campo (los miembros se heredan mediante un "
"mecanismo diferente)."

#: ../Doc/c-api/typeobj.rst:1681
msgid ""
"An optional pointer to a static ``NULL``-terminated array "
"of :c:type:`PyGetSetDef` structures, declaring computed attributes of "
"instances of this type."
msgstr ""
"Un puntero opcional a un arreglo estático terminado en ``NULL`` de "
"estructuras :c:type:`PyGetSetDef`, declarando atributos calculados de "
"instancias de este tipo."

#: ../Doc/c-api/typeobj.rst:1684
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Para cada entrada en el arreglo, se agrega una entrada al diccionario del "
"tipo (ver :c:member:`~PyTypeObject.tp_dict` a continuación) que contiene un "
"descriptor *getset*."

#: ../Doc/c-api/typeobj.rst:1689
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Este campo no es heredado por los subtipos (los atributos computados se "
"heredan a través de un mecanismo diferente)."

#: ../Doc/c-api/typeobj.rst:1695
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Un puntero opcional a un tipo base del que se heredan las propiedades de "
"tipo. En este nivel, solo se admite una herencia única; La herencia múltiple "
"requiere la creación dinámica de un objeto tipo llamando al metatipo."

#: ../Doc/c-api/typeobj.rst:1703
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"La inicialización de ranuras está sujeta a las reglas de inicialización de "
"globales. C99 requiere que los inicializadores sean \"constantes de "
"dirección\". Los designadores de funciones como :c:func:`PyType_GenericNew`, "
"con conversión implícita a un puntero, son constantes de dirección C99 "
"válidas."

#: ../Doc/c-api/typeobj.rst:1708
#, fuzzy
msgid ""
"However, the unary '&' operator applied to a non-static variable "
"like :c:data:`PyBaseObject_Type` is not required to produce an address "
"constant.  Compilers may support this (gcc does), MSVC does not. Both "
"compilers are strictly standard conforming in this particular behavior."
msgstr ""
"Sin embargo, el operador unario '&' aplicado a una variable no estática "
"como :c:func:`PyBaseObject_Type` no es necesario para producir una dirección "
"constante. Los compiladores pueden admitir esto (gcc lo hace), MSVC no. "
"Ambos compiladores son estrictamente estándar conforme a este comportamiento "
"particular."

#: ../Doc/c-api/typeobj.rst:1714
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"En consecuencia, :c:member:`~PyTypeObject.tp_base` debe establecerse en la "
"función *init* del módulo de extensión."

#: ../Doc/c-api/typeobj.rst:1719
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Este campo no es heredado por los subtipos (obviamente)."

#: ../Doc/c-api/typeobj.rst:1723
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"Este campo predeterminado es ``&PyBaseObject_Type`` (que para los "
"programadores de Python se conoce como el tipo :class:`objeto`)."

#: ../Doc/c-api/typeobj.rst:1729
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "El diccionario del tipo se almacena aquí por :c:func:`PyType_Ready`."

#: ../Doc/c-api/typeobj.rst:1731
#, fuzzy
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations "
"(like :meth:`~object.__add__`).  Once initialization for the type has "
"finished, this field should be treated as read-only."
msgstr ""
"Este campo normalmente debe inicializarse a ``NULL`` antes de llamar a "
"``PyType_Ready``; también se puede inicializar en un diccionario que "
"contiene atributos iniciales para el tipo. Una vez :c:func:`PyType_Ready` ha "
"inicializado el tipo, los atributos adicionales para el tipo pueden "
"agregarse a este diccionario solo si no corresponden a operaciones "
"sobrecargadas (como :meth:`__add__`)."

#: ../Doc/c-api/typeobj.rst:1739
msgid ""
"Some types may not store their dictionary in this slot. "
"Use :c:func:`PyType_GetDict` to retrieve the dictionary for an arbitrary "
"type."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1745
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. "
"Use :c:func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1751
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Este campo no es heredado por los subtipos (aunque los atributos definidos "
"aquí se heredan a través de un mecanismo diferente)."

#: ../Doc/c-api/typeobj.rst:1756
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Si este campo es ``NULL``, :c:func:`PyType_Ready` le asignará un nuevo "
"diccionario."

#: ../Doc/c-api/typeobj.rst:1761
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise "
"modify :c:member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"No es seguro usar :c:func:`PyDict_SetItem` en o modificar de otra manera "
"a :c:member:`~PyTypeObject.tp_dict` con el diccionario C-API."

#: ../Doc/c-api/typeobj.rst:1767
msgid "An optional pointer to a \"descriptor get\" function."
msgstr ""
"Un puntero opcional a una función \"obtener descriptor\" (*descriptor ger*)."

#: ../Doc/c-api/typeobj.rst:1769 ../Doc/c-api/typeobj.rst:1785
#: ../Doc/c-api/typeobj.rst:1849 ../Doc/c-api/typeobj.rst:1879
#: ../Doc/c-api/typeobj.rst:1903
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../Doc/c-api/typeobj.rst:1771
msgid "PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1782
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Un puntero opcional a una función para configurar y eliminar el valor de un "
"descriptor."

#: ../Doc/c-api/typeobj.rst:1787
msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1789
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "El argumento *value* se establece a ``NULL`` para borrar el valor."

#: ../Doc/c-api/typeobj.rst:1800
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1803
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used "
"by :c:func:`PyObject_GenericGetAttr`."
msgstr ""
"Si las instancias de este tipo tienen un diccionario que contiene variables "
"de instancia, este campo no es cero y contiene el desplazamiento en las "
"instancias del tipo del diccionario de variables de instancia; este "
"desplazamiento es utilizado por :c:func:`PyObject_GenericGetAttr`."

#: ../Doc/c-api/typeobj.rst:1808
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"No confunda este campo con :c:member:`~PyTypeObject.tp_dict`; ese es el "
"diccionario para los atributos del tipo de objeto en sí."

#: ../Doc/c-api/typeobj.rst:1811
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1813
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary "
"call :c:func:`PyObject_GenericGetDict`. "
"Calling :c:func:`PyObject_GenericGetDict` may need to allocate memory for "
"the dictionary, so it is may be more efficient to "
"call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
"El :c:member:`~PyTypeObject.tp_dictoffset` debe considerarse como de solo "
"escritura. Para obtener el puntero al diccionario, llame "
"a :c:func:`PyObject_GenericGetDict`. Llamar "
"a :c:func:`PyObject_GenericGetDict` puede necesitar asignar memoria para el "
"diccionario, por lo que puede ser más eficiente llamar "
"a :c:func:`PyObject_GetAttr` cuando se accede a un atributo en el objeto."

#: ../Doc/c-api/typeobj.rst:1819
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_dictoffset`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1824
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, "
"use :c:macro:`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1831
#, fuzzy
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"Esta ranura no tiene ningún valor predeterminado. Para :ref:`tipos estáticos "
"<static-types>`, si el campo es ``NULL``, no se crea ningún :attr:`__dict__` "
"para las instancias."

#: ../Doc/c-api/typeobj.rst:1834
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in "
"the :c:member:`~PyTypeObject.tp_flags` field, "
"then :c:member:`~PyTypeObject.tp_dictoffset` will be set to ``-1``, to "
"indicate that it is unsafe to use this field."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1842
msgid "An optional pointer to an instance initialization function."
msgstr "Un puntero opcional a una función de inicialización de instancia."

#: ../Doc/c-api/typeobj.rst:1844
#, fuzzy
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"Esta función corresponde al método de clases :meth:`__init__`. "
"Como :meth:`__init__`, es posible crear una instancia sin llamar "
"a :meth:`__init__`, y es posible reinicializar una instancia llamando de "
"nuevo a su método :meth:`__init__`."

#: ../Doc/c-api/typeobj.rst:1851
msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1853
#, fuzzy
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call "
"to :meth:`~object.__init__`."
msgstr ""
"El argumento propio es la instancia que se debe inicializar; los argumentos "
"*args* y *kwds* representan argumentos posicionales y de palabras clave de "
"la llamada a :meth:`__init__`."

#: ../Doc/c-api/typeobj.rst:1857
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the "
"type's :c:member:`~PyTypeObject.tp_new` function has returned an instance of "
"the type.  If the :c:member:`~PyTypeObject.tp_new` function returns an "
"instance of some other type that is not a subtype of the original type, "
"no :c:member:`~PyTypeObject.tp_init` function is called; "
"if :c:member:`~PyTypeObject.tp_new` returns an instance of a subtype of the "
"original type, the subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"La función :c:member:`~PyTypeObject.tp_init`, si no es ``NULL``, se llama "
"cuando una instancia se crea normalmente llamando a su tipo, después de la "
"función :c:member:`~PyTypeObject.tp_new` del tipo ha retornado una instancia "
"del tipo. Si la función :c:member:`~PyTypeObject.tp_new` retorna una "
"instancia de otro tipo que no es un subtipo del tipo original, no se llama "
"la función :c:member:`~PyTypeObject.tp_init`; "
"if :c:member:`~PyTypeObject.tp_new` retorna una instancia de un subtipo del "
"tipo original, se llama al subtipo :c:member:`~PyTypeObject.tp_init`."

#: ../Doc/c-api/typeobj.rst:1864
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"Retorna ``0`` en caso de éxito, ``-1`` y establece una excepción en caso de "
"error."

#: ../Doc/c-api/typeobj.rst:1872
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr ""
"Para :ref:`tipos estáticos <static-types>`, este campo no tiene un valor "
"predeterminado."

#: ../Doc/c-api/typeobj.rst:1877
msgid "An optional pointer to an instance allocation function."
msgstr "Un puntero opcional a una función de asignación de instancia."

#: ../Doc/c-api/typeobj.rst:1881
msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1885
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)."
msgstr ""
"Este campo es heredado por subtipos estáticos, pero no por subtipos "
"dinámicos (subtipos creados por una declaración de clase)."

#: ../Doc/c-api/typeobj.rst:1890
msgid ""
"For dynamic subtypes, this field is always set "
"to :c:func:`PyType_GenericAlloc`, to force a standard heap allocation "
"strategy."
msgstr ""
"Para subtipos dinámicos, este campo siempre se establece "
"en :c:func:`PyType_GenericAlloc`, para forzar una estrategia de asignación "
"de heap estándar."

#: ../Doc/c-api/typeobj.rst:1894
#, fuzzy
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` "
"uses :c:func:`PyType_GenericAlloc`.  That is the recommended value for all "
"statically defined types."
msgstr ""
"Para subtipos estáticos, :c:type:`PyBaseObject_Type` "
"utiliza :c:func:`PyType_GenericAlloc`. Ese es el valor recomendado para "
"todos los tipos definidos estáticamente."

#: ../Doc/c-api/typeobj.rst:1901
msgid "An optional pointer to an instance creation function."
msgstr "Un puntero opcional a una función de creación de instancias."

#: ../Doc/c-api/typeobj.rst:1905
msgid ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1907
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type "
"whose :c:member:`~PyTypeObject.tp_new` function is called; it may be a "
"subtype of that type (but not an unrelated type)."
msgstr ""
"El argumento *subtype* es el tipo de objeto que se está creando; los "
"argumentos *args* y *kwds* representan argumentos posicionales y de palabras "
"clave de la llamada al tipo. Tenga en cuenta que *subtype* no tiene que ser "
"igual al tipo cuya función :c:member:`~PyTypeObject.tp_new` es llamada; "
"puede ser un subtipo de ese tipo (pero no un tipo no relacionado)."

#: ../Doc/c-api/typeobj.rst:1913
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place "
"in :c:member:`~PyTypeObject.tp_new`, while for mutable types, most "
"initialization should be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"La función :c:member:`~PyTypeObject.tp_new` debería llamar a ``subtype-"
">tp_alloc(subtype, nitems)`` para asignar espacio para el objeto, y luego "
"hacer solo la inicialización adicional que sea absolutamente necesaria. La "
"inicialización que se puede ignorar o repetir de forma segura debe colocarse "
"en el controlador :c:member:`~PyTypeObject.tp_init`. Una buena regla general "
"es que para los tipos inmutables, toda la inicialización debe tener lugar "
"en :c:member:`~PyTypeObject.tp_new`, mientras que para los tipos mutables, "
"la mayoría de las inicializaciones se deben diferir "
"a :c:member:`~PyTypeObject.tp_init`."

#: ../Doc/c-api/typeobj.rst:1921
#, fuzzy
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"Configure la marca :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION` para no "
"permitir la creación de instancias del tipo en Python."

#: ../Doc/c-api/typeobj.rst:1926
msgid ""
"This field is inherited by subtypes, except it is not inherited "
"by :ref:`static types <static-types>` "
"whose :c:member:`~PyTypeObject.tp_base` is ``NULL`` or "
"``&PyBaseObject_Type``."
msgstr ""
"Este campo se hereda por subtipos, excepto que no lo heredan :ref:`tipos "
"estáticos <static-types>` cuyo :c:member:`~PyTypeObject.tp_base` es ``NULL`` "
"o ``&PyBaseObject_Type``."

#: ../Doc/c-api/typeobj.rst:1932
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"Para :ref:`tipos estáticos <static-types>`, este campo no tiene ningún valor "
"predeterminado. Esto significa que si la ranura se define como ``NULL``, no "
"se puede llamar al tipo para crear nuevas instancias; presumiblemente hay "
"alguna otra forma de crear instancias, como una función de fábrica."

#: ../Doc/c-api/typeobj.rst:1940
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"Un puntero opcional a una función de desasignación de instancia. Su firma "
"es::"

#: ../Doc/c-api/typeobj.rst:1942
msgid "void tp_free(void *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1944
msgid ""
"An initializer that is compatible with this signature "
"is :c:func:`PyObject_Free`."
msgstr ""
"Un inicializador que es compatible con esta firma es :c:func:`PyObject_Free`."

#: ../Doc/c-api/typeobj.rst:1948
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement)"
msgstr ""
"Este campo es heredado por subtipos estáticos, pero no por subtipos "
"dinámicos (subtipos creados por una declaración de clase)"

#: ../Doc/c-api/typeobj.rst:1953
#, fuzzy
msgid ""
"In dynamic subtypes, this field is set to a deallocator suitable to "
"match :c:func:`PyType_GenericAlloc` and the value of "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""
"En los subtipos dinámicos, este campo se establece en un desasignador "
"adecuado para que coincida con :c:func:`PyType_GenericAlloc` y el valor del "
"bit de bandera :const:`Py_TPFLAGS_HAVE_GC`."

#: ../Doc/c-api/typeobj.rst:1957
#, fuzzy
msgid ""
"For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_Del`."
msgstr ""
"Para subtipos estáticos, :c:type:`PyBaseObject_Type` usa ``PyObject_Del``."

#: ../Doc/c-api/typeobj.rst:1962
msgid "An optional pointer to a function called by the garbage collector."
msgstr "Un puntero opcional a una función llamada por el recolector de basura."

#: ../Doc/c-api/typeobj.rst:1964
#, fuzzy
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check "
"the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture "
"of statically and dynamically allocated instances, and the statically "
"allocated instances are not collectible.  Such types should define this "
"function; it should return ``1`` for a collectible instance, and ``0`` for a "
"non-collectible instance. The signature is::"
msgstr ""
"El recolector de basura necesita saber si un objeto en particular es "
"coleccionable o no. Normalmente, es suficiente mirar el el "
"campo :c:member:`~PyTypeObject.tp_flags` del tipo objeto , y verificar el "
"bit de bandera :const:`Py_TPFLAGS_HAVE_GC`. Pero algunos tipos tienen una "
"mezcla de instancias asignadas estáticamente y dinámicamente, y las "
"instancias asignadas estáticamente no son coleccionables. Tales tipos "
"deberían definir esta función; debería retornar ``1`` para una instancia "
"coleccionable y ``0`` para una instancia no coleccionable. La firma es::"

#: ../Doc/c-api/typeobj.rst:1972
msgid "int tp_is_gc(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:1974
msgid ""
"(The only example of this are types themselves.  The "
"metatype, :c:data:`PyType_Type`, defines this function to distinguish "
"between statically and :ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(El único ejemplo de esto son los tipos en sí. El "
"metatipo, :c:data:`PyType_Type`, define esta función para distinguir entre "
"tipos estática y :ref:`dinámicamente asignados <heap-types>`.)"

#: ../Doc/c-api/typeobj.rst:1984
#, fuzzy
msgid ""
"This slot has no default.  If this field is "
"``NULL``, :c:macro:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Esta ranura no tiene valor predeterminado. Si este campo es ``NULL``, se "
"utiliza :const:`Py_TPFLAGS_HAVE_GC` como el equivalente funcional."

#: ../Doc/c-api/typeobj.rst:1990
msgid "Tuple of base types."
msgstr "Tupla de tipos base."

#: ../Doc/c-api/typeobj.rst:1992 ../Doc/c-api/typeobj.rst:2016
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:1995
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument "
"of :c:func:`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2002
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2008 ../Doc/c-api/typeobj.rst:2031
#: ../Doc/c-api/typeobj.rst:2048 ../Doc/c-api/typeobj.rst:2065
#: ../Doc/c-api/typeobj.rst:2079
msgid "This field is not inherited."
msgstr "Este campo no se hereda."

#: ../Doc/c-api/typeobj.rst:2013
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Tupla que contiene el conjunto expandido de tipos base, comenzando con el "
"tipo en sí y terminando con :class:`object`, en orden de resolución de "
"método."

#: ../Doc/c-api/typeobj.rst:2021
msgid ""
"This field is not inherited; it is calculated fresh "
"by :c:func:`PyType_Ready`."
msgstr "Este campo no se hereda; se calcula fresco por :c:func:`PyType_Ready`."

#: ../Doc/c-api/typeobj.rst:2027
msgid "Unused.  Internal use only."
msgstr "No usado. Solo para uso interno."

#: ../Doc/c-api/typeobj.rst:2036
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2038
msgid ""
"To get a list of subclasses, call the Python "
"method :py:meth:`~type.__subclasses__`."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2043
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2053
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Cabecera de lista de referencia débil, para referencias débiles a este tipo "
"de objeto. No heredado Solo para uso interno."

#: ../Doc/c-api/typeobj.rst:2058
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even "
"if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2070
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Este campo está en desuso. Use :c:member:`~PyTypeObject.tp_finalize` en su "
"lugar."

#: ../Doc/c-api/typeobj.rst:2075
msgid "Used to index into the method cache.  Internal use only."
msgstr "Se usa para indexar en el caché de métodos. Solo para uso interno."

#: ../Doc/c-api/typeobj.rst:2084
msgid ""
"An optional pointer to an instance finalization function.  Its signature is::"
msgstr ""
"Un puntero opcional a una función de finalización de instancia. Su firma es::"

#: ../Doc/c-api/typeobj.rst:2086
msgid "void tp_finalize(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2088
msgid ""
"If :c:member:`~PyTypeObject.tp_finalize` is set, the interpreter calls it "
"once when finalizing an instance.  It is called either from the garbage "
"collector (if the instance is part of an isolated reference cycle) or just "
"before the object is deallocated.  Either way, it is guaranteed to be called "
"before attempting to break reference cycles, ensuring that it finds the "
"object in a sane state."
msgstr ""
"Si :c:member:`~PyTypeObject.tp_finalize` está configurado, el intérprete lo "
"llama una vez cuando finaliza una instancia. Se llama desde el recolector de "
"basura (si la instancia es parte de un ciclo de referencia aislado) o justo "
"antes de que el objeto se desasigne. De cualquier manera, se garantiza que "
"se invocará antes de intentar romper los ciclos de referencia, asegurando "
"que encuentre el objeto en un estado sano."

#: ../Doc/c-api/typeobj.rst:2095
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should not mutate the current "
"exception status; therefore, a recommended way to write a non-trivial "
"finalizer is::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` no debe mutar el estado de excepción "
"actual; por lo tanto, una forma recomendada de escribir un finalizador no "
"trivial es::"

#: ../Doc/c-api/typeobj.rst:2098
msgid ""
"static void\n"
"local_finalize(PyObject *self)\n"
"{\n"
"    PyObject *error_type, *error_value, *error_traceback;\n"
"\n"
"    /* Save the current exception, if any. */\n"
"    PyErr_Fetch(&error_type, &error_value, &error_traceback);\n"
"\n"
"    /* ... */\n"
"\n"
"    /* Restore the saved exception. */\n"
"    PyErr_Restore(error_type, error_value, error_traceback);\n"
"}"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2112
msgid ""
"Also, note that, in a garbage collected "
"Python, :c:member:`~PyTypeObject.tp_dealloc` may be called from any Python "
"thread, not just the thread which created the object (if the object becomes "
"part of a refcount cycle, that cycle might be collected by a garbage "
"collection on any thread).  This is not a problem for Python API calls, "
"since the thread on which tp_dealloc is called will own the Global "
"Interpreter Lock (GIL). However, if the object being destroyed in turn "
"destroys objects from some other C or C++ library, care should be taken to "
"ensure that destroying those objects on the thread which called tp_dealloc "
"will not violate any assumptions of the library."
msgstr ""
"Además, tenga en cuenta que, en un Python que ha recolectado basura, se "
"puede llamar a :c:member:`~PyTypeObject.tp_dealloc` desde cualquier hilo de "
"Python, no solo el hilo que creó el objeto (si el objeto se convierte en "
"parte de un ciclo de conteo de referencias, ese ciclo puede ser recogido por "
"una recolección de basura en cualquier hilo). Esto no es un problema para "
"las llamadas a la API de Python, ya que el hilo en el que se llama "
"``tp_dealloc`` será el propietario del Bloqueo Global del Intérprete (GIL, "
"por sus siglas en inglés *Global Interpreter Lock*). Sin embargo, si el "
"objeto que se destruye a su vez destruye objetos de alguna otra biblioteca C "
"o C++, se debe tener cuidado para garantizar que la destrucción de esos "
"objetos en el hilo que se llama ``tp_dealloc`` no violará ningún supuesto de "
"la biblioteca."

#: ../Doc/c-api/typeobj.rst:2131
#, fuzzy
msgid ""
"Before version 3.8 it was necessary to set "
"the :c:macro:`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to "
"be used.  This is no longer required."
msgstr ""
"Antes de la versión 3.8 era necesario establecer el bit de "
"bandera :const:`Py_TPFLAGS_HAVE_FINALIZE` para que este campo fuera "
"utilizado.  Esto ya no es necesario."

#: ../Doc/c-api/typeobj.rst:2135
msgid "\"Safe object finalization\" (:pep:`442`)"
msgstr "\"Finalización segura de objetos\" (:pep:`442`)"

#: ../Doc/c-api/typeobj.rst:2140
#, fuzzy
msgid ""
"Vectorcall function to use for calls of this type object. In other words, it "
"is used to implement :ref:`vectorcall <vectorcall>` for ``type.__call__``. "
"If ``tp_vectorcall`` is ``NULL``, the default call implementation "
"using :meth:`~object.__new__` and :meth:`~object.__init__` is used."
msgstr ""
"Función Vectorcall a utilizar para llamadas de este tipo de objeto. En otras "
"palabras, se usa para implementar :ref:`vectorcall <vectorcall>` para "
"``type.__call__``. Si ``tp_vectorcall`` es ``NULL``, se usa la "
"implementación de llamada predeterminada usando :attr:`__new__` "
"y :attr:`__init__`."

#: ../Doc/c-api/typeobj.rst:2148
msgid "This field is never inherited."
msgstr "Este campo nunca se hereda."

#: ../Doc/c-api/typeobj.rst:2150
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(el campo existe desde 3.8 pero solo se usa desde 3.9)"

#: ../Doc/c-api/typeobj.rst:2155
msgid "Internal. Do not use."
msgstr ""

#: ../Doc/c-api/typeobj.rst:2163
msgid "Static Types"
msgstr "Tipos estáticos"

#: ../Doc/c-api/typeobj.rst:2165
msgid ""
"Traditionally, types defined in C code are *static*, that is, a "
"static :c:type:`PyTypeObject` structure is defined directly in code and "
"initialized using :c:func:`PyType_Ready`."
msgstr ""
"Tradicionalmente, los tipos definidos en el código C son *static*, es decir, "
"una estructura estática :c:type:`PyTypeObject` se define directamente en el "
"código y se inicializa usando :c:func:`PyType_Ready`."

#: ../Doc/c-api/typeobj.rst:2169
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Esto da como resultado tipos que están limitados en relación con los tipos "
"definidos en Python:"

#: ../Doc/c-api/typeobj.rst:2171
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Los tipos estáticos están limitados a una base, es decir, no pueden usar "
"herencia múltiple."

#: ../Doc/c-api/typeobj.rst:2173
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Los objetos de tipo estático (pero no necesariamente sus instancias) son "
"inmutables. No es posible agregar o modificar los atributos del objeto tipo "
"desde Python."

#: ../Doc/c-api/typeobj.rst:2175
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Los objetos de tipo estático se comparten en :ref:`sub intérpretes <sub-"
"interpreter-support>`, por lo que no deben incluir ningún estado específico "
"del sub interpretador."

#: ../Doc/c-api/typeobj.rst:2179
#, fuzzy
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"Además, dado que :c:type:`PyTypeObject` no forma parte de :ref:`stable ABI "
"<stable>`, cualquier módulo de extensión que use tipos estáticos debe "
"compilarse para una versión menor específica de Python."

#: ../Doc/c-api/typeobj.rst:2187
msgid "Heap Types"
msgstr "Tipos Heap"

#: ../Doc/c-api/typeobj.rst:2189
#, fuzzy
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have "
"the :c:macro:`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Una alternativa a :ref:`tipos estáticos <static-types>` es *heap-allocated "
"types*, o *tipos heap* para abreviar, que se corresponden estrechamente con "
"las clases creadas por la declaración ``class`` de Python. Los tipos de heap "
"tienen establecida la bandera :const:`Py_TPFLAGS_HEAPTYPE`."

#: ../Doc/c-api/typeobj.rst:2194
#, fuzzy
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and "
"calling :c:func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:`PyType_FromModuleAndSpec`, "
"or :c:func:`PyType_FromMetaclass`."
msgstr ""
"Esto se hace llenando una estructura :c:type:`PyType_Spec` y llamando "
"a :c:func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases` "
"o :c:func:`PyType_FromModuleAndSpec`."

#: ../Doc/c-api/typeobj.rst:2202
msgid "Number Object Structures"
msgstr "Estructuras de objetos de números"

#: ../Doc/c-api/typeobj.rst:2209
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Esta estructura contiene punteros a las funciones que utiliza un objeto para "
"implementar el protocolo numérico. Cada función es utilizada por la función "
"de un nombre similar documentado en la sección :ref:`number`."

#: ../Doc/c-api/typeobj.rst:2215 ../Doc/c-api/typeobj.rst:2539
msgid "Here is the structure definition::"
msgstr "Aquí está la definición de la estructura::"

#: ../Doc/c-api/typeobj.rst:2217
msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2262
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"Las funciones binarias y ternarias deben verificar el tipo de todos sus "
"operandos e implementar las conversiones necesarias (al menos uno de los "
"operandos es una instancia del tipo definido). Si la operación no está "
"definida para los operandos dados, las funciones binarias y ternarias deben "
"retornar ``Py_NotImplemented``, si se produce otro error, deben retornar "
"``NULL`` y establecer una excepción."

#: ../Doc/c-api/typeobj.rst:2271
#, fuzzy
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in "
"Python 3.0.1."
msgstr ""
"El campo :c:data:`nb_reserved` siempre debe ser ``NULL``. Anteriormente se "
"llamaba :c:data:`nb_long`, y se renombró en Python 3.0.1."

#: ../Doc/c-api/typeobj.rst:2316
msgid "Mapping Object Structures"
msgstr "Estructuras de objetos mapeo"

#: ../Doc/c-api/typeobj.rst:2323
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Esta estructura contiene punteros a las funciones que utiliza un objeto para "
"implementar el protocolo de mapeo. Tiene tres miembros:"

#: ../Doc/c-api/typeobj.rst:2328
msgid ""
"This function is used by :c:func:`PyMapping_Size` "
"and :c:func:`PyObject_Size`, and has the same signature.  This slot may be "
"set to ``NULL`` if the object has no defined length."
msgstr ""
"Esta función es utilizada por :c:func:`PyMapping_Size` "
"y :c:func:`PyObject_Size`, y tiene la misma firma. Esta ranura puede "
"establecerse en ``NULL`` si el objeto no tiene una longitud definida."

#: ../Doc/c-api/typeobj.rst:2334
msgid ""
"This function is used by :c:func:`PyObject_GetItem` "
"and :c:func:`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for "
"the :c:func:`PyMapping_Check` function to return ``1``, it can be ``NULL`` "
"otherwise."
msgstr ""
"Esta función es utilizada por :c:func:`PyObject_GetItem` "
"y :c:func:`PySequence_GetSlice`, y tiene la misma firma que :c:func:`!"
"PyObject_GetItem`. Este espacio debe llenarse para que la "
"función :c:func:`PyMapping_Check` retorna ``1``, de lo contrario puede ser "
"``NULL``."

#: ../Doc/c-api/typeobj.rst:2342
#, fuzzy
msgid ""
"This function is used "
"by :c:func:`PyObject_SetItem`, :c:func:`PyObject_DelItem`, :c:func:`PySequence_SetSlice` "
"and :c:func:`PySequence_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Esta función es utilizada "
"por :c:func:`PyObject_SetItem`, :c:func:`PyObject_DelItem`, :c:func:`PyObject_SetSlice` "
"y :c:func:`PyObject_DelSlice`. Tiene la misma firma que :c:func:`!"
"PyObject_SetItem`, pero *v* también se puede establecer en ``NULL`` para "
"eliminar un elemento. Si este espacio es ``NULL``, el objeto no admite la "
"asignación y eliminación de elementos."

#: ../Doc/c-api/typeobj.rst:2353
msgid "Sequence Object Structures"
msgstr "Estructuras de objetos secuencia"

#: ../Doc/c-api/typeobj.rst:2360
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Esta estructura contiene punteros a las funciones que utiliza un objeto para "
"implementar el protocolo de secuencia."

#: ../Doc/c-api/typeobj.rst:2365
msgid ""
"This function is used by :c:func:`PySequence_Size` "
"and :c:func:`PyObject_Size`, and has the same signature.  It is also used "
"for handling negative indices via the :c:member:`~PySequenceMethods.sq_item` "
"and the :c:member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Size` "
"y :c:func:`PyObject_Size`, y tiene la misma firma. También se usa para "
"manejar índices negativos a través de los "
"espacios :c:member:`~PySequenceMethods.sq_item` "
"y :c:member:`~PySequenceMethods.sq_ass_item`."

#: ../Doc/c-api/typeobj.rst:2372
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Concat` y tiene la misma "
"firma. También es utilizado por el operador ``+``, después de intentar la "
"suma numérica a través de la ranura :c:member:`~PyNumberMethods.nb_add`."

#: ../Doc/c-api/typeobj.rst:2378
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_Repeat` y tiene la misma "
"firma. También es utilizado por el operador ``*``, después de intentar la "
"multiplicación numérica a través de la "
"ranura :c:member:`~PyNumberMethods.nb_multiply`."

#: ../Doc/c-api/typeobj.rst:2384
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_GetItem` y tiene la misma "
"firma. También es utilizado por :c:func:`PyObject_GetItem`, después de "
"intentar la suscripción a través de la "
"ranura :c:member:`~PyMappingMethods.mp_subscript`. Este espacio debe "
"llenarse para que la función :c:func:`PySequence_Check` retorna ``1``, de lo "
"contrario puede ser ``NULL``."

#: ../Doc/c-api/typeobj.rst:2390
#, fuzzy
msgid ""
"Negative indexes are handled as follows: if "
"the :c:member:`~PySequenceMethods.sq_length` slot is filled, it is called "
"and the sequence length is used to compute a positive index which is passed "
"to  :c:member:`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is "
"``NULL``, the index is passed as is to the function."
msgstr ""
"Los índices negativos se manejan de la siguiente manera: si se llena el "
"espacio :attr:`sq_length`, se llama y la longitud de la secuencia se usa "
"para calcular un índice positivo que se pasa a :attr:`sq_item`. "
"Si :attr:`sq_length` es ``NULL``, el índice se pasa como es a la función."

#: ../Doc/c-api/typeobj.rst:2397
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` "
"and :c:func:`PyObject_DelItem`, after trying the item assignment and "
"deletion via the :c:member:`~PyMappingMethods.mp_ass_subscript` slot. This "
"slot may be left to ``NULL`` if the object does not support item assignment "
"and deletion."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_SetItem` y tiene la misma "
"firma. También lo usan :c:func:`PyObject_SetItem` "
"y :c:func:`PyObject_DelItem`, después de intentar la asignación y "
"eliminación del elemento a través de la "
"ranura :c:member:`~PyMappingMethods.mp_ass_subscript`. Este espacio puede "
"dejarse en ``NULL`` si el objeto no admite la asignación y eliminación de "
"elementos."

#: ../Doc/c-api/typeobj.rst:2406
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Esta función puede ser utilizada por :c:func:`PySequence_Contains` y tiene "
"la misma firma. Este espacio puede dejarse en ``NULL``, en este "
"caso :c:func:`!PySequence_Contains` simplemente atraviesa la secuencia hasta "
"que encuentra una coincidencia."

#: ../Doc/c-api/typeobj.rst:2413
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via "
"the :c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_InPlaceConcat` y tiene la "
"misma firma. Debería modificar su primer operando y retornarlo. Este espacio "
"puede dejarse en ``NULL``, en este caso :c:func:`!PySequence_InPlaceConcat` "
"volverá a :c:func:`PySequence_Concat`. También es utilizado por la "
"asignación aumentada ``+=``, después de intentar la suma numérica en el "
"lugar a través de la ranura :c:member:`~PyNumberMethods.nb_inplace_add`."

#: ../Doc/c-api/typeobj.rst:2422
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Esta función es utilizada por :c:func:`PySequence_InPlaceRepeat` y tiene la "
"misma firma. Debería modificar su primer operando y retornarlo. Este espacio "
"puede dejarse en ``NULL``, en este caso :c:func:`!PySequence_InPlaceRepeat` "
"volverá a :c:func:`PySequence_Repeat`. También es utilizado por la "
"asignación aumentada ``*=``, después de intentar la multiplicación numérica "
"en el lugar a través de la "
"ranura :c:member:`~PyNumberMethods.nb_inplace_multiply`."

#: ../Doc/c-api/typeobj.rst:2433
msgid "Buffer Object Structures"
msgstr "Estructuras de objetos búfer"

#: ../Doc/c-api/typeobj.rst:2441
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Esta estructura contiene punteros a las funciones requeridas "
"por :ref:`Buffer protocol <bufferobjects>`. El protocolo define cómo un "
"objeto exportador puede exponer sus datos internos a objetos de consumo."

#: ../Doc/c-api/typeobj.rst:2447 ../Doc/c-api/typeobj.rst:2496
#: ../Doc/c-api/typeobj.rst:2550 ../Doc/c-api/typeobj.rst:2561
#: ../Doc/c-api/typeobj.rst:2573 ../Doc/c-api/typeobj.rst:2583
msgid "The signature of this function is::"
msgstr "La firma de esta función es::"

#: ../Doc/c-api/typeobj.rst:2449
msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2451
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Maneja una solicitud a *exporter* para completar *view* según lo "
"especificado por *flags*. Excepto por el punto (3), una implementación de "
"esta función DEBE seguir estos pasos:"

#: ../Doc/c-api/typeobj.rst:2455
#, fuzzy
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, "
"set :c:expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Comprueba si se puede cumplir con la solicitud. Si no, "
"lanza :c:data:`PyExc_BufferError`, establece :c:data:`view->obj` en ``NULL`` "
"y retorna ``-1``."

#: ../Doc/c-api/typeobj.rst:2458
msgid "Fill in the requested fields."
msgstr "Rellene los campos solicitados."

#: ../Doc/c-api/typeobj.rst:2460
msgid "Increment an internal counter for the number of exports."
msgstr ""
"Incrementa un contador interno para el número de exportaciones (*exports*)."

#: ../Doc/c-api/typeobj.rst:2462
#, fuzzy
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Establece :c:data:`view->obj` en *exporter* e incremente :c:data:`view->obj`."

#: ../Doc/c-api/typeobj.rst:2464
msgid "Return ``0``."
msgstr "Retorna ``0``."

#: ../Doc/c-api/typeobj.rst:2466
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Si *exporter* es parte de una cadena o árbol de proveedores de búfer, se "
"pueden usar dos esquemas principales:"

#: ../Doc/c-api/typeobj.rst:2469
#, fuzzy
msgid ""
"Re-export: Each member of the tree acts as the exporting object and "
"sets :c:expr:`view->obj` to a new reference to itself."
msgstr ""
"Re-exportación: cada miembro del árbol actúa como el objeto exportador y "
"establece :c:data:`view->obj` en una nueva referencia a sí mismo."

#: ../Doc/c-api/typeobj.rst:2472
#, fuzzy
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Redirigir: la solicitud de búfer se redirige al objeto raíz del árbol. "
"Aquí :c:data:`view->obj` será una nueva referencia al objeto raíz."

#: ../Doc/c-api/typeobj.rst:2476
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Los campos individuales de *view* se describen en la "
"sección :ref:`Estructura de búfer <buffer-structure>`, las reglas sobre cómo "
"debe reaccionar un exportador a solicitudes específicas se encuentran en la "
"sección :ref:`Tipos de solicitud de búfer <buffer-request-types>`."

#: ../Doc/c-api/typeobj.rst:2481
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers "
"left. :c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` "
"and :c:member:`~Py_buffer.internal` are read-only for the consumer."
msgstr ""
"Toda la memoria señalada en la estructura :c:type:`Py_buffer` pertenece al "
"exportador y debe permanecer válida hasta que no queden "
"consumidores. :c:member:`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer.strides`, :c:member:`~Py_buffer.suboffsets` "
"y :c:member:`~Py_buffer.internal` son de solo lectura para el consumidor."

#: ../Doc/c-api/typeobj.rst:2488
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` proporciona una manera fácil de exponer un búfer "
"de bytes simple mientras se trata correctamente con todos los tipos de "
"solicitud."

#: ../Doc/c-api/typeobj.rst:2491
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` es la interfaz para el consumidor que envuelve "
"esta función."

#: ../Doc/c-api/typeobj.rst:2498
msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2500
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Maneja una solicitud para liberar los recursos del búfer. Si no es necesario "
"liberar recursos, :c:member:`PyBufferProcs.bf_releasebuffer` puede ser "
"``NULL``. De lo contrario, una implementación estándar de esta función "
"tomará estos pasos opcionales:"

#: ../Doc/c-api/typeobj.rst:2505
msgid "Decrement an internal counter for the number of exports."
msgstr "Disminuir un contador interno para el número de exportaciones."

#: ../Doc/c-api/typeobj.rst:2507
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Si el contador es ``0``, libera toda la memoria asociada con *view*."

#: ../Doc/c-api/typeobj.rst:2509
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"El exportador DEBE utilizar el campo :c:member:`~Py_buffer.internal` para "
"realizar un seguimiento de los recursos específicos del búfer. Se garantiza "
"que este campo permanecerá constante, mientras que un consumidor PUEDE pasar "
"una copia del búfer original como argumento *view*."

#: ../Doc/c-api/typeobj.rst:2515
#, fuzzy
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Esta función NO DEBE disminuir :c:data:`view->obj`, ya que esto se hace "
"automáticamente en :c:func:`PyBuffer_Release` (este esquema es útil para "
"romper los ciclos de referencia)."

#: ../Doc/c-api/typeobj.rst:2520
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` es la interfaz para el consumidor que envuelve "
"esta función."

#: ../Doc/c-api/typeobj.rst:2528
msgid "Async Object Structures"
msgstr "Estructuras de objetos asíncronos"

#: ../Doc/c-api/typeobj.rst:2536
msgid ""
"This structure holds pointers to the functions required to "
"implement :term:`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Esta estructura contiene punteros a las funciones requeridas para "
"implementar objetos \"esperable\" (:term:`awaitable`) y \"iterador "
"asincrónico\" (:term:`asynchronous iterator`)."

#: ../Doc/c-api/typeobj.rst:2541
msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2552
msgid "PyObject *am_await(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2554
#, fuzzy
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"El objeto retornado debe ser un iterador, es decir :c:func:`PyIter_Check` "
"debe retornar ``1`` para ello."

#: ../Doc/c-api/typeobj.rst:2557
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Este espacio puede establecerse en ``NULL`` si un objeto no "
"es :term:`awaitable`."

#: ../Doc/c-api/typeobj.rst:2563
msgid "PyObject *am_aiter(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2565
#, fuzzy
msgid ""
"Must return an :term:`asynchronous iterator` object. "
"See :meth:`~object.__anext__` for details."
msgstr ""
"Debe retornar un objeto \"esperable\" (:term:`awaitable`). "
"Ver :meth:`__anext__` para más detalles."

#: ../Doc/c-api/typeobj.rst:2568
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Este espacio puede establecerse en ``NULL`` si un objeto no implementa el "
"protocolo de iteración asincrónica."

#: ../Doc/c-api/typeobj.rst:2575
msgid "PyObject *am_anext(PyObject *self);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2577
#, fuzzy
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"Debe retornar un objeto \"esperable\" (:term:`awaitable`). "
"Ver :meth:`__anext__` para más detalles. Esta ranura puede establecerse en "
"``NULL``."

#: ../Doc/c-api/typeobj.rst:2585
msgid "PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2587
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Consulte :c:func:`PyIter_Send` para obtener más detalles. Esta ranura se "
"puede establecer en ``NULL``."

#: ../Doc/c-api/typeobj.rst:2596
msgid "Slot Type typedefs"
msgstr "Tipo Ranura *typedefs*"

#: ../Doc/c-api/typeobj.rst:2600
#, fuzzy
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` "
"and :c:member:`~PyObject.ob_type` set to the type argument.  If the "
"type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, the "
"object's :c:member:`~PyVarObject.ob_size` field should be initialized to "
"*nitems* and the length of the allocated memory block should be "
"``tp_basicsize + nitems*tp_itemsize``, rounded up to a multiple of "
"``sizeof(void*)``; otherwise, *nitems* is not used and the length of the "
"block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"El propósito de esta función es separar la asignación de memoria de la "
"inicialización de memoria. Debería retornar un puntero a un bloque de "
"memoria de longitud adecuada para la instancia, adecuadamente alineado e "
"inicializado a ceros, pero con :attr:`ob_refcnt` establecido en ``1`` "
"y :attr:`ob_type` establecido en argumento de tipo. Si el "
"tipo :c:member:`~PyTypeObject.tp_itemsize` no es cero, el campo del "
"objeto :attr:`ob_size` debe inicializarse en *nitems* y la longitud del "
"bloque de memoria asignado debe ser ``tp_basicsize + nitems*tp_itemsize``, "
"redondeado a un múltiplo de ``sizeof(void*)``; de lo contrario, *nitems* no "
"se usa y la longitud del bloque debe "
"ser :c:member:`~PyTypeObject.tp_basicsize`."

#: ../Doc/c-api/typeobj.rst:2610
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done "
"by :c:member:`~PyTypeObject.tp_new`."
msgstr ""
"Esta función no debe hacer ninguna otra instancia de inicialización, ni "
"siquiera para asignar memoria adicional; eso debe ser realizado "
"por :c:member:`~PyTypeObject.tp_new`."

#: ../Doc/c-api/typeobj.rst:2617
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_free`."

#: ../Doc/c-api/typeobj.rst:2621
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_new`."

#: ../Doc/c-api/typeobj.rst:2625
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_init`."

#: ../Doc/c-api/typeobj.rst:2629
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_repr`."

#: ../Doc/c-api/typeobj.rst:2633 ../Doc/c-api/typeobj.rst:2642
msgid "Return the value of the named attribute for the object."
msgstr "Retorna el valor del atributo nombrado para el objeto."

#: ../Doc/c-api/typeobj.rst:2637 ../Doc/c-api/typeobj.rst:2648
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Establece el valor del atributo nombrado para el objeto. El argumento del "
"valor se establece en ``NULL`` para eliminar el atributo."

#: ../Doc/c-api/typeobj.rst:2644
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_getattro`."

#: ../Doc/c-api/typeobj.rst:2651
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_setattro`."

#: ../Doc/c-api/typeobj.rst:2655
#, fuzzy
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_descrget`."

#: ../Doc/c-api/typeobj.rst:2659
#, fuzzy
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_descrset`."

#: ../Doc/c-api/typeobj.rst:2663
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_hash`."

#: ../Doc/c-api/typeobj.rst:2667
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_richcompare`."

#: ../Doc/c-api/typeobj.rst:2671
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_iter`."

#: ../Doc/c-api/typeobj.rst:2675
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Consulte :c:member:`~PyTypeObject.tp_iternext`."

#: ../Doc/c-api/typeobj.rst:2689
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Consulte :c:member:`~PyAsyncMethods.am_send`."

#: ../Doc/c-api/typeobj.rst:2705
msgid "Examples"
msgstr "Ejemplos"

#: ../Doc/c-api/typeobj.rst:2707
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"Los siguientes son ejemplos simples de definiciones de tipo Python. Incluyen "
"el uso común que puede encontrar. Algunos demuestran casos difíciles de "
"esquina (*corner cases*). Para obtener más ejemplos, información práctica y "
"un tutorial, consulte \"definiendo nuevos tipos\" (:ref:`defining-new-"
"types`) y \"tópicos de nuevos tipos (:ref:`new-types-topics`)."

#: ../Doc/c-api/typeobj.rst:2712
msgid "A basic :ref:`static type <static-types>`::"
msgstr "Un :ref:`tipo estático <static-types>` básico:"

#: ../Doc/c-api/typeobj.rst:2714
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2729
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"También puede encontrar código más antiguo (especialmente en la base de "
"código CPython) con un inicializador más detallado::"

#: ../Doc/c-api/typeobj.rst:2732
msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2773
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr ""
"Un tipo que admite referencias débiles, instancias de diccionarios (*dicts*) "
"y *hashing*::"

#: ../Doc/c-api/typeobj.rst:2775
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2798
#, fuzzy
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) "
"using :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"Una subclase str que no se puede subclasificar y no se puede llamar para "
"crear instancias (por ejemplo, usa una función de fábrica separada) usando "
"el indicador :c:data:`Py_TPFLAGS_DISALLOW_INSTANTIATION`:"

#: ../Doc/c-api/typeobj.rst:2802
msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2817
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"El :ref:`tipo estático <static-types>` más simple con instancias de longitud "
"fija:"

#: ../Doc/c-api/typeobj.rst:2819
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""

#: ../Doc/c-api/typeobj.rst:2828
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"El :ref:`tipo estático <static-types>` más simple con instancias de longitud "
"variable:"

#: ../Doc/c-api/typeobj.rst:2830
msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""

#: ../Doc/c-api/typeobj.rst:787 ../Doc/c-api/typeobj.rst:852
msgid "built-in function"
msgstr ""

#: ../Doc/c-api/typeobj.rst:787
#, fuzzy
msgid "repr"
msgstr "__repr__"

#: ../Doc/c-api/typeobj.rst:852
#, fuzzy
msgid "hash"
msgstr "__hash__"
