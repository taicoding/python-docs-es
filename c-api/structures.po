# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# Maintained by the python-doc-es workteam.
# docs-es@python.org /
# https://mail.python.org/mailman3/lists/docs-es.python.org/
# Check https://github.com/python/python-docs-es/blob/3.8/TRANSLATORS to
# get the list of volunteers
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-21 16:38-0300\n"
"PO-Revision-Date: 2022-10-31 15:59-0400\n"
"Last-Translator: José Luis Salgado Banda <josephLSalgado@outlook.com>\n"
"Language: es\n"
"Language-Team: python-doc-es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../Doc/c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Estructuras de objetos comunes"

#: ../Doc/c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Hay un gran número de estructuras que se utilizan en la definición de los "
"tipos de objetos de Python. Esta sección describe estas estructuras y la "
"forma en que se utilizan."

#: ../Doc/c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Tipos objeto base y macros"

#: ../Doc/c-api/structures.rst:16
#, fuzzy
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects.  "
"Additional macros can be found under :ref:`reference counting "
"<countingrefs>`."
msgstr ""
"En última instancia, todos los objetos de Python comparten un pequeño número "
"de campos en el comienzo de la representación del objeto en la memoria. "
"Estos están representados por la :c:type:`PyObject` "
"y :c:type:`PyVarObject`,que se definen, a su vez, por las expansiones de "
"algunos macros también se utilizan, ya sea directa o indirectamente, en la "
"definición de todos otros objetos de Python."

#: ../Doc/c-api/structures.rst:26
#, fuzzy
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:expr:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Todos los tipos de objetos son extensiones de este tipo. Este es un tipo que "
"contiene la información que Python necesita para tratar un puntero a un "
"objeto como un objeto. En una construcción \"*release*\" normal, que "
"contiene solo contador de referencia del objeto y un puntero al objeto de "
"tipo correspondiente. En realidad nada es declarado como "
"un :c:type:`PyObject`, pero cada puntero a un objeto de Python se puede "
"convertir en una :c:type:`PyObject*`. El acceso a los miembros debe hacerse "
"mediante el uso de las macros :c:macro:`Py_REFCNT` y :c:macro:`Py_TYPE`."

#: ../Doc/c-api/structures.rst:38
#, fuzzy
msgid ""
"This is an extension of :c:type:`PyObject` that adds "
"the :c:member:`~PyVarObject.ob_size` field.  This is only used for objects "
"that have some notion of *length*. This type does not often appear in the "
"Python/C API. Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, and :c:macro:`Py_SIZE`."
msgstr ""
"Esta es una extensión de :c:type:`PyObject` que se suma el "
"campo :attr:`ob_size`. Esto sólo se utiliza para objetos que tienen cierta "
"noción de longitud (*length*). Este tipo no suele aparecer en la API Python/"
"C. El acceso a los miembros debe hacerse mediante el uso de las "
"macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, y :c:macro:`Py_SIZE`."

#: ../Doc/c-api/structures.rst:47
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Esta es una macro utilizado cuando se declara nuevos tipos que representan "
"objetos sin una longitud variable. La macro PyObject_HEAD se expande a::"

#: ../Doc/c-api/structures.rst:50
msgid "PyObject ob_base;"
msgstr ""

#: ../Doc/c-api/structures.rst:52
msgid "See documentation of :c:type:`PyObject` above."
msgstr ""
"Consulte la documentación de :c:type:`PyObject` en secciones anteriores."

#: ../Doc/c-api/structures.rst:57
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Esta es una macro utilizado cuando se declara nuevos tipos que representan "
"objetos con una longitud que varía de una instancia a otra instancia. La "
"macro PyObject_VAR_HEAD se expande a::"

#: ../Doc/c-api/structures.rst:61
msgid "PyVarObject ob_base;"
msgstr ""

#: ../Doc/c-api/structures.rst:63
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Consulte la documentación de :c:type:`PyVarObject` anteriormente."

#: ../Doc/c-api/structures.rst:68
msgid ""
"Test if the *x* object is the *y* object, the same as ``x is y`` in Python."
msgstr ""
"Prueba si el objeto *x* es el objeto *y*, lo mismo que ``x is y`` en Python."

#: ../Doc/c-api/structures.rst:75
msgid ""
"Test if an object is the ``None`` singleton, the same as ``x is None`` in "
"Python."
msgstr ""
"Prueba si un objeto es la instancia única ``None``, lo mismo que ``x is "
"None`` en Python."

#: ../Doc/c-api/structures.rst:83
msgid ""
"Test if an object is the ``True`` singleton, the same as ``x is True`` in "
"Python."
msgstr ""
"Prueba si un objeto es la instancia única ``True``, lo mismo que ``x is "
"True`` en Python."

#: ../Doc/c-api/structures.rst:91
msgid ""
"Test if an object is the ``False`` singleton, the same as ``x is False`` in "
"Python."
msgstr ""
"Prueba si un objeto es la instancia única ``False``, lo mismo que ``x is "
"False`` en Python."

#: ../Doc/c-api/structures.rst:99
msgid "Get the type of the Python object *o*."
msgstr "Obtiene el tipo de objeto Python *o*."

#: ../Doc/c-api/structures.rst:101
msgid "Return a :term:`borrowed reference`."
msgstr "Retorna una referencia prestada (:term:`borrowed reference`)."

#: ../Doc/c-api/structures.rst:103
#, fuzzy
msgid "Use the :c:func:`Py_SET_TYPE` function to set an object type."
msgstr ""
"Debe utilizarse la función :c:func:`Py_SET_TYPE` para establecer un tipo de "
"objeto."

#: ../Doc/c-api/structures.rst:105
msgid ""
":c:func:`Py_TYPE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyObject*`."
msgstr ""
":c:func:`Py_TYPE()` se cambia a una función estática inline. El tipo de "
"parámetro ya no es :c:expr:`const PyObject*`."

#: ../Doc/c-api/structures.rst:112
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Retorna un valor distinto de cero si el objeto *o* tipo es *type*. Retorna "
"cero en caso contrario. Equivalente a: ``Py_TYPE(o) == type``."

#: ../Doc/c-api/structures.rst:120
msgid "Set the object *o* type to *type*."
msgstr "Establece el tipo del objeto *o* a *type*."

#: ../Doc/c-api/structures.rst:127
msgid "Get the size of the Python object *o*."
msgstr "Obtiene el tamaño del objeto Python *o*."

#: ../Doc/c-api/structures.rst:129
#, fuzzy
msgid "Use the :c:func:`Py_SET_SIZE` function to set an object size."
msgstr ""
"Debe utilizarse la función :c:func:`Py_SET_SIZE` para establecer un tamaño "
"de objeto."

#: ../Doc/c-api/structures.rst:131
msgid ""
":c:func:`Py_SIZE()` is changed to an inline static function. The parameter "
"type is no longer :c:expr:`const PyVarObject*`."
msgstr ""
":c:func:`Py_SIZE()` se cambia a una función estática inline. El tipo de "
"parámetro ya no es :c:expr:`const PyVarObject*`."

#: ../Doc/c-api/structures.rst:138
msgid "Set the object *o* size to *size*."
msgstr "Establece el tamaño del objeto *o* a *size*."

#: ../Doc/c-api/structures.rst:145
msgid ""
"This is a macro which expands to initialization values for a "
"new :c:type:`PyObject` type.  This macro expands to::"
msgstr ""
"Esta es una macro que se expande para valores de inicialización para un "
"nuevo tipo :c:type:`PyObject`. Esta macro expande::"

#: ../Doc/c-api/structures.rst:148
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type,"
msgstr ""

#: ../Doc/c-api/structures.rst:154
#, fuzzy
msgid ""
"This is a macro which expands to initialization values for a "
"new :c:type:`PyVarObject` type, including "
"the :c:member:`~PyVarObject.ob_size` field. This macro expands to::"
msgstr ""
"Esta es una macro que se expande para valores de inicialización para un "
"nuevo tipo :c:type:`PyVarObject`, incluyendo el campo :attr:`ob_size`. Esta "
"macro se expande a::"

#: ../Doc/c-api/structures.rst:158
msgid ""
"_PyObject_EXTRA_INIT\n"
"1, type, size,"
msgstr ""

#: ../Doc/c-api/structures.rst:163
msgid "Implementing functions and methods"
msgstr "Implementando funciones y métodos"

#: ../Doc/c-api/structures.rst:167
#, fuzzy
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:expr:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Tipo de las funciones usadas para implementar la mayoría de invocables "
"Python en C. Funciones de este tipo toman dos parámetros :c:type:`PyObject*` "
"y retorna un valor de ese tipo. Si el valor de retorno es ``NULL``, una "
"excepción fue establecida. Si no es ``NULL``, el valor retornado se "
"interpreta como el valor de retorno de la función que se expone en Python. "
"La función debe retornar una nueva referencia."

#: ../Doc/c-api/structures.rst:174
msgid "The function signature is::"
msgstr "La firma de la función es::"

#: ../Doc/c-api/structures.rst:176
msgid ""
"PyObject *PyCFunction(PyObject *self,\n"
"                      PyObject *args);"
msgstr ""

#: ../Doc/c-api/structures.rst:181
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`. "
"The function signature is::"
msgstr ""
"Tipo de las funciones que se utilizan para implementar invocables Python en "
"C con la firma :const:`METH_VARARGS | METH_KEYWORDS`. La firma de la función "
"es::"

#: ../Doc/c-api/structures.rst:185
msgid ""
"PyObject *PyCFunctionWithKeywords(PyObject *self,\n"
"                                  PyObject *args,\n"
"                                  PyObject *kwargs);"
msgstr ""

#: ../Doc/c-api/structures.rst:192
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :c:macro:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Tipo de las funciones que se utilizan para implementar invocables Python en "
"C con la firma :const:`METH_FASTCALL`. La firma de la función es::"

#: ../Doc/c-api/structures.rst:196
msgid ""
"PyObject *PyCFunctionFast(PyObject *self,\n"
"                          PyObject *const *args,\n"
"                          Py_ssize_t nargs);"
msgstr ""

#: ../Doc/c-api/structures.rst:202
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo de las funciones que se utilizan para implementar invocables Python en "
"C con la firma :const:`METH_FASTCALL | METH_KEYWORDS`. La firma de la "
"función es::"

#: ../Doc/c-api/structures.rst:206
msgid ""
"PyObject *PyCFunctionFastWithKeywords(PyObject *self,\n"
"                                      PyObject *const *args,\n"
"                                      Py_ssize_t nargs,\n"
"                                      PyObject *kwnames);"
msgstr ""

#: ../Doc/c-api/structures.rst:213
#, fuzzy
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-"
"METH_FASTCALL-METH_KEYWORDS>`. The function signature is::"
msgstr ""
"Tipo de las funciones que se utilizan para implementar invocables Python en "
"C con la firma :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. La "
"firma de la función es::"

#: ../Doc/c-api/structures.rst:217
msgid ""
"PyObject *PyCMethod(PyObject *self,\n"
"                    PyTypeObject *defining_class,\n"
"                    PyObject *const *args,\n"
"                    Py_ssize_t nargs,\n"
"                    PyObject *kwnames)"
msgstr ""

#: ../Doc/c-api/structures.rst:228
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Estructura utiliza para describir un método de un tipo de extensión. Esta "
"estructura tiene cuatro campos:"

#: ../Doc/c-api/structures.rst:233
#, fuzzy
msgid "Name of the method."
msgstr "nombre del método"

#: ../Doc/c-api/structures.rst:237
#, fuzzy
msgid "Pointer to the C implementation."
msgstr "puntero a la implementación en C"

#: ../Doc/c-api/structures.rst:241
#, fuzzy
msgid "Flags bits indicating how the call should be constructed."
msgstr "*flag* bits que indican cómo debe ser construida la llamada"

#: ../Doc/c-api/structures.rst:245
#, fuzzy
msgid "Points to the contents of the docstring."
msgstr "puntos a los contenidos del docstring"

#: ../Doc/c-api/structures.rst:247
#, fuzzy
msgid ""
"The :c:member:`~PyMethodDef.ml_meth` is a C function pointer. The functions "
"may be of different types, but they always return :c:expr:`PyObject*`.  If "
"the function is not of the :c:type:`PyCFunction`, the compiler will require "
"a cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:expr:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
"El :attr:`ml_meth` es un puntero de función C. Las funciones pueden ser de "
"diferentes tipos, pero siempre retornan :c:type:`PyObject*`. Si la función "
"no es la de :c:type:`PyCFunction`, el compilador requiere una conversión de "
"tipo en la tabla de métodos. A pesar de que :c:type:`PyCFunction` define el "
"primer parámetro como :c:type:`PyObject*`, es común que la implementación "
"del método utiliza el tipo específico C del objeto *self*."

#: ../Doc/c-api/structures.rst:255
#, fuzzy
msgid ""
"The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include "
"the following flags. The individual flags indicate either a calling "
"convention or a binding convention."
msgstr ""
"El campo :attr:`ml_flags` es un campo de bits que puede incluir las "
"siguientes *flags*. Las *flags* individuales indican o bien una convención "
"de llamada o una convención vinculante."

#: ../Doc/c-api/structures.rst:260
msgid "There are these calling conventions:"
msgstr "Existen estas convenciones de llamada:"

#: ../Doc/c-api/structures.rst:264
#, fuzzy
msgid ""
"This is the typical calling convention, where the methods have the "
"type :c:type:`PyCFunction`. The function expects two :c:expr:`PyObject*` "
"values. The first one is the *self* object for methods; for module "
"functions, it is the module object.  The second parameter (often called "
"*args*) is a tuple object representing all arguments. This parameter is "
"typically processed using :c:func:`PyArg_ParseTuple` "
"or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Esta es la convención de llamada típica, donde los métodos tienen el "
"tipo :c:type:`PyCFunction`. La función espera dos "
"valores :c:type:`PyObject*`.  El primero es objeto *self* para los métodos; "
"para las funciones del módulo, que es el objeto módulo. El segundo parámetro "
"(a menudo llamado *args*) es un objeto tupla que representa todos los "
"argumentos. Este parámetro se procesa típicamente "
"usando :c:func:`PyArg_ParseTuple` o :c:func:`PyArg_UnpackTuple`."

#: ../Doc/c-api/structures.rst:274
msgid ""
"Can only be used in certain combinations with other "
"flags: :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-"
"METH_KEYWORDS>`, :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` and :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS "
"<METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""

#: ../Doc/c-api/structures.rst:288
msgid ":c:expr:`METH_VARARGS | METH_KEYWORDS`"
msgstr ""

#: ../Doc/c-api/structures.rst:283
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Los métodos con estas *flags* deben ser del "
"tipo :c:type:`PyCFunctionWithKeywords`. La función espera tres parámetros: "
"*self*, *args*, *kwargs* donde *kwargs* es un diccionario de todos los "
"argumentos de palabras clave o, posiblemente, ``NULL`` si no hay argumentos "
"de palabra clave. Los parámetros se procesan típicamente "
"usando :c:func:`PyArg_ParseTupleAndKeywords`."

#: ../Doc/c-api/structures.rst:292
#, fuzzy
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:expr:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Convención de llamando rápido que soporta sólo argumentos posicionales. Los "
"métodos tienen el tipo :c:type:`_PyCFunctionFast`. El primer parámetro es "
"*self*, el segundo parámetro es un arreglo C de valores :c:type:`PyObject*` "
"que indican los argumentos y el tercer parámetro es el número de argumentos "
"(la longitud del arreglo)."

#: ../Doc/c-api/structures.rst:302
#, fuzzy
msgid "``METH_FASTCALL`` is now part of the :ref:`stable ABI <stable-abi>`."
msgstr "Ahora ``METH_FASTCALL`` es parte de la ABI estable."

#: ../Doc/c-api/structures.rst:319
msgid ":c:expr:`METH_FASTCALL | METH_KEYWORDS`"
msgstr ""

#: ../Doc/c-api/structures.rst:308
#, fuzzy
msgid ""
"Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments, "
"with methods of type :c:type:`PyCFunctionFastWithKeywords`. Keyword "
"arguments are passed the same way as in the :ref:`vectorcall protocol "
"<vectorcall>`: there is an additional fourth :c:expr:`PyObject*` parameter "
"which is a tuple representing the names of the keyword arguments (which are "
"guaranteed to be strings) or possibly ``NULL`` if there are no keywords.  "
"The values of the keyword arguments are stored in the *args* array, after "
"the positional arguments."
msgstr ""
"Extensión de :const:`METH_FASTCALL` que admite también argumentos de palabra "
"clave, con los métodos de tipo :c:type:`_PyCFunctionFastWithKeywords`. "
"argumentos de palabra clave se transmiten de la misma manera como en "
"el  :ref:`vectorcall protocol <vectorcall>`: hay un cuarto "
"parámetro :c:type:`PyObject*` adicional que es una tupla que representa los "
"nombres de los argumentos de palabra clave o posiblemente ``NULL`` si no hay "
"palabras clave. Los valores de los argumentos de palabras clave se almacenan "
"en el arreglo *args*, después de los argumentos posicionales."

#: ../Doc/c-api/structures.rst:323
msgid ""
"Can only be used in the combination with other flags: :ref:`METH_METHOD | "
"METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`."
msgstr ""

#: ../Doc/c-api/structures.rst:340
msgid ":c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`"
msgstr ""

#: ../Doc/c-api/structures.rst:330
#, fuzzy
msgid ""
"Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-"
"METH_KEYWORDS>` supporting the *defining class*, that is, the class that "
"contains the method in question. The defining class might be a superclass of "
"``Py_TYPE(self)``."
msgstr ""
"Extensión de :const:`METH_FASTCALL | METH_KEYWORDS` que admite la *clase "
"definitoria*, es decir, la clase que contiene el método en cuestión. La "
"clase definitoria podría ser una superclase de ``Py_TYPE(self)``."

#: ../Doc/c-api/structures.rst:335
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"El método debe ser de tipo :c:type:`PyCMethod`, lo mismo que para "
"``METH_FASTCALL | METH_KEYWORDS`` con el argumento ``defining_clase`` "
"añadido después de ``self``."

#: ../Doc/c-api/structures.rst:344
#, fuzzy
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Métodos sin parámetros no tienen que comprobar si los argumentos se dan si "
"están registrados con el *flag* :const:`METH_NOARGS`. Tienen que ser de "
"tipo :c:type:`PyCFunction`. El primer parámetro normalmente se denomina "
"*self* y llevará a cabo una referencia a la instancia módulo u objeto. En "
"todos los casos el segundo parámetro será ``NULL``."

#: ../Doc/c-api/structures.rst:350
msgid ""
"The function must have 2 parameters. Since the second parameter is "
"unused, :c:macro:`Py_UNUSED` can be used to prevent a compiler warning."
msgstr ""
"La función debe tener 2 parámetros. Dado que el segundo parámetro no se "
"usa, :c:macro:`Py_UNUSED` se puede usar para evitar una advertencia del "
"compilador."

#: ../Doc/c-api/structures.rst:356
#, fuzzy
msgid ""
"Methods with a single object argument can be listed with "
"the :c:macro:`METH_O` flag, instead of invoking :c:func:`PyArg_ParseTuple` "
"with a ``\"O\"`` argument. They have the type :c:type:`PyCFunction`, with "
"the *self* parameter, and a :c:expr:`PyObject*` parameter representing the "
"single argument."
msgstr ""
"Los métodos con un solo argumento objeto pueden ser listados con el "
"flag :const:`METH_O`, en lugar de invocar :c:func:`PyArg_ParseTuple` con un "
"argumento ``\"O\"``. Tienen el tipo :c:type:`PyCFunction`, con el parámetro "
"*self*, y un parámetro :c:type:`PyObject*` que representa el único argumento."

#: ../Doc/c-api/structures.rst:362
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Estas dos constantes no se utilizan para indicar la convención de llamada si "
"no la vinculación cuando su usan con métodos de las clases. Estos no se "
"pueden usar para funciones definidas para módulos. A lo sumo uno de estos "
"*flags* puede establecerse en un método dado."

#: ../Doc/c-api/structures.rst:372
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"Al método se le pasará el objeto tipo como primer parámetro, en lugar de una "
"instancia del tipo. Esto se utiliza para crear métodos de clase (*class "
"methods*), similar a lo que se crea cuando se utiliza la "
"función :func:`classmethod` incorporada."

#: ../Doc/c-api/structures.rst:382
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"El método pasará ``NULL`` como el primer parámetro en lugar de una instancia "
"del tipo. Esto se utiliza para crear métodos estáticos (*static methods*), "
"similar a lo que se crea cuando se utiliza la función :func:`staticmethod` "
"incorporada."

#: ../Doc/c-api/structures.rst:386
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"En otros controles constantes dependiendo si se carga un método en su lugar "
"(*in place*) de otra definición con el mismo nombre del método."

#: ../Doc/c-api/structures.rst:392
#, fuzzy
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method "
"named :meth:`~object.__contains__` and preclude the loading of a "
"corresponding PyCFunction with the same name.  With the flag defined, the "
"PyCFunction will be loaded in place of the wrapper object and will co-exist "
"with the slot.  This is helpful because calls to PyCFunctions are optimized "
"more than wrapper object calls."
msgstr ""
"El método se cargará en lugar de las definiciones existentes. Sin "
"*METH_COEXIST*, el comportamiento predeterminado es saltarse las "
"definiciones repetidas. Desde envolturas de ranura se cargan antes de la "
"tabla de métodos, la existencia de una ranura *sq_contains*, por ejemplo, "
"generaría un método envuelto llamado :meth:`__contains__` e impediría la "
"carga de una PyCFunction correspondiente con el mismo nombre. Con el *flag* "
"definido, la PyCFunction se cargará en lugar del objeto envoltorio y "
"coexistirá con la ranura. Esto es útil porque las llamadas a PyCFunctions se "
"optimizan más que las llamadas a objetos envolvente."

#: ../Doc/c-api/structures.rst:404
msgid ""
"Turn *ml* into a Python :term:`callable` object. The caller must ensure that "
"*ml* outlives the :term:`callable`. Typically, *ml* is defined as a static "
"variable."
msgstr ""

#: ../Doc/c-api/structures.rst:408
msgid ""
"The *self* parameter will be passed as the *self* argument to the C function "
"in ``ml->ml_meth`` when invoked. *self* can be ``NULL``."
msgstr ""

#: ../Doc/c-api/structures.rst:412
msgid ""
"The :term:`callable` object's ``__module__`` attribute can be set from the "
"given *module* argument. *module* should be a Python string, which will be "
"used as name of the module the function is defined in. If unavailable, it "
"can be set to :const:`None` or ``NULL``."
msgstr ""

#: ../Doc/c-api/structures.rst:418
msgid ":attr:`function.__module__`"
msgstr ""

#: ../Doc/c-api/structures.rst:420
msgid ""
"The *cls* parameter will be passed as the *defining_class* argument to the C "
"function. Must be set if :c:macro:`METH_METHOD` is set on ``ml->ml_flags``."
msgstr ""

#: ../Doc/c-api/structures.rst:429
msgid "Equivalent to ``PyCMethod_New(ml, self, module, NULL)``."
msgstr ""

#: ../Doc/c-api/structures.rst:434
msgid "Equivalent to ``PyCMethod_New(ml, self, NULL, NULL)``."
msgstr ""

#: ../Doc/c-api/structures.rst:438
msgid "Accessing attributes of extension types"
msgstr "Acceder a atributos de tipos de extensión"

#: ../Doc/c-api/structures.rst:442
#, fuzzy
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member. When defining a class, put a NULL-terminated array of these "
"structures in the :c:member:`~PyTypeObject.tp_members` slot."
msgstr ""
"Estructura que describe un atributo de un tipo que corresponde a un miembro "
"de la estructura de C. Sus campos son:"

#: ../Doc/c-api/structures.rst:447
msgid "Its fields are, in order:"
msgstr ""

#: ../Doc/c-api/structures.rst:451
msgid ""
"Name of the member. A NULL value marks the end of a ``PyMemberDef[]`` array."
msgstr ""

#: ../Doc/c-api/structures.rst:454
msgid "The string should be static, no copy is made of it."
msgstr ""

#: ../Doc/c-api/structures.rst:458
msgid ""
"The type of the member in the C struct. See :ref:`PyMemberDef-types` for the "
"possible values."
msgstr ""

#: ../Doc/c-api/structures.rst:463
#, fuzzy
msgid ""
"The offset in bytes that the member is located on the type’s object struct."
msgstr ""
"el desplazamiento en bytes que el miembro se encuentra en la estructura de "
"objetos tipo"

#: ../Doc/c-api/structures.rst:467
msgid ""
"Zero or more of the :ref:`PyMemberDef-flags`, combined using bitwise OR."
msgstr ""

#: ../Doc/c-api/structures.rst:471
msgid ""
"The docstring, or NULL. The string should be static, no copy is made of it. "
"Typically, it is defined using :c:macro:`PyDoc_STR`."
msgstr ""

#: ../Doc/c-api/structures.rst:475
msgid ""
"By default (when :c:member:`~PyMemberDef.flags` is ``0``), members allow "
"both read and write access. Use the :c:macro:`Py_READONLY` flag for read-"
"only access. Certain types, like :c:macro:`Py_T_STRING`, "
"imply :c:macro:`Py_READONLY`. Only :c:macro:`Py_T_OBJECT_EX` (and "
"legacy :c:macro:`T_OBJECT`) members can be deleted."
msgstr ""

#: ../Doc/c-api/structures.rst:484
#, fuzzy
msgid ""
"For heap-allocated types (created using :c:func:`PyType_FromSpec` or "
"similar), ``PyMemberDef`` may contain a definition for the special member "
"``\"__vectorcalloffset__\"``, corresponding "
"to :c:member:`~PyTypeObject.tp_vectorcall_offset` in type objects. These "
"must be defined with ``Py_T_PYSSIZET`` and ``Py_READONLY``, for example::"
msgstr ""
"Los tipos asignados al heap (creados usando :c:func:`PyType_FromSpec` o "
"similar), ``PyMemberDef`` pueden contener definiciones para los miembros "
"especiales ``__dictoffset__``, ``__weaklistoffset__`` y "
"``__vectorcalloffset__``, correspondientes "
"a :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:`~PyTypeObject.tp_weaklistoffset` "
"y :c:member:`~PyTypeObject.tp_vectorcall_offset` en objetos de tipo. Estos "
"deben definirse con ``T_PYSSIZET`` y ``READONLY``, por ejemplo::"

#: ../Doc/c-api/structures.rst:490
msgid ""
"static PyMemberDef spam_type_members[] = {\n"
"    {\"__vectorcalloffset__\", Py_T_PYSSIZET,\n"
"     offsetof(Spam_object, vectorcall), Py_READONLY},\n"
"    {NULL}  /* Sentinel */\n"
"};"
msgstr ""

#: ../Doc/c-api/structures.rst:496
msgid "(You may need to ``#include <stddef.h>`` for :c:func:`!offsetof`.)"
msgstr ""

#: ../Doc/c-api/structures.rst:498
msgid ""
"The legacy offsets :c:member:`~PyTypeObject.tp_dictoffset` "
"and :c:member:`~PyTypeObject.tp_weaklistoffset` can be defined similarly "
"using ``\"__dictoffset__\"`` and ``\"__weaklistoffset__\"`` members, but "
"extensions are strongly encouraged to use :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"and :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead."
msgstr ""

#: ../Doc/c-api/structures.rst:506
msgid ""
"``PyMemberDef`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""

#: ../Doc/c-api/structures.rst:511
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Obtiene un atributo que pertenece al objeto en la dirección *obj_addr*. El "
"atributo se describe por ``PyMemberDef`` *m*. Retorna ``NULL`` en caso de "
"error."

#: ../Doc/c-api/structures.rst:517
msgid ""
"``PyMember_GetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""

#: ../Doc/c-api/structures.rst:522
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Establece un atributo que pertenece al objeto en la dirección *obj_addr* al "
"objeto *o*. El atributo a establecer se describe por ``PyMemberDef`` *m*. "
"Retorna ``0`` si tiene éxito y un valor negativo si falla."

#: ../Doc/c-api/structures.rst:528
msgid ""
"``PyMember_SetOne`` is always available. Previously, it required including "
"``\"structmember.h\"``."
msgstr ""

#: ../Doc/c-api/structures.rst:534
msgid "Member flags"
msgstr ""

#: ../Doc/c-api/structures.rst:536
msgid "The following flags can be used with :c:member:`PyMemberDef.flags`:"
msgstr ""

#: ../Doc/c-api/structures.rst:540
msgid "Not writable."
msgstr ""

#: ../Doc/c-api/structures.rst:544
msgid ""
"Emit an ``object.__getattr__`` :ref:`audit event <audit-events>` before "
"reading."
msgstr ""

#: ../Doc/c-api/structures.rst:549
msgid ""
"Indicates that the :c:member:`~PyMemberDef.offset` of this ``PyMemberDef`` "
"entry indicates an offset from the subclass-specific data, rather than from "
"``PyObject``."
msgstr ""

#: ../Doc/c-api/structures.rst:553
msgid ""
"Can only be used as part of :c:member:`Py_tp_members "
"<PyTypeObject.tp_members>` :c:type:`slot <PyType_Slot>` when creating a "
"class using negative :c:member:`~PyType_Spec.basicsize`. It is mandatory in "
"that case."
msgstr ""

#: ../Doc/c-api/structures.rst:558
msgid ""
"This flag is only used in :c:type:`PyType_Slot`. When "
"setting :c:member:`~PyTypeObject.tp_members` during class creation, Python "
"clears it and sets :c:member:`PyMemberDef.offset` to the offset from the "
"``PyObject`` struct."
msgstr ""

#: ../Doc/c-api/structures.rst:570
msgid ""
"The :c:macro:`!RESTRICTED`, :c:macro:`!READ_RESTRICTED` and :c:macro:`!"
"WRITE_RESTRICTED` macros available with ``#include \"structmember.h\"`` are "
"deprecated. :c:macro:`!READ_RESTRICTED` and :c:macro:`!RESTRICTED` are "
"equivalent to :c:macro:`Py_AUDIT_READ`; :c:macro:`!WRITE_RESTRICTED` does "
"nothing."
msgstr ""

#: ../Doc/c-api/structures.rst:581
msgid ""
"The :c:macro:`!READONLY` macro was renamed to :c:macro:`Py_READONLY`. "
"The :c:macro:`!PY_AUDIT_READ` macro was renamed with the ``Py_`` prefix. The "
"new names are now always available. Previously, these required ``#include "
"\"structmember.h\"``. The header is still available and it provides the old "
"names."
msgstr ""

#: ../Doc/c-api/structures.rst:590
msgid "Member types"
msgstr ""

#: ../Doc/c-api/structures.rst:592
msgid ""
":c:member:`PyMemberDef.type` can be one of the following macros "
"corresponding to various C types. When the member is accessed in Python, it "
"will be converted to the equivalent Python type. When it is set from Python, "
"it will be converted back to the C type. If that is not possible, an "
"exception such as :exc:`TypeError` or :exc:`ValueError` is raised."
msgstr ""

#: ../Doc/c-api/structures.rst:600
msgid ""
"Unless marked (D), attributes defined this way cannot be deleted using "
"e.g. :keyword:`del` or :py:func:`delattr`."
msgstr ""

#: ../Doc/c-api/structures.rst:604
msgid "Macro name"
msgstr "Nombre de la macro"

#: ../Doc/c-api/structures.rst:604
msgid "C type"
msgstr "Tipo C"

#: ../Doc/c-api/structures.rst:604
msgid "Python type"
msgstr ""

#: ../Doc/c-api/structures.rst:606
msgid ":c:expr:`char`"
msgstr ""

#: ../Doc/c-api/structures.rst:606 ../Doc/c-api/structures.rst:607
#: ../Doc/c-api/structures.rst:608 ../Doc/c-api/structures.rst:609
#: ../Doc/c-api/structures.rst:610 ../Doc/c-api/structures.rst:611
#: ../Doc/c-api/structures.rst:612 ../Doc/c-api/structures.rst:613
#: ../Doc/c-api/structures.rst:614 ../Doc/c-api/structures.rst:615
#: ../Doc/c-api/structures.rst:616
msgid ":py:class:`int`"
msgstr ""

#: ../Doc/c-api/structures.rst:607
msgid ":c:expr:`short`"
msgstr ""

#: ../Doc/c-api/structures.rst:608
msgid ":c:expr:`int`"
msgstr ""

#: ../Doc/c-api/structures.rst:609
msgid ":c:expr:`long`"
msgstr ""

#: ../Doc/c-api/structures.rst:610
#, fuzzy
msgid ":c:expr:`long long`"
msgstr "long long"

#: ../Doc/c-api/structures.rst:611
#, fuzzy
msgid ":c:expr:`unsigned char`"
msgstr "unsigned char"

#: ../Doc/c-api/structures.rst:612
#, fuzzy
msgid ":c:expr:`unsigned int`"
msgstr "unsigned int"

#: ../Doc/c-api/structures.rst:613
#, fuzzy
msgid ":c:expr:`unsigned short`"
msgstr "unsigned short"

#: ../Doc/c-api/structures.rst:614
#, fuzzy
msgid ":c:expr:`unsigned long`"
msgstr "unsigned long"

#: ../Doc/c-api/structures.rst:615
#, fuzzy
msgid ":c:expr:`unsigned long long`"
msgstr "unsigned long long"

#: ../Doc/c-api/structures.rst:616
#, fuzzy
msgid ":c:expr:`Py_ssize_t`"
msgstr "Py_ssize_t"

#: ../Doc/c-api/structures.rst:617
msgid ":c:expr:`float`"
msgstr ""

#: ../Doc/c-api/structures.rst:617 ../Doc/c-api/structures.rst:618
msgid ":py:class:`float`"
msgstr ""

#: ../Doc/c-api/structures.rst:618
msgid ":c:expr:`double`"
msgstr ""

#: ../Doc/c-api/structures.rst:619
msgid ":c:expr:`char` (written as 0 or 1)"
msgstr ""

#: ../Doc/c-api/structures.rst:619
msgid ":py:class:`bool`"
msgstr ""

#: ../Doc/c-api/structures.rst:621
#, fuzzy
msgid ":c:expr:`const char *` (*)"
msgstr "const char \\*"

#: ../Doc/c-api/structures.rst:621 ../Doc/c-api/structures.rst:622
msgid ":py:class:`str` (RO)"
msgstr ""

#: ../Doc/c-api/structures.rst:622
#, fuzzy
msgid ":c:expr:`const char[]` (*)"
msgstr "const char \\*"

#: ../Doc/c-api/structures.rst:623
msgid ":c:expr:`char` (0-127)"
msgstr ""

#: ../Doc/c-api/structures.rst:623
msgid ":py:class:`str` (**)"
msgstr ""

#: ../Doc/c-api/structures.rst:624
#, fuzzy
msgid ":c:expr:`PyObject *`"
msgstr "PyObject \\*"

#: ../Doc/c-api/structures.rst:624
msgid ":py:class:`object` (D)"
msgstr ""

#: ../Doc/c-api/structures.rst:627
msgid ""
"(*): Zero-terminated, UTF8-encoded C string. With :c:macro:`!Py_T_STRING` "
"the C representation is a pointer; with :c:macro:`!Py_T_STRING_INPLACE` the "
"string is stored directly in the structure."
msgstr ""

#: ../Doc/c-api/structures.rst:632
msgid "(**): String of length 1. Only ASCII is accepted."
msgstr ""

#: ../Doc/c-api/structures.rst:634
msgid "(RO): Implies :c:macro:`Py_READONLY`."
msgstr ""

#: ../Doc/c-api/structures.rst:636
msgid ""
"(D): Can be deleted, in which case the pointer is set to ``NULL``. Reading a "
"``NULL`` pointer raises :py:exc:`AttributeError`."
msgstr ""

#: ../Doc/c-api/structures.rst:662
msgid ""
"In previous versions, the macros were only available with ``#include "
"\"structmember.h\"`` and were named without the ``Py_`` prefix (e.g. as "
"``T_INT``). The header is still available and contains the old names, along "
"with the following deprecated types:"
msgstr ""

#: ../Doc/c-api/structures.rst:670
msgid ""
"Like ``Py_T_OBJECT_EX``, but ``NULL`` is converted to ``None``. This results "
"in surprising behavior in Python: deleting the attribute effectively sets it "
"to ``None``."
msgstr ""

#: ../Doc/c-api/structures.rst:676
msgid "Always ``None``. Must be used with :c:macro:`Py_READONLY`."
msgstr ""

#: ../Doc/c-api/structures.rst:679
msgid "Defining Getters and Setters"
msgstr ""

#: ../Doc/c-api/structures.rst:683
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Estructura para definir el acceso para un tipo como el de una propiedad. "
"Véase también la descripción de la ranura :c:member:`PyTypeObject.tp_getset`."

#: ../Doc/c-api/structures.rst:688
msgid "attribute name"
msgstr "nombre del atributo"

#: ../Doc/c-api/structures.rst:692
#, fuzzy
msgid "C function to get the attribute."
msgstr "Función C para obtener el atributo"

#: ../Doc/c-api/structures.rst:696
#, fuzzy
msgid ""
"Optional C function to set or delete the attribute. If ``NULL``, the "
"attribute is read-only."
msgstr ""
"función opcional C para establecer o eliminar el atributo, si se omite el "
"atributo es de sólo lectura"

#: ../Doc/c-api/structures.rst:701
msgid "optional docstring"
msgstr "docstring opcional"

#: ../Doc/c-api/structures.rst:705
#, fuzzy
msgid ""
"Optional user data pointer, providing additional data for getter and setter."
msgstr ""
"puntero de función opcional, proporcionar datos adicionales para *getter* y "
"*setter*"

#: ../Doc/c-api/structures.rst:709
#, fuzzy
msgid ""
"The ``get`` function takes one :c:expr:`PyObject*` parameter (the instance) "
"and a user data pointer (the associated ``closure``):"
msgstr ""
"La función ``get`` toma un parámetro :c:type:`PyObject*` (la instancia) y un "
"puntero de función (el ``closure`` asociado)::"

#: ../Doc/c-api/structures.rst:712
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Debe retornar una nueva referencia en caso de éxito o ``NULL`` con una "
"excepción establecida en caso de error."

#: ../Doc/c-api/structures.rst:717
#, fuzzy
msgid ""
"``set`` functions take two :c:expr:`PyObject*` parameters (the instance and "
"the value to be set) and a user data pointer (the associated ``closure``):"
msgstr ""
"Las funciones ``set`` toman dos parámetros :c:type:`PyObject*` (la instancia "
"y el valor a ser establecido) y un puntero de función (el ``closure`` "
"asociado)::"

#: ../Doc/c-api/structures.rst:720
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"En caso de que el atributo deba suprimirse el segundo parámetro es ``NULL``. "
"Debe retornar ``0`` en caso de éxito o ``-1`` con una excepción explícita en "
"caso de fallo."

#: ../Doc/c-api/structures.rst:370 ../Doc/c-api/structures.rst:380
msgid "built-in function"
msgstr ""

#: ../Doc/c-api/structures.rst:370
msgid "classmethod"
msgstr ""

#: ../Doc/c-api/structures.rst:380
msgid "staticmethod"
msgstr ""

#: ../Doc/c-api/structures.rst:563
msgid "READ_RESTRICTED (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:563
msgid "WRITE_RESTRICTED (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:563
msgid "RESTRICTED (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:576
msgid "READONLY (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
msgid "T_BYTE (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
msgid "T_SHORT (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
msgid "T_INT (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
msgid "T_LONG (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_LONGLONG (C macro)"
msgstr "T_LONGLONG"

#: ../Doc/c-api/structures.rst:639
msgid "T_UBYTE (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_USHORT (C macro)"
msgstr "T_USHORT"

#: ../Doc/c-api/structures.rst:639
msgid "T_UINT (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
msgid "T_ULONG (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_ULONGULONG (C macro)"
msgstr "T_ULONGLONG"

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_PYSSIZET (C macro)"
msgstr "T_PYSSIZET"

#: ../Doc/c-api/structures.rst:639
msgid "T_FLOAT (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_DOUBLE (C macro)"
msgstr "T_DOUBLE"

#: ../Doc/c-api/structures.rst:639
msgid "T_BOOL (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
msgid "T_CHAR (C macro)"
msgstr ""

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_STRING (C macro)"
msgstr "T_STRING"

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_STRING_INPLACE (C macro)"
msgstr "T_STRING"

#: ../Doc/c-api/structures.rst:639
#, fuzzy
msgid "T_OBJECT_EX (C macro)"
msgstr "T_OBJECT_EX"

#: ../Doc/c-api/structures.rst:639
msgid "structmember.h"
msgstr ""
